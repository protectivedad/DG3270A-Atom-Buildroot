diff -Naur hostapd-2.9/src/drivers/ath_ald_external.h hostapd-2.9-new/src/drivers/ath_ald_external.h
--- hostapd-2.9/src/drivers/ath_ald_external.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ath_ald_external.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,104 @@
+/*****************************************************************************/
+/* \file ath_ald_external.h
+** \brief External Header File References
+**
+**  This header file refers to the internal header files that provide the
+**  data structure definitions and parameters required by external programs
+**  that interface via ioctl or similiar mechanisms.  This hides the location
+**  of the specific header files, and provides a control to limit what is
+**  being exported for external use.
+**
+**  Copyright (c) 2009 Atheros Communications Inc.  All rights reserved.
+**
+** Permission to use, copy, modify, and/or distribute this software for any
+** purpose with or without fee is hereby granted, provided that the above
+** copyright notice and this permission notice appear in all copies.
+**
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+** WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+** MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+** ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+** WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+** ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+** OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+**/
+
+
+#ifndef ATH_ALD_EXTERNAL_H
+#define ATH_ALD_EXTERNAL_H
+
+#if ATH_SUPPORT_HYFI_ENHANCEMENTS
+#define IEEE80211_IOCTL_ALD	        (SIOCIWFIRSTPRIV+25)
+enum {
+    IEEE80211_ALD_UTILITY = 0,
+    IEEE80211_ALD_CAPACITY,
+    IEEE80211_ALD_LOAD,
+    IEEE80211_ALD_ALL,
+    IEEE80211_ALD_MAXCU,
+    IEEE80211_ALD_ASSOCIATE,
+    IEEE80211_ALD_BUFFULL_WRN,
+    IEEE80211_ALD_MCTBL_UPDATE,
+    IEEE80211_ALD_ERROR,
+};
+
+#define NETLINK_ALD 31
+#define MAX_NODES_NETWORK (64+1) // one is ap self
+typedef struct _linkcapacity_t
+{
+    u_int32_t   capacity;   // Current number of bits per second that can be delivered to the given DA.
+    u_int32_t   aggr;
+    u_int32_t   phyerr;
+    u_int32_t   lastper;
+    u_int32_t   msdusize;
+    u_int8_t    da[6];      // This linkâ€™s destination address.
+    u_int16_t   nobufs[WME_NUM_AC]; /*#pkts lost due to buff overflows per ac*/
+    u_int16_t   excretries[WME_NUM_AC];/* #pkts lost due to exc retries per ac*/
+    u_int16_t   txpktcnt[WME_NUM_AC];/* #successfully transmitted pkts per ac*/
+	u_int16_t	retries;
+	u_int32_t	aggrmax;
+} linkcapacity_t;
+
+struct ald_stat_info {
+    u_int32_t cmd;
+    u_int8_t name[IFNAMSIZ];
+    u_int32_t maxcu;
+    u_int32_t utility;
+    u_int32_t load;
+    u_int32_t txbuf;
+    u_int32_t curThroughput;
+    u_int32_t vapstatus;
+
+    u_int32_t nientry;
+    linkcapacity_t lkcapacity[MAX_NODES_NETWORK];
+};
+
+enum {
+    ALD_ACTION_ASSOC = 0,
+    ALD_ACTION_DISASSOC,
+    ALD_ACTION_MAX,
+};
+
+enum {
+    ALD_FREQ_24G = 0,
+    ALD_FREQ_5G,
+    ALD_FREQ_MAX,
+};
+
+struct ald_assoc_info {
+    u_int32_t cmd;
+    u_int8_t name[IFNAMSIZ];
+    u_int8_t macaddr[IEEE80211_ADDR_LEN];
+    u_int8_t aflag;
+    u_int8_t afreq;
+};
+
+struct ald_buffull_info {
+    u_int32_t cmd;
+    u_int8_t name[IFNAMSIZ];
+    u_int16_t resv;
+};
+
+#endif
+
+
+#endif
diff -Naur hostapd-2.9/src/drivers/ieee80211_band_steering_api.h hostapd-2.9-new/src/drivers/ieee80211_band_steering_api.h
--- hostapd-2.9/src/drivers/ieee80211_band_steering_api.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ieee80211_band_steering_api.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,240 @@
+/*
+ * @@-COPYRIGHT-START-@@
+ *
+ * Copyright (c) 2014 Qualcomm Atheros, Inc.
+ * All Rights Reserved.
+ * Qualcomm Atheros Confidential and Proprietary.
+ *
+ * @@-COPYRIGHT-END-@@
+ */
+
+#ifndef _ATH_BAND_STEERING_API__
+#define _ATH_BAND_STEERING_API__
+#define NETLINK_BAND_STEERING_EVENT 21
+#define BSTEERING_INVALID_RSSI 0
+#define IEEE80211_ADDR_LEN 6
+/**
+ * Metadata about a probe request received from a client that is useful
+ * for making band steering decisions.
+ */
+struct bs_probe_req_ind {
+    /* The MAC address of the client that sent the probe request.*/
+    u_int8_t sender_addr[IEEE80211_ADDR_LEN];
+    /*  The RSSI of the received probe request.*/
+    u_int8_t rssi;
+};
+
+/**
+ * Metadata about an authentication message that was sent with a failure
+ * code due to the client being prohibited by the ACL.
+ */
+struct bs_auth_reject_ind {
+    /* The MAC address of the client to which the authentication message 
+        was sent with a failure code.*/
+    u_int8_t client_addr[IEEE80211_ADDR_LEN];
+    /* The RSSI of the received authentication message (the one that
+       triggered the rejection).*/
+    u_int8_t rssi;
+};
+
+/**
+ * Metadata about a STA that has been authorized (security handshake has
+ * completed).
+ */
+struct bs_node_authorized_ind {
+    /* The MAC address of the client that is having its authorize status
+       changed.*/
+    u_int8_t client_addr[IEEE80211_ADDR_LEN];
+};
+
+/**
+ * Metadata about a client activity status change.
+ */
+struct bs_activity_change_ind {
+    /* The MAC address of the client that activity status changes */
+    u_int8_t client_addr[IEEE80211_ADDR_LEN];
+    /* Activity status*/
+    u_int8_t activity;
+};
+
+/**
+ * Data for a channel utilization measurement.
+ */
+struct bs_chan_utilization_ind {
+    /* The current utilization on the band, expressed as a percentage.*/
+    u_int8_t utilization;
+};
+
+/**
+ * Enumeration to mark RSSI crossing direction
+ */
+typedef enum {
+    /* RSSI not change */
+    BSTEERING_RSSI_UNCHANGED = 0,
+    /* RSSI going up */
+    BSTEERING_RSSI_UP = 1,
+    /* RSSI going down */
+    BSTEERING_RSSI_DOWN = 2
+} BSTEERING_RSSI_XING_DIRECTION;
+
+/**
+ * Metadata about a client RSSI measurement crossed threshold.
+ */
+struct bs_rssi_xing_threshold_ind {
+    /* The MAC address of the client */
+    u_int8_t client_addr[IEEE80211_ADDR_LEN];
+    /* The measured RSSI */
+    u_int8_t rssi;
+    /* Flag indicating if it crossed inactivity RSSI threshold */
+    BSTEERING_RSSI_XING_DIRECTION inact_rssi_xing;
+    /* Flag indicating if it crossed low RSSI threshold */
+    BSTEERING_RSSI_XING_DIRECTION low_rssi_xing;
+};
+
+/**
+ * Metadata about a client requested RSSI measurement
+ */
+struct bs_rssi_measurement_ind {
+    /* The MAC address of the client */
+    u_int8_t client_addr[IEEE80211_ADDR_LEN];
+    /* The measured RSSI */
+    u_int8_t rssi;
+};
+
+/**
+ * Common event structure for all Netlink indications to userspace.
+ */
+typedef struct ath_netlink_bsteering_event {
+    /* The type of the event: One of ATH_BSTEERING_EVENT.*/
+    u_int32_t type;
+    /* The band on which the event occurred.*/
+    u_int32_t band_index;
+    /* The data for the event. Which member is valid is based on the
+       type field.*/
+    union {
+        struct bs_probe_req_ind bs_probe;
+        struct bs_node_authorized_ind bs_node_authorized;
+        struct bs_activity_change_ind bs_activity_change;
+        struct bs_auth_reject_ind bs_auth;
+        struct bs_chan_utilization_ind bs_chan_util;
+        struct bs_rssi_xing_threshold_ind bs_rssi_xing;
+        struct bs_rssi_measurement_ind bs_rssi_measurement;
+    } data;
+} ath_netlink_bsteering_event_t;
+
+/**
+ * Parameters that can be configured by userspace to control the band
+ * steering events.
+ */
+typedef struct ieee80211_bsteering_param_t {
+    /* Amount of time a client has to be idle under normal (no overload)
+       conditions before it becomes a candidate for steering.*/
+    u_int32_t inactivity_timeout_normal;
+    /*  Amount of time a client has to be idle under overload conditions
+        before it becomes a candidate for steering.*/
+    u_int32_t inactivity_timeout_overload;
+    /* Frequency (in seconds) at which the client inactivity staus should
+       be checked. */
+    u_int32_t inactivity_check_period;
+    /* Frequency (in seconds) at which the medium utilization should be
+       measured. */
+    u_int32_t utilization_sample_period;
+    /* The number of samples over which the medium utilization should be
+       averaged before being reported.*/
+    u_int32_t utilization_average_num_samples;
+    /* The RSSI value for which to generate threshold crossing events for
+     an idle client. Such events are generated when the threshold is
+     crossed in either direction.*/
+    u_int32_t inactive_rssi_crossing_threshold;
+    /* The RSSI value for which to generate threshold crossing events for
+        both active and idle clients. This value should generally be less
+        than inactive_rssi_crossing_threshold.*/
+    u_int32_t low_rssi_crossing_threshold;
+} ieee80211_bsteering_param_t;
+
+/**
+ * Parameters that are used to configure lmac part band steering logic.
+ * Currently it contains inactivity related parameters.
+ */
+typedef struct ieee80211_bsteering_lmac_param_t {
+    /* Frequency (in seconds) at which the client inactivity staus should
+       be checked.*/
+    u_int32_t inactivity_check_period;
+
+    /* Number of check periods a client has to be idle under normal (no overload)
+       conditions before it becomes a candidate for steering.*/
+    u_int32_t inactivity_threshold_normal;
+
+    /* Number of check periods a client has to be idle under overload conditions
+       before it becomes a candidate for steering.*/
+    u_int32_t inactivity_threshold_overload;
+} ieee80211_bsteering_lmac_param_t;
+
+/**
+ * Parameters that must be specified to trigger an RSSI measurement by
+ * sending QoS Null Data Packets and examining the RSSI from the ACK.
+ */
+typedef struct ieee80211_bsteering_rssi_req_t {
+    /* The address of the client to measure.*/
+    u_int8_t sender_addr[IEEE80211_ADDR_LEN];
+    /* The number of consecutive measurements to make. This must be
+       at least 1.*/
+    u_int16_t num_measurements;
+} ieee80211_bsteering_rssi_req_t;
+
+/**
+ * Parameters that can be configured by userspace to enable logging of
+ * intermediate results via events to userspace.
+ */
+typedef struct ieee80211_bsteering_dbg_param_t {
+    /* Whether logging of the raw channel utilization data is enabled.*/
+    u_int8_t  raw_chan_util_log_enable:1;
+    /* Whether logging of the raw RSSI measurement is enabled.*/
+    u_int8_t  raw_rssi_log_enable:1;
+} ieee80211_bsteering_dbg_param_t;
+
+/**
+ * Event types that are asynchronously generated by the band steering
+ * module.
+ */
+typedef enum {
+    /* Indication of utilization of the channel.*/
+    ATH_EVENT_BSTEERING_CHAN_UTIL = 1,
+    /* Indication that a probe request was received from a client.*/
+    ATH_EVENT_BSTEERING_PROBE_REQ = 2,
+    /* Authorization change for a STA.*/
+    ATH_EVENT_BSTEERING_NODE_AUTHORIZED = 3,
+    /* Indication that an authentication frame was sent with a failure
+        status code.*/
+    ATH_EVENT_BSTEERING_TX_AUTH_FAIL = 4,
+    /* Indication that a client changes from active to inactive or
+       vice versa.*/
+    ATH_EVENT_BSTEERING_CLIENT_ACTIVITY_CHANGE = 5,
+    /* Indication when the client RSSI crosses above or below the
+       configured threshold.*/
+    ATH_EVENT_BSTEERING_CLIENT_RSSI_CROSSING = 6,
+    /* Indication when a requested RSSI measurement for a specific
+       client is available.*/
+    ATH_EVENT_BSTEERING_CLIENT_RSSI_MEASUREMENT = 7,
+    /*  Events generated solely for debugging purposes. These are not
+        intended for direct consumption by any algorithm components but are
+        here to facilitate logging the raw data.*/
+    ATH_EVENT_BSTEERING_DBG_CHAN_UTIL = 32,
+    /* Raw RSSI measurement event used to facilitate logging.*/
+    ATH_EVENT_BSTEERING_DBG_RSSI = 33,
+} ATH_BSTEERING_EVENT;
+
+/**
+ * The band of operation.
+ */
+typedef enum {
+    /* 2.4 GHz*/
+    BSTEERING_24G = 0,
+    /* 5 GHz */
+    BSTEERING_5G = 1,
+    BSTEERING_INVALID = 2,
+    BSTEERING_MAX = BSTEERING_INVALID,
+} BSTEERING_BAND;
+
+#undef IEEE80211_ADDR_LEN
+#endif /* _ATH_BAND_STEERING_API__ */
diff -Naur hostapd-2.9/src/drivers/ieee80211_defines.h hostapd-2.9-new/src/drivers/ieee80211_defines.h
--- hostapd-2.9/src/drivers/ieee80211_defines.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ieee80211_defines.h	2019-11-04 11:20:58.020153000 -0400
@@ -0,0 +1,1728 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Copyright (c) 2011-2014 Qualcomm Atheros, Inc.
+ * Qualcomm Atheros, Inc. has chosen to take madwifi subject to the BSD license and terms.
+ *
+ */
+
+#ifndef _IEEE80211_DEFINES_H_
+#define _IEEE80211_DEFINES_H_
+
+#include "ieee80211.h"
+#ifndef EXTERNAL_USE_ONLY
+#include <_ieee80211.h>        /* IEEE80211_ADDR_LEN, iee80211_phymode */
+#endif
+
+/*
+ * Public defines for Atheros Upper MAC Layer
+ */
+
+/**
+ * @brief Opaque handle of 802.11 protocal layer.
+ */
+struct ieee80211com;
+typedef struct ieee80211com *wlan_dev_t; 
+
+/**
+ * @brief Opaque handle to App IE module.
+*/
+struct wlan_mlme_app_ie;
+typedef struct wlan_mlme_app_ie *wlan_mlme_app_ie_t; 
+
+/**
+ * @brief Opaque handle of network instance (vap) in 802.11 protocal layer.
+*/
+struct ieee80211vap;
+typedef struct ieee80211vap *wlan_if_t; 
+
+struct ieee80211vapprofile;
+typedef struct ieee80211vapprofile *wlan_if_info_t;
+
+/**
+ * @brief Opaque handle of a node in the wifi network.
+ */
+struct ieee80211_node;
+typedef struct ieee80211_node *wlan_node_t;
+
+/**
+ * @brief Opaque handle of OS interface (ifp in the case of unix ).
+ */
+struct _os_if_t;
+typedef struct _os_if_t *os_if_t; 
+
+/**
+ *
+ * @brief Opaque handle.
+ */
+typedef void *os_handle_t; 
+
+/**
+ * @brief Opaque handle of a channel.
+ */
+struct ieee80211_channel;
+typedef struct ieee80211_channel *wlan_chan_t;
+
+/**
+ * @brief Opaque handle scan_entry.
+ */
+struct ieee80211_scan_entry; 
+typedef struct ieee80211_scan_entry *wlan_scan_entry_t;
+
+/* AoW related defines */
+#define AOW_MAX_RECEIVER_COUNT  10
+
+
+
+#define IEEE80211_NWID_LEN                  32
+#define IEEE80211_ISO_COUNTRY_LENGTH        3       /* length of 11d ISO country string */
+
+typedef struct _ieee80211_ssid {
+    int         len;
+    u_int8_t    ssid[IEEE80211_NWID_LEN + 1];
+} ieee80211_ssid;
+
+typedef struct ieee80211_tx_status {
+    int         ts_flags;
+#define IEEE80211_TX_ERROR          0x01
+#define IEEE80211_TX_XRETRY         0x02
+#define IEEE80211_TX_FLUSH          0x04
+    int         ts_retries;     /* number of retries to successfully transmit this frame */
+#ifdef ATH_SUPPORT_TxBF
+    u_int8_t    ts_txbfstatus;
+#define	AR_BW_Mismatch      0x1
+#define	AR_Stream_Miss      0x2
+#define	AR_CV_Missed        0x4
+#define AR_Dest_Miss        0x8
+#define AR_Expired          0x10
+#define AR_TxBF_Valid_HW_Status    (AR_BW_Mismatch|AR_Stream_Miss|AR_CV_Missed|AR_Dest_Miss|AR_Expired)
+#define TxBF_STATUS_Sounding_Complete   0x20
+#define TxBF_STATUS_Sounding_Request    0x40
+#define TxBF_Valid_SW_Status  (TxBF_STATUS_Sounding_Complete | TxBF_STATUS_Sounding_Request)
+#define TxBF_Valid_Status  (AR_TxBF_Valid_HW_Status | TxBF_Valid_SW_Status)
+    u_int32_t    ts_tstamp;     /* tx time stamp */
+#endif
+#if ATH_SUPPORT_FLOWMAC_MODULE
+    u_int8_t    ts_flowmac_flags;
+#define IEEE80211_TX_FLOWMAC_DONE           0x01
+#endif
+    u_int32_t    ts_rateKbps;
+} ieee80211_xmit_status;
+
+#ifndef EXTERNAL_USE_ONLY
+typedef struct ieee80211_rx_status {
+    int         rs_numchains;
+    int         rs_flags;
+#define IEEE80211_RX_FCS_ERROR      0x01
+#define IEEE80211_RX_MIC_ERROR      0x02
+#define IEEE80211_RX_DECRYPT_ERROR  0x04
+/* holes in flags here between, ATH_RX_XXXX to IEEE80211_RX_XXX */
+#define IEEE80211_RX_KEYMISS        0x200
+    int         rs_rssi;       /* RSSI (noise floor ajusted) */
+    int         rs_abs_rssi;   /* absolute RSSI */
+    int         rs_datarate;   /* data rate received */
+    int         rs_rateieee;
+    int         rs_ratephy;
+
+#define IEEE80211_MAX_ANTENNA       3                /* Keep the same as ATH_MAX_ANTENNA */
+    u_int8_t    rs_rssictl[IEEE80211_MAX_ANTENNA];   /* RSSI (noise floor ajusted) */
+    u_int8_t    rs_rssiextn[IEEE80211_MAX_ANTENNA];  /* RSSI (noise floor ajusted) */    
+    u_int8_t    rs_isvalidrssi;                      /* rs_rssi is valid or not */
+
+    enum ieee80211_phymode rs_phymode;
+    int         rs_freq;
+    
+    union {
+        u_int8_t            data[8];
+        u_int64_t           tsf;
+    } rs_tstamp;
+
+    /* 
+     * Detail channel structure of recv frame. 
+     * It could be NULL if not available 
+     */
+    struct ieee80211_channel *rs_full_chan; 
+
+#if ATH_SUPPORT_AOW
+    u_int16_t   rs_rxseq;      /* WLAN Sequence number */
+#endif
+#if ATH_VOW_EXT_STATS
+    u_int32_t vow_extstats_offset; /* Lower 16 bits holds the udp checksum offset in the data pkt */
+                                   /* Higher 16 bits contains offset in the data pkt at which vow ext stats are embedded */
+#endif
+    u_int8_t rs_isaggr;
+    u_int8_t rs_isapsd;
+    int16_t rs_noisefloor;
+    u_int16_t  rs_channel;
+#ifdef ATH_SUPPORT_TxBF
+    u_int32_t   rs_rpttstamp;   /* txbf report time stamp*/
+#endif
+
+    /* The following counts are meant to assist in stats calculation.
+       These variables are incremented only in specific situations, and
+       should not be relied upon for any purpose other than the original
+       stats related purpose they have been introduced for. */
+
+    u_int16_t   rs_cryptodecapcount; /* Crypto bytes decapped/demic'ed. */
+    u_int8_t    rs_padspace;         /* No. of padding bytes present after header
+                                        in wbuf. */
+    u_int8_t    rs_qosdecapcount;    /* QoS/HTC bytes decapped. */
+
+    /* End of stats calculation related counts. */
+
+    uint8_t     rs_lsig[IEEE80211_LSIG_LEN];
+    uint8_t     rs_htsig[IEEE80211_HTSIG_LEN];
+    uint8_t     rs_servicebytes[IEEE80211_SB_LEN];
+
+} ieee80211_recv_status;
+#endif /* EXTERNAL_USE_ONLY */
+
+/*
+ * flags to be passed to ieee80211_vap_create function .
+ */
+#define IEEE80211_CLONE_BSSID           0x0001  /* allocate unique mac/bssid */
+#define IEEE80211_CLONE_NOBEACONS       0x0002  /* don't setup beacon timers */
+#define IEEE80211_CLONE_WDS             0x0004  /* enable WDS processing */
+#define IEEE80211_CLONE_WDSLEGACY       0x0008  /* legacy WDS operation */
+#define IEEE80211_PRIMARY_VAP           0x0010  /* primary vap */
+#define IEEE80211_P2PDEV_VAP            0x0020  /* p2pdev vap */
+#define IEEE80211_P2PGO_VAP             0x0040  /* p2p-go vap */
+#define IEEE80211_P2PCLI_VAP            0x0080  /* p2p-client vap */
+#define IEEE80211_CLONE_MACADDR         0x0100  /* create vap w/ specified mac/bssid */
+#define IEEE80211_CLONE_MATADDR         0x0200  /* create vap w/ specified MAT addr */
+#define IEEE80211_WRAP_VAP              0x0400  /* wireless repeater ap vap */
+
+/*
+ * For the new multi-vap scan feature, there is a set of default priority tables
+ * for each OpMode.
+ * The following are the default list of the VAP Scan Priority Mapping based on OpModes.
+ * NOTE: the following are only used when "#if ATH_SUPPORT_MULTIPLE_SCANS" is true.
+ */
+/* For IBSS opmode */
+#define DEF_VAP_SCAN_PRI_MAP_OPMODE_IBSS_BASE               0
+/* For STA opmode */
+#define DEF_VAP_SCAN_PRI_MAP_OPMODE_STA_BASE                0
+#define DEF_VAP_SCAN_PRI_MAP_OPMODE_STA_P2P_CLIENT          1
+/* For HostAp opmode */
+#define DEF_VAP_SCAN_PRI_MAP_OPMODE_AP_BASE                 0
+#define DEF_VAP_SCAN_PRI_MAP_OPMODE_AP_P2P_GO               1
+#define DEF_VAP_SCAN_PRI_MAP_OPMODE_AP_P2P_DEVICE           2
+/* For BTAmp opmode */
+#define DEF_VAP_SCAN_PRI_MAP_OPMODE_BTAMP_BASE              0
+
+typedef enum _ieee80211_dev_vap_event {
+    IEEE80211_VAP_CREATED = 1,
+    IEEE80211_VAP_STOPPED,
+    IEEE80211_VAP_DELETED
+} ieee80211_dev_vap_event;
+
+typedef struct _wlan_dev_event_handler_table {
+    void (*wlan_dev_vap_event) (void *event_arg, wlan_dev_t, os_if_t, ieee80211_dev_vap_event);  /* callback to receive vap events*/
+#if ATH_SUPPORT_SPECTRAL
+    void (*wlan_dev_spectral_indicate)(void*, void*, u_int32_t);
+#endif
+} wlan_dev_event_handler_table;
+
+typedef enum _ieee80211_ap_stopped_reason {
+    IEEE80211_AP_STOPPED_REASON_DUMMY = 0,          /* Dummy placeholder. Should not use */
+    IEEE80211_AP_STOPPED_REASON_CHANNEL_DFS = 1,
+} ieee80211_ap_stopped_reason;
+
+typedef int IEEE80211_REASON_CODE;
+typedef int IEEE80211_STATUS;
+
+#ifndef EXTERNAL_USE_ONLY
+#include <wbuf.h> /* wbuf_t */
+typedef struct _wlan_event_handler_table {
+    void (*wlan_receive) (os_if_t osif, wbuf_t wbuf,
+                          u_int16_t type, u_int16_t subtype,
+                          ieee80211_recv_status *rs);                       /* callback to receive all the packets */
+    int  (*wlan_receive_filter_80211) (os_if_t osif, wbuf_t wbuf,
+                                       u_int16_t type, u_int16_t subtype,
+                                       ieee80211_recv_status *rs);          /* callback to receive and filter all the 802.11 frames*/
+    void (*wlan_receive_monitor_80211) (os_if_t osif, wbuf_t wbuf,
+                                        ieee80211_recv_status *rs);         /* recieve 802.11 frames for monitor mode only*/
+    int  (*wlan_dev_xmit_queue) (os_if_t osif, wbuf_t wbuf);                /* queue packet to the device for transmit */
+    void (*wlan_vap_xmit_queue) (os_if_t osif, wbuf_t wbuf);                /* queue packet to the interface for transmit */
+    void (*wlan_xmit_update_status)(os_if_t osif, wbuf_t wbuf,
+                                    ieee80211_xmit_status *ts);             /* callback to indicate tx completion.
+                                                                             * NB: this is to allow IHV to update certain statistics,
+                                                                             * it should NOT consume the wbuf */
+#if ATH_SUPPORT_IWSPY
+	void (*wlan_iwspy_update)(os_if_t osif, u_int8_t *address, int8_t rssi); /* IWSPY support, update rssi */
+#endif
+#if ATH_SUPPORT_FLOWMAC_MODULE
+    /* pause: 1-pause, 0-wake */
+    void (*wlan_pause_queue)(os_if_t osif, int pause, unsigned int pctl);
+#endif
+} wlan_event_handler_table;
+
+typedef struct _wlan_mlme_event_handler_table {
+    /* MLME confirmation handler */
+    void (*mlme_join_complete_infra)(os_handle_t, IEEE80211_STATUS);
+    void (*mlme_join_complete_adhoc)(os_handle_t, IEEE80211_STATUS);
+    void (*mlme_auth_complete)(os_handle_t, IEEE80211_STATUS);
+    void (*mlme_assoc_req)(os_handle_t, wbuf_t wbuf);
+    void (*mlme_assoc_complete)(os_handle_t, IEEE80211_STATUS, u_int16_t aid, wbuf_t wbuf);
+    void (*mlme_reassoc_complete)(os_handle_t, IEEE80211_STATUS, u_int16_t aid, wbuf_t wbuf);
+    void (*mlme_deauth_complete)(os_handle_t,u_int8_t *, IEEE80211_STATUS);
+    void (*mlme_disassoc_complete)(os_handle_t, u_int8_t *, u_int32_t, IEEE80211_STATUS);
+
+    /* MLME indication handler */
+    void (*mlme_auth_indication)(os_handle_t, u_int8_t *macaddr, u_int16_t result);
+    void (*mlme_deauth_indication)(os_handle_t, u_int8_t *macaddr, u_int16_t reason_code);
+    void (*mlme_assoc_indication)(os_handle_t, u_int8_t *macaddr, u_int16_t result, wbuf_t wbuf, wbuf_t resp_wbuf);
+    void (*mlme_reassoc_indication)(os_handle_t, u_int8_t *macaddr, u_int16_t result, wbuf_t wbuf, wbuf_t resp_wbuf);
+    void (*mlme_disassoc_indication)(os_handle_t, u_int8_t *macaddr, u_int32_t reason_code);
+    void (*mlme_ibss_merge_start_indication)(os_handle_t, u_int8_t *bssid);
+    void (*mlme_ibss_merge_completion_indication)(os_handle_t, u_int8_t *bssid);
+    void (*wlan_radar_detected) (os_if_t, u_int32_t csa_delay);
+} wlan_mlme_event_handler_table;
+
+typedef struct _wlan_misc_event_handler_table {
+    void (*wlan_channel_change) (os_handle_t, wlan_chan_t chan);
+    void (*wlan_country_changed) (os_handle_t, char *country);
+    void (*wlan_linkspeed)(os_handle_t, u_int32_t rxlinkspeed, u_int32_t txlinkspeed);
+    void (*wlan_michael_failure_indication)(os_handle_t, const u_int8_t *frm, u_int keyix);
+    void (*wlan_replay_failure_indication)(os_handle_t, const u_int8_t *frm, u_int keyix);
+    void (*wlan_beacon_miss_indication)(os_handle_t);
+    void (*wlan_beacon_rssi_indication)(os_handle_t);
+    void (*wlan_device_error_indication)(os_handle_t);
+    void (*wlan_sta_clonemac_indication)(os_handle_t);
+    void (*wlan_sta_scan_entry_update)(os_handle_t, wlan_scan_entry_t, bool);
+    void (*wlan_ap_stopped)(os_handle_t, ieee80211_ap_stopped_reason reason);
+#if ATH_SUPPORT_WAPI
+    void (*wlan_sta_rekey_indication)(os_handle_t, u_int8_t *macaddr);
+#endif
+#if ATH_SUPPORT_IBSS_NETLINK_NOTIFICATION
+    void (*wlan_ibss_rssi_monitor) (os_handle_t, u_int8_t *macaddr, u_int32_t rssi_class);
+#endif
+#if UMAC_SUPPORT_RRM_MISC
+    void (*wlan_channel_load) (os_handle_t, u_int8_t chload);
+    void (*wlan_nonerpcnt) (os_handle_t, u_int8_t erpcnt);
+    void (*wlan_bgjoin) (os_handle_t, u_int8_t val);
+    void (*wlan_cochannelap_cnt) (os_handle_t, u_int8_t val);
+#endif
+#if ATH_SUPPORT_HYFI_ENHANCEMENTS 
+    void (*wlan_buffull)(os_handle_t);
+#endif
+#if ATH_BAND_STEERING
+    void (*bsteering_event) (os_handle_t, ATH_BSTEERING_EVENT, uint32_t eventlen, const char *data, uint32_t band_index);
+#endif
+    void (*wlan_ch_hop_channel_change) (os_handle_t, u_int8_t channel);
+} wlan_misc_event_handler_table;
+
+typedef struct _wlan_ccx_handler_table {
+    void (*wlan_ccx_trigger_roam) (os_if_t,  u_int16_t reason);
+    void (*wlan_ccx_set_vperf) (os_if_t, u_int8_t);
+    void (*wlan_ccx_fill_tsrsie)(os_if_t, u_int8_t tid, u_int32_t rate, u_int8_t *frm, u_int8_t *len);
+    bool (*wlan_ccx_is_mfp)(os_if_t);
+    bool (*wlan_ccx_validate_bss)(os_if_t, wlan_scan_entry_t, int);
+    void (*wlan_ccx_process_qos)(os_if_t, u_int8_t, u_int16_t);
+    bool (*wlan_ccx_check_msdu_life)(os_if_t, u_int16_t);
+    void (*wlan_ccx_vperf_pause)(os_if_t, bool);
+} wlan_ccx_handler_table;
+
+/* action frame complete callback*/
+typedef void (*wlan_action_frame_complete_handler)(wlan_if_t vaphandle, wbuf_t wbuf, void *arg, u_int8_t *dst_addr, u_int8_t *src_addr, u_int8_t *bssid, ieee80211_xmit_status *ts);
+
+/* 
+ *                        
+ *  wlan_dev_xmit      : the OS dependent layer needs to register a callback function.
+ *                       umac layer uses this callback to xmit a packet. the implementaion
+ *                       of this  call back function would implement OS specific handling of 
+ *                       the wbuf and at the end it if it decides to xmit the wbuf it should 
+ *                       call the ath_tx_send (the ath layer xmit funtion). the implementation
+ *                       should return 0 on success and -ve value on failure.
+ *
+ *  wlan_vap_xmit      : the OS dependent layer needs to register a callback function.
+ *                       umac layer uses this callback to xmit a packet. the implementaion
+ *                       of this  call back function would implement send the packet on to the 
+ *                       transmit queue of the vap. if IEEE80211_DELIVER_80211 param is set the 
+ *                       frame is 802.11 frame else  it is ethernet (802.3) frame.
+ * 
+ *  wlan_receive       : handler to receive all the packets icluding data,mgmt,control.
+ *                       UMAC will deliver standard 802.11 frames (with qos control removed)
+ *                       if IEEE80211_DELIVER_80211 param is set. 
+ *                       UMAC will deliver ethernet frames (with 802.11 header decapped)
+ *                       if IEEE80211_DELIVER_80211 param is not set. 
+ *                       the handler should cosume the wbuf (release it eventually). 
+ *
+ *  wlan_receive_filter_80211 : handler to receive all the frames with 802.11 header unstripped but the FCS stripped at the end.
+ *                              implementation of the handler should make a copy of the wbuf and should not
+ *                              release the wbuf passed via the handler. implementation should return non zero if the packet
+ *                              should not be processed further by umac.
+ *
+ *  wlan_receive_monitor_80211 : handler to receive the  all the frames with the 802.11 header including the FCS.
+ *                               the handler should cosume the wbuf (release it eventually). 
+ *                               this function is exclusively used for monitor mode.
+ *
+ *  
+ */
+#endif /* EXTERNAL_USE_ONLY */
+/*
+ * scan API related structs.
+ */
+typedef enum _ieee80211_scan_type {
+    IEEE80211_SCAN_BACKGROUND,
+    IEEE80211_SCAN_FOREGROUND,
+    IEEE80211_SCAN_SPECTRAL,
+    IEEE80211_SCAN_REPEATER_BACKGROUND,
+    IEEE80211_SCAN_REPEATER_EXT_BACKGROUND,
+    IEEE80211_SCAN_RADIO_MEASUREMENTS,
+} ieee80211_scan_type;
+
+/*
+ * Priority numbers must be sequential, starting with 0.
+ */
+typedef enum ieee80211_scan_priority_t {
+    IEEE80211_SCAN_PRIORITY_VERY_LOW    = 0,
+    IEEE80211_SCAN_PRIORITY_LOW,
+    IEEE80211_SCAN_PRIORITY_MEDIUM,
+    IEEE80211_SCAN_PRIORITY_HIGH,
+    IEEE80211_SCAN_PRIORITY_VERY_HIGH,
+
+    IEEE80211_SCAN_PRIORITY_COUNT   /* number of priorities supported */
+} IEEE80211_SCAN_PRIORITY;
+
+typedef u_int16_t    IEEE80211_SCAN_REQUESTOR;
+typedef u_int32_t    IEEE80211_SCAN_ID;
+
+#define IEEE80211_SCAN_ID_NONE                    0
+
+/* All P2P scans currently use medium priority */
+#define IEEE80211_P2P_DEFAULT_SCAN_PRIORITY       IEEE80211_SCAN_PRIORITY_MEDIUM
+#define IEEE80211_P2P_SCAN_PRIORITY_HIGH          IEEE80211_SCAN_PRIORITY_HIGH
+
+/* Masks identifying types/ID of scans */
+#define IEEE80211_SPECIFIC_SCAN       0x00000000
+#define IEEE80211_VAP_SCAN            0x01000000
+#define IEEE80211_ALL_SCANS           0x04000000
+
+/** 
+ * host scan bit. only relevant for host/target architecture. 
+ * do not reuse this bit definition. target uses this .
+ *
+ */ 
+#define IEEE80211_HOST_SCAN           0x80000000
+#define IEEE80211_SCAN_CLASS_MASK     0xFF000000
+
+#define IEEE80211_SCAN_PASSIVE            0x0001 /* passively scan all the channels */
+#define IEEE80211_SCAN_ACTIVE             0x0002 /* actively  scan all the channels (regdomain rules still apply) */
+#define IEEE80211_SCAN_2GHZ               0x0004 /* scan 2GHz band */
+#define IEEE80211_SCAN_5GHZ               0x0008 /* scan 5GHz band */
+#define IEEE80211_SCAN_ALLBANDS           (IEEE80211_SCAN_5GHZ | IEEE80211_SCAN_2GHZ)
+#define IEEE80211_SCAN_CONTINUOUS         0x0010 /* keep scanning until maxscantime expires */
+#define IEEE80211_SCAN_FORCED             0x0020 /* forced scan (OS request) - should proceed even in the presence of data traffic */
+#define IEEE80211_SCAN_NOW                0x0040 /* scan now (User request)  - should proceed even in the presence of data traffic */
+#define IEEE80211_SCAN_ADD_BCAST_PROBE    0x0080 /* add wildcard ssid and broadcast probe request if there is none */
+#define IEEE80211_SCAN_EXTERNAL           0x0100 /* scan requested by OS */
+#define IEEE80211_SCAN_BURST              0x0200 /* scan multiple channels before returning to BSS channel */
+#define IEEE80211_SCAN_CHAN_EVENT         0x0400 /* scan chan event for  offload architectures */
+#define IEEE80211_SCAN_OFFCHAN_MGMT_TX    0x0800 /* allow mgmt transmission during off channel scan */
+#define IEEE80211_SCAN_OFFCHAN_DATA_TX    0x1000 /* allow data transmission during off channel scan */
+#define IEEE80211_SCAN_80MHZ              0x2000 /* support to scan VHT80/40 */
+#define IEEE80211_SCAN_PROM_MODE          0x4000 /* force scan with promiscous mode */
+#define IEEE80211_SCAN_PHY_ERR            0x8000 /* capture pkts with PHY errors */
+
+#define IEEE80211_SCAN_PARAMS_MAX_SSID     10
+#define IEEE80211_SCAN_PARAMS_MAX_BSSID    10
+
+
+/* flag definitions passed to scan_cancel API */
+
+#define IEEE80211_SCAN_CANCEL_ASYNC 0x0 /* asynchronouly wait for scan SM to complete cancel */ 
+#define IEEE80211_SCAN_CANCEL_WAIT  0x1 /* wait for scan SM to complete cancel */ 
+#define IEEE80211_SCAN_CANCEL_SYNC  0x2 /* synchronously execute cancel scan */ 
+
+/* Scan Parameters for Enhanced-Independent-Repeater */
+#define MIN_REST_TIME 500
+#define MAX_REST_TIME 600 
+#define MIN_DWELL_TIME_ACTIVE 150
+#define MAX_DWELL_TIME_ACTIVE 200
+#define INIT_REST_TIME 14000
+
+#ifndef EXTERNAL_USE_ONLY
+typedef bool (*ieee80211_scan_termination_check) (void *arg);
+
+typedef struct _ieee80211_scan_params {
+    ieee80211_scan_type                 type;
+    int                                 min_dwell_time_active;  /* min time in msec on active channels */
+    int                                 max_dwell_time_active;  /* max time in msec on active channels (if no response) */
+    int                                 min_dwell_time_passive; /* min time in msec on passive channels */
+    int                                 max_dwell_time_passive; /* max time in msec on passive channels (if no response) */
+    int                                 min_rest_time;          /* min time in msec on the BSS channel, only valid for BG scan */
+    int                                 init_rest_time;        /*  used by EIRPTR - min time in msec on the BSS channel, only valid for BG scan */
+    int                                 max_rest_time;          /* max time in msec on the BSS channel, only valid for BG scan */
+    int                                 max_offchannel_time;    /* max time away from BSS channel, in ms */
+    int                                 repeat_probe_time;      /* time before sending second probe request */
+    int                                 idle_time;              /* time in msec on bss channel before switching channel */
+    int                                 max_scan_time;          /* maximum time in msec allowed for scan  */
+    int                                 probe_delay;            /* delay in msec before sending probe request */
+    int                                 offchan_retry_delay;    /* delay in msec before retrying off-channel switch */
+    int                                 min_beacon_count;       /* number of home AP beacons to receive before leaving the home channel */
+    int                                 max_offchan_retries;    /* maximum number of times to retry off-channel switch */
+    int                                 beacon_timeout;         /* maximum time to wait for beacons */
+    int                                 flags;                  /* scan flags */
+    int                                 num_channels;           /* number of channels to scan */
+    bool                                multiple_ports_active;  /* driver has multiple ports active in the home channel */
+    bool                                restricted_scan;        /* Perform restricted scan */
+    bool                                chan_list_allocated;
+    IEEE80211_SCAN_PRIORITY             p2p_scan_priority;      /* indicates the scan priority if this is a P2P-related scan */
+    u_int32_t                           *chan_list;             /* array of ieee channels (or) frequencies to scan */
+    int                                 num_ssid;               /* number of desired ssids */
+    ieee80211_ssid                      ssid_list[IEEE80211_SCAN_PARAMS_MAX_SSID];
+    int                                 num_bssid;              /* number of desired bssids */
+    u_int8_t                            bssid_list[IEEE80211_SCAN_PARAMS_MAX_BSSID][IEEE80211_ADDR_LEN];
+    struct ieee80211_node               *bss_node;              /* BSS node */
+    int                                 ie_len;                 /* length of the ie data to be added to probe req */ 
+    u_int8_t                            *ie_data;               /* pointer to ie data */
+    ieee80211_scan_termination_check    check_termination_function;  /* function checking for termination condition */
+    void                                *check_termination_context;  /* context passed to function above */
+} ieee80211_scan_params;
+
+/* Data types used to specify scan priorities */
+typedef u_int32_t IEEE80211_PRIORITY_MAPPING[IEEE80211_SCAN_PRIORITY_COUNT];
+
+/**************************************
+ * Called before attempting to roam.  Modifies the rssiAdder of a BSS
+ * based on the preferred status of a BSS.
+ *
+ * According to CCX spec, AP in the neighbor list is not meant for giving extra
+ * weightage in roaming. By doing so, roaming becomes sticky. See bug 21220.
+ * Change the weightage to 0. Cisco may ask in future for a user control of
+ * this weightage.
+ */
+#define PREFERRED_BSS_RANK                20
+#define NEIGHBOR_BSS_RANK                  0    /* must be less than preferred BSS rank */
+
+/*
+ * The utility of the BSS is the metric used in the selection
+ * of a BSS. The Utility of the BSS is reduced if we just left the BSS.
+ * The Utility of the BSS is not reduced if we have left the
+ * BSS for 8 seconds (8000ms) or more.
+ * 2^13 milliseconds is a close approximation to avoid expensive division
+ */
+#define LAST_ASSOC_TIME_DELTA_REQUIREMENT (1 << 13) // 8192
+
+#define QBSS_SCALE_MAX                   255  /* Qbss channel load Max value */
+#define QBSS_SCALE_DOWN_FACTOR             2  /* scale factor to reduce Qbss channel load */
+#define QBSS_HYST_ADJ                     60  /* Qbss Weightage factor for the current AP */
+
+/*
+ * Flags used to set field APState
+ */
+#define AP_STATE_GOOD    0x00
+#define AP_STATE_BAD     0x01
+#define AP_STATE_RETRY   0x10
+#define BAD_AP_TIMEOUT   6000   // In milli seconds
+/*
+ * To disable BAD_AP status check on any scan entry
+ */
+#define BAD_AP_TIMEOUT_DISABLED             0
+
+/*
+ * BAD_AP timeout specified in seconds
+ */
+#define BAD_AP_TIMEOUT_IN_SECONDS           10
+
+/*
+ * State values used to represent our assoc_state with ap (discrete, not bitmasks)
+ */
+#define AP_ASSOC_STATE_NONE     0
+#define AP_ASSOC_STATE_AUTH     1
+#define AP_ASSOC_STATE_ASSOC    2
+
+/*
+ * Entries in the scan list are considered obsolete after 75 seconds.
+ */
+#define IEEE80211_SCAN_ENTRY_EXPIRE_TIME           75000
+
+/*
+ * idle time is only valid for scan type IEEE80211_SCAN_BACKGROUND.
+ * if idle time is set then the scanner would change channel from BSS
+ * channel to foreign channel only if both resttime is expired and 
+ * the theres was not traffic for idletime msec on the bss channel.
+ * value of 0 for idletime would cause the channel to switch from BSS
+ * channel to foreign channel as soon  as the resttime is expired.
+ *
+ * if maxscantime is nonzero and if the scanner can not complete the 
+ * scan in maxscantime msec then the scanner will cancel the scan and
+ * post IEEE80211_SCAN_COMPLETED event with reason SCAN_TIMEDOUT.
+ *
+ */  
+
+/*
+ * chanlist can be either ieee channels (or) frequencies.
+ * if a value is less than 1000 implementation assumes it 
+ * as ieee channel # otherwise implementation assumes it 
+ * as frequency in Mhz.
+ */ 
+
+typedef enum _ieee80211_scan_event_type {
+    IEEE80211_SCAN_STARTED,
+    IEEE80211_SCAN_COMPLETED,
+    IEEE80211_SCAN_RADIO_MEASUREMENT_START,
+    IEEE80211_SCAN_RADIO_MEASUREMENT_END,
+    IEEE80211_SCAN_RESTARTED,
+    IEEE80211_SCAN_HOME_CHANNEL,
+    IEEE80211_SCAN_FOREIGN_CHANNEL,
+    IEEE80211_SCAN_BSSID_MATCH,
+    IEEE80211_SCAN_FOREIGN_CHANNEL_GET_NF,
+    IEEE80211_SCAN_DEQUEUED,
+    IEEE80211_SCAN_PREEMPTED,
+
+    IEEE80211_SCAN_EVENT_COUNT
+} ieee80211_scan_event_type;
+
+#define IEEE80211_SCAN_CHAN_SHIFT       0
+#define IEEE80211_SCAN_CHAN_MASK        0xffff
+#define IEEE80211_SCAN_CHAN_MODE_SHIFT  16
+#define IEEE80211_SCAN_CHAN_MODE_MASK   0xff
+
+typedef enum _ieee80211_scan_chan_mode {
+   IEEE80211_SCAN_CHAN_MODE_NONE,
+   IEEE80211_SCAN_CHAN_MODE_11NA_HT20,
+   IEEE80211_SCAN_CHAN_MODE_11NG_HT20,
+   IEEE80211_SCAN_CHAN_MODE_11NA_HT40,
+   IEEE80211_SCAN_CHAN_MODE_11NG_HT40,
+   IEEE80211_SCAN_CHAN_MODE_11AC_VHT20,
+   IEEE80211_SCAN_CHAN_MODE_11AC_VHT40,
+   IEEE80211_SCAN_CHAN_MODE_11AC_VHT80,
+   IEEE80211_SCAN_CHAN_MODE_11AC_VHT20_2G,
+   IEEE80211_SCAN_CHAN_MODE_11AC_VHT40_2G,
+   IEEE80211_SCAN_CHAN_MODE_11AC_VHT80_2G,
+} ieee80211_scan_chan_mode_t;
+
+typedef enum ieee80211_scan_completion_reason {
+    IEEE80211_REASON_NONE,
+    IEEE80211_REASON_COMPLETED,
+    IEEE80211_REASON_CANCELLED,
+    IEEE80211_REASON_TIMEDOUT,
+    IEEE80211_REASON_TERMINATION_FUNCTION,
+    IEEE80211_REASON_MAX_OFFCHAN_RETRIES,
+    IEEE80211_REASON_PREEMPTED,
+    IEEE80211_REASON_RUN_FAILED,
+    IEEE80211_REASON_INTERNAL_STOP,
+
+    IEEE80211_REASON_COUNT
+} ieee80211_scan_completion_reason;
+
+typedef struct _ieee80211_scan_event {
+    ieee80211_scan_event_type           type;
+    ieee80211_scan_completion_reason    reason;
+    wlan_chan_t                         chan;
+    IEEE80211_SCAN_REQUESTOR            requestor; /* Requestor ID passed to the scan_start function */
+    IEEE80211_SCAN_ID                   scan_id;   /* Specific ID of the scan reporting the event */
+} ieee80211_scan_event;
+
+typedef enum _ieee80211_scan_request_status {
+    IEEE80211_SCAN_STATUS_QUEUED,
+    IEEE80211_SCAN_STATUS_RUNNING,
+    IEEE80211_SCAN_STATUS_PREEMPTED,
+    IEEE80211_SCAN_STATUS_COMPLETED
+} ieee80211_scan_request_status;
+
+/*
+ * the sentry field of tht ieee80211_scan_event is only valid if the
+ * event type is IEEE80211_SCAN_BSSID_MATCH.
+ */
+
+typedef void (*ieee80211_scan_event_handler) (wlan_if_t vaphandle, ieee80211_scan_event *event, void *arg);  
+
+typedef struct _ieee80211_scan_info {
+    ieee80211_scan_type                type;
+    IEEE80211_SCAN_REQUESTOR           requestor;                   /* Originator ID passed to the scan_start function */
+    IEEE80211_SCAN_ID                  scan_id;                     /* Specific ID of the scan reporting the event */
+    IEEE80211_SCAN_PRIORITY            priority;                    /* Requested priority level (low/medium/high) */
+    ieee80211_scan_request_status      scheduling_status;           /* Queued/running/preempted/completed */
+    int                                min_dwell_time_active;       /* min time in msec on active channels */
+    int                                max_dwell_time_active;       /* max time in msec on active channel (if no response) */
+    int                                min_dwell_time_passive;      /* min time in msec on passive channels */
+    int                                max_dwell_time_passive;      /* max time in msec on passive channel*/
+    int                                min_rest_time;               /* min time in msec on the BSS channel, only valid for BG scan */
+    int                                max_rest_time;               /* max time in msec on the BSS channel, only valid for BG scan */
+    int                                max_offchannel_time;         /* max time away from BSS channel, in ms */
+    int                                repeat_probe_time;           /* time before sending second probe request */
+    int                                min_beacon_count;            /* number of home AP beacons to receive before leaving the home channel */
+    int                                flags;                       /* scan flags */
+    systime_t                          scan_start_time;             /* system time when last scani started */ 
+    int                                scanned_channels;            /* number of scanned channels */
+    int                                default_channel_list_length; /* number of channels in the default channel list */
+    int                                channel_list_length;         /* number of channels in the channel list used for the current scan */
+    int                                in_progress            : 1,  /* if the scan is in progress */
+                                       cancelled              : 1,  /* if the scan is cancelled */
+                                       preempted              : 1,  /* if the scan is preempted */
+                                       restricted             : 1;  /* if the scan is restricted */
+} ieee80211_scan_info;
+
+typedef struct _ieee80211_scan_request_info {
+    wlan_if_t                        vaphandle;
+    IEEE80211_SCAN_REQUESTOR         requestor;
+    IEEE80211_SCAN_PRIORITY          requested_priority;
+    IEEE80211_SCAN_PRIORITY          absolute_priority;
+    IEEE80211_SCAN_ID                scan_id;
+    ieee80211_scan_request_status    scheduling_status;
+    ieee80211_scan_params            params;
+    systime_t                        request_timestamp;
+    u_int32_t                        maximum_duration;
+} ieee80211_scan_request_info;
+
+#endif /* EXTERNAL_USE_ONLY */
+
+#ifndef EXTERNAL_USE_ONLY
+typedef void (*ieee80211_acs_event_handler) (void *arg, wlan_chan_t channel);  
+typedef void (*ieee80211_acs_scantimer_handler) (void *arg);  
+#endif /* EXTERNAL_USE_ONLY */
+
+#define MAX_CHAINS 3
+
+typedef struct _wlan_rssi_info {
+    int8_t      avg_rssi;     /* average rssi */
+    u_int8_t    valid_mask;   /* bitmap of valid elements in rssi_ctrl/ext array */
+    int8_t      rssi_ctrl[MAX_CHAINS];
+    int8_t      rssi_ext[MAX_CHAINS];
+} wlan_rssi_info;
+
+typedef enum _wlan_rssi_type {
+    WLAN_RSSI_TX,
+    WLAN_RSSI_RX,
+    WLAN_RSSI_BEACON,  /* rssi of the beacon, only valid for STA/IBSS vap */
+    WLAN_RSSI_RX_DATA
+} wlan_rssi_type;
+
+typedef enum _ieee80211_rate_type {
+    IEEE80211_RATE_TYPE_LEGACY,
+    IEEE80211_RATE_TYPE_MCS,
+} ieee80211_rate_type;
+
+typedef struct _ieee80211_rate_info {
+    ieee80211_rate_type    type;
+    u_int32_t              rate;     /* average rate in kbps */
+    u_int32_t              lastrate; /* last packet rate in kbps */
+    u_int8_t               mcs;      /* mcs index . is valid if rate type is MCS20 or MCS40 */
+    u_int8_t               maxrate_per_client;
+} ieee80211_rate_info;
+
+typedef enum _ieee80211_node_param_type {
+    IEEE80211_NODE_PARAM_TX_POWER,
+    IEEE80211_NODE_PARAM_ASSOCID,
+    IEEE80211_NODE_PARAM_INACT,     /* inactivity timer value */
+    IEEE80211_NODE_PARAM_AUTH_MODE, /* auth mode */
+    IEEE80211_NODE_PARAM_CAP_INFO,  /* auth mode */
+} ieee80211_node_param_type;
+
+/*
+ * Per/node (station) statistics available when operating as an AP.
+ */
+struct ieee80211_nodestats {
+    u_int32_t    ns_rx_data;             /* rx data frames */
+    u_int32_t    ns_rx_mgmt;             /* rx management frames */
+    u_int32_t    ns_rx_ctrl;             /* rx control frames */
+    u_int32_t    ns_rx_ucast;            /* rx unicast frames */
+    u_int32_t    ns_rx_mcast;            /* rx multi/broadcast frames */
+    u_int64_t    ns_rx_bytes;            /* rx data count (bytes) */
+    u_int64_t    ns_rx_beacons;          /* rx beacon frames */
+    u_int32_t    ns_rx_proberesp;        /* rx probe response frames */
+
+    u_int32_t    ns_rx_dup;              /* rx discard 'cuz dup */
+    u_int32_t    ns_rx_noprivacy;        /* rx w/ wep but privacy off */
+    u_int32_t    ns_rx_wepfail;          /* rx wep processing failed */
+    u_int32_t    ns_rx_demicfail;        /* rx demic failed */
+       
+    /* We log MIC and decryption failures against Transmitter STA stats.
+       Though the frames may not actually be sent by STAs corresponding
+       to TA, the stats are still valuable for some customers as a sort
+       of rough indication.
+       Also note that the mapping from TA to STA may fail sometimes. */
+    u_int32_t    ns_rx_tkipmic;          /* rx TKIP MIC failure */
+    u_int32_t    ns_rx_ccmpmic;          /* rx CCMP MIC failure */
+    u_int32_t    ns_rx_wpimic;           /* rx WAPI MIC failure */
+    u_int32_t    ns_rx_tkipicv;          /* rx ICV check failed (TKIP) */
+    u_int32_t    ns_rx_decap;            /* rx decapsulation failed */
+    u_int32_t    ns_rx_defrag;           /* rx defragmentation failed */
+    u_int32_t    ns_rx_disassoc;         /* rx disassociation */
+    u_int32_t    ns_rx_deauth;           /* rx deauthentication */
+    u_int32_t    ns_rx_action;           /* rx action */
+    u_int32_t    ns_rx_decryptcrc;       /* rx decrypt failed on crc */
+    u_int32_t    ns_rx_unauth;           /* rx on unauthorized port */
+    u_int32_t    ns_rx_unencrypted;      /* rx unecrypted w/ privacy */
+
+    u_int32_t    ns_tx_data;             /* tx data frames */
+    u_int32_t    ns_tx_data_success;     /* tx data frames successfully
+                                            transmitted (unicast only) */
+    u_int32_t    ns_tx_mgmt;             /* tx management frames */
+    u_int32_t    ns_tx_ucast;            /* tx unicast frames */
+    u_int32_t    ns_tx_mcast;            /* tx multi/broadcast frames */
+    u_int64_t    ns_tx_bytes;            /* tx data count (bytes) */
+    u_int64_t    ns_tx_bytes_success;    /* tx success data count - unicast only
+                                            (bytes) */
+    u_int32_t    ns_tx_probereq;         /* tx probe request frames */
+    u_int32_t    ns_tx_uapsd;            /* tx on uapsd queue */
+    u_int32_t    ns_tx_discard;          /* tx dropped by NIC */
+    u_int32_t    ns_is_tx_not_ok;        /* tx not ok */
+    u_int32_t    ns_tx_novlantag;        /* tx discard 'cuz no tag */
+    u_int32_t    ns_tx_vlanmismatch;     /* tx discard 'cuz bad tag */
+
+    u_int32_t    ns_tx_eosplost;         /* uapsd EOSP retried out */
+
+    u_int32_t    ns_ps_discard;          /* ps discard 'cuz of age */
+
+    u_int32_t    ns_uapsd_triggers;      /* uapsd triggers */
+    u_int32_t    ns_uapsd_duptriggers;    /* uapsd duplicate triggers */
+    u_int32_t    ns_uapsd_ignoretriggers; /* uapsd duplicate triggers */
+    u_int32_t    ns_uapsd_active;         /* uapsd duplicate triggers */
+    u_int32_t    ns_uapsd_triggerenabled; /* uapsd duplicate triggers */
+    u_int32_t    ns_last_tx_rate;
+    u_int32_t    ns_last_rx_rate;
+    u_int32_t    ns_is_tx_nobuf;
+
+    /* MIB-related state */
+    u_int32_t    ns_tx_assoc;            /* [re]associations */
+    u_int32_t    ns_tx_assoc_fail;       /* [re]association failures */
+    u_int32_t    ns_tx_auth;             /* [re]authentications */
+    u_int32_t    ns_tx_auth_fail;        /* [re]authentication failures*/
+    u_int32_t    ns_tx_deauth;           /* deauthentications */
+    u_int32_t    ns_tx_deauth_code;      /* last deauth reason */
+    u_int32_t    ns_tx_disassoc;         /* disassociations */
+    u_int32_t    ns_tx_disassoc_code;    /* last disassociation reason */
+    u_int32_t    ns_psq_drops;           /* power save queue drops */
+    
+    /* IQUE-HBR related state */
+#ifdef ATH_SUPPORT_IQUE
+	u_int32_t	ns_tx_dropblock;	/* tx discard 'cuz headline block */
+#endif
+};
+
+/*
+ * station power save mode.
+ */
+typedef enum ieee80211_psmode {
+    IEEE80211_PWRSAVE_NONE = 0,          /* no power save */
+    IEEE80211_PWRSAVE_LOW,
+    IEEE80211_PWRSAVE_NORMAL,
+    IEEE80211_PWRSAVE_MAXIMUM,
+    IEEE80211_PWRSAVE_WNM                /* WNM-Sleep Mode */
+} ieee80211_pwrsave_mode;
+
+/* station power save pspoll handling */
+typedef enum {
+  IEEE80211_CONTINUE_PSPOLL_FOR_MORE_DATA,
+  IEEE80211_WAKEUP_FOR_MORE_DATA,
+} ieee80211_pspoll_moredata_handling;
+
+/*
+ * apps power save state.
+ */
+typedef enum {
+     APPS_AWAKE = 0,
+     APPS_PENDING_SLEEP,
+     APPS_SLEEP,
+     APPS_FAKE_SLEEP,           /* Pending blocking sleep */
+     APPS_FAKING_SLEEP,         /* Blocking sleep */
+     APPS_UNKNOWN_PWRSAVE,
+} ieee80211_apps_pwrsave_state;
+
+typedef enum _iee80211_mimo_powersave_mode {
+    IEEE80211_MIMO_POWERSAVE_NONE,    /* no mimo power save */
+    IEEE80211_MIMO_POWERSAVE_STATIC,  /* static mimo power save */
+    IEEE80211_MIMO_POWERSAVE_DYNAMIC  /* dynamic mimo powersave */
+} ieee80211_mimo_powersave_mode;
+
+#ifdef ATH_COALESCING
+typedef enum _ieee80211_coalescing_state {
+    IEEE80211_COALESCING_DISABLED   = 0,        /* Coalescing is disabled*/
+    IEEE80211_COALESCING_DYNAMIC    = 1,        /* Dynamically move to Enabled state based on Uruns*/
+    IEEE80211_COALESCING_ENABLED    = 2,        /* Coalescing is enabled*/
+} ieee80211_coalescing_state;
+
+#define IEEE80211_TX_COALESCING_THRESHOLD     5 /* Number of underrun errors to trigger coalescing */
+#endif
+
+typedef enum _ieee80211_cap {
+    IEEE80211_CAP_SHSLOT,                    /* CAPABILITY: short slot */
+    IEEE80211_CAP_SHPREAMBLE,                /* CAPABILITY: short premable */
+    IEEE80211_CAP_MULTI_DOMAIN,              /* CAPABILITY: multiple domain */
+    IEEE80211_CAP_WMM,                       /* CAPABILITY: WMM */
+    IEEE80211_CAP_HT,                        /* CAPABILITY: HT */
+    IEEE80211_CAP_PERF_PWR_OFLD,             /* CAPABILITY: power performance offload support */
+    IEEE80211_CAP_11AC,                      /* CAPABILITY: 11ac support */
+} ieee80211_cap;
+
+typedef enum _ieee80211_device_param {
+	IEEE80211_DEVICE_RSSI_CTL,
+    IEEE80211_DEVICE_NUM_TX_CHAIN,
+    IEEE80211_DEVICE_NUM_RX_CHAIN,
+    IEEE80211_DEVICE_TX_CHAIN_MASK,
+    IEEE80211_DEVICE_RX_CHAIN_MASK,
+    IEEE80211_DEVICE_TX_CHAIN_MASK_LEGACY,
+    IEEE80211_DEVICE_RX_CHAIN_MASK_LEGACY, 
+    IEEE80211_DEVICE_BMISS_LIMIT,            /* # of beacon misses for HW to generate BMISS intr */
+    IEEE80211_DEVICE_PROTECTION_MODE,        /* protection mode*/
+    IEEE80211_DEVICE_BLKDFSCHAN,             /* block the use of DFS channels */
+    IEEE80211_DEVICE_GREEN_AP_PS_ENABLE,
+    IEEE80211_DEVICE_GREEN_AP_PS_TIMEOUT,
+    IEEE80211_DEVICE_GREEN_AP_PS_ON_TIME,
+    IEEE80211_DEVICE_CWM_EXTPROTMODE,
+    IEEE80211_DEVICE_CWM_EXTPROTSPACING,
+    IEEE80211_DEVICE_CWM_ENABLE,
+    IEEE80211_DEVICE_CWM_EXTBUSYTHRESHOLD,
+    IEEE80211_DEVICE_DOTH,
+    IEEE80211_DEVICE_ADDBA_MODE,
+    IEEE80211_DEVICE_COUNTRYCODE,
+    IEEE80211_DEVICE_MULTI_CHANNEL,           /* turn on/off off channel support */    
+    IEEE80211_DEVICE_MAX_AMSDU_SIZE,          /* Size of AMSDU to be sent on the air */
+#if ATH_SUPPORT_IBSS_HT 
+    IEEE80211_DEVICE_HT20ADHOC,
+    IEEE80211_DEVICE_HT40ADHOC,
+    IEEE80211_DEVICE_HTADHOCAGGR,
+#endif
+    IEEE80211_DEVICE_P2P,                     /* Enable or Disable P2P */
+    IEEE80211_DEVICE_OVERRIDE_SCAN_PROBERESPONSE_IE, /* Override scan Probe response IE, 0: Don't over-ride */
+    IEEE80211_DEVICE_2G_CSA,
+    IEEE80211_DEVICE_PWRTARGET,
+    IEEE80211_DEVICE_OFF_CHANNEL_SUPPORT,
+    IEEE80211_DEVICE_GREEN_AP_ENABLE_PRINT,
+} ieee80211_device_param;
+
+typedef enum _ieee80211_param {
+    IEEE80211_BEACON_INTVAL,                 /* in TUs */
+#if ATH_SUPPORT_AP_WDS_COMBO
+    IEEE80211_NO_BEACON,                     /* the vap does not tx beacon/probe resp. */
+#endif
+    IEEE80211_LISTEN_INTVAL,                 /* number of beacons */
+    IEEE80211_DTIM_INTVAL,                   /* number of beacons */
+    IEEE80211_BMISS_COUNT_RESET,             /* number of beacon miss intrs before reset */
+    IEEE80211_BMISS_COUNT_MAX,               /* number of beacon miss intrs for bmiss notificationst */
+    IEEE80211_ATIM_WINDOW,                   /* ATIM window */
+    IEEE80211_SHORT_SLOT,                    /* short slot on/off */
+    IEEE80211_SHORT_PREAMBLE,                /* short preamble on/off */
+    IEEE80211_RTS_THRESHOLD,                 /* rts threshold, 0 means no rts threshold  */
+    IEEE80211_FRAG_THRESHOLD,                /* fragmentation threshold, 0 means no rts threshold  */
+    IEEE80211_FIXED_RATE,                    /* 
+                                              * rate code series(0: auto rate, 32 bit value:  rate 
+                                              * codes for 4 rate series. each byte for one rate series) 
+                                              */
+    IEEE80211_MCAST_RATE,                    /* rate in Kbps */
+    IEEE80211_TXPOWER,                       /* in 0.5db units */
+    IEEE80211_AMPDU_DENCITY,                 /* AMPDU dencity*/
+    IEEE80211_AMPDU_LIMIT,                   /* AMPDU limit*/
+    IEEE80211_MAX_AMPDU,                     /* Max AMPDU Exp*/
+    IEEE80211_VHT_MAX_AMPDU,                 /* VHT Max AMPDU Exp */
+    IEEE80211_WPS_MODE,                      /* WPS mode*/
+    IEEE80211_TSN_MODE,                      /* TSN mode*/
+    IEEE80211_MULTI_DOMAIN,                  /* Multiple domain */
+    IEEE80211_SAFE_MODE,                     /* Safe mode */
+    IEEE80211_NOBRIDGE_MODE,                 /* No bridging done, all frames sent up the stack */
+    IEEE80211_PERSTA_KEYTABLE_SIZE,          /* IBSS-only, read-only: persta key table size */
+    IEEE80211_RECEIVE_80211,                 /* deliver std 802.11 frames 802.11 instead of ethernet frames on the rx */
+    IEEE80211_SEND_80211,                    /* OS sends std 802.11 frames 802.11 instead of ethernet frames on tx side */
+    IEEE80211_MIN_BEACON_COUNT,              /* minumum number beacons to tx/rx before vap can pause */
+    IEEE80211_IDLE_TIME,                     /* minimun no activity time before vap can pause */
+    IEEE80211_MIN_FRAMESIZE,                 /* smallest frame size we are allowed to receive */
+                                             /* features. 0:feature is off. 1:feature is on. */
+    IEEE80211_FEATURE_WMM,                   /* WMM */
+    IEEE80211_FEATURE_WMM_PWRSAVE,           /* WMM Power Save */
+    IEEE80211_FEATURE_UAPSD,                 /* UAPSD setting (BE/BK/VI/VO) */
+    IEEE80211_FEATURE_WDS,                   /* dynamic WDS feature */
+    IEEE80211_FEATURE_PRIVACY,               /* encryption */
+    IEEE80211_FEATURE_DROP_UNENC,            /* drop un encrypted frames */
+    IEEE80211_FEATURE_COUNTER_MEASURES ,     /* turn on couter measures */
+    IEEE80211_FEATURE_HIDE_SSID,             /* turn on hide ssid feature */
+    IEEE80211_FEATURE_APBRIDGE,              /* turn on internal mcast traffic bridging for AP */
+    IEEE80211_FEATURE_PUREB,                 /* turn on pure B mode for AP */
+    IEEE80211_FEATURE_PUREG,                 /* turn on pure G mode for AP */
+    IEEE80211_FEATURE_REGCLASS,              /* add regulatory class IE in AP */
+    IEEE80211_FEATURE_COUNTRY_IE,            /* add country IE for vap in AP */
+    IEEE80211_FEATURE_IC_COUNTRY_IE,         /* add country IE for ic in AP */
+    IEEE80211_FEATURE_DOTH,                  /* enable 802.11h */
+    IEEE80211_FEATURE_PURE11N,               /* enable pure 11n  mode */
+    IEEE80211_FEATURE_PRIVATE_RSNIE,         /* enable OS shim to setup RSN IE*/
+    IEEE80211_FEATURE_COPY_BEACON,           /* keep a copy of beacon */
+    IEEE80211_FEATURE_PSPOLL,                /* enable/disable pspoll mode in power save SM */
+    IEEE80211_FEATURE_CONTINUE_PSPOLL_FOR_MOREDATA, /* enable/disable option to contunue sending ps polls when there is more data */
+    IEEE80211_FEATURE_AMPDU,                 /* Enable or Disable Aggregation */
+#ifdef ATH_COALESCING
+    IEEE80211_FEATURE_TX_COALESCING,         /* enable tx coalescing */
+#endif
+    IEEE80211_FEATURE_VAP_IND,               /* Repeater independant VAP */   
+    IEEE80211_FEATURE_VAP_ENHIND,            /* enhanced Repeater independant VAP */ 
+    IEEE80211_FEATURE_EXTAP,                 /* Extender AP */
+    IEEE80211_FIXED_RETRIES,                 /* fixed retries  0-4 */
+    IEEE80211_SHORT_GI,                      /* short gi on/off */
+    IEEE80211_HT40_INTOLERANT,
+    IEEE80211_CHWIDTH,
+    IEEE80211_CHEXTOFFSET,
+    IEEE80211_DISABLE_2040COEXIST,
+    IEEE80211_DISABLE_HTPROTECTION,
+    IEEE80211_STA_QUICKKICKOUT,
+    IEEE80211_CHSCANINIT,
+    IEEE80211_FEATURE_STAFWD,                /* dynamic AP Client  feature */
+    IEEE80211_DRIVER_CAPS,
+    IEEE80211_BANDWIDTH,
+    IEEE80211_FREQ_BAND,
+    IEEE80211_EXTCHAN,
+#if ATH_SUPPORT_IQUE
+    IEEE80211_IQUE_CONFIG,
+    IEEE80211_ME,                            /* mcast enhancement mode */
+	IEEE80211_MEDEBUG,
+	IEEE80211_MEDUMP,
+	IEEE80211_ME_SNOOPLENGTH,
+	IEEE80211_ME_TIMER,
+	IEEE80211_ME_TIMEOUT,
+	IEEE80211_ME_DROPMCAST,
+    IEEE80211_ME_SHOWDENY,
+    IEEE80211_ME_CLEARDENY,
+    IEEE80211_ME_ADDDENY,
+    IEEE80211_HBR_TIMER,
+#endif //ATH_SUPPORT_IQUE
+    IEEE80211_UAPSD_MAXSP,                    /* UAPSD service period setting (0:unlimited, 2,4,6) */
+    IEEE80211_WEP_MBSSID,
+    IEEE80211_MGMT_RATE,                      /* ieee rate to be used for management*/ 
+    IEEE80211_RESMGR_VAP_AIR_TIME_LIMIT,      /* When multi-channel enabled, restrict air-time allocated to a VAP */
+#if UMAC_SUPPORT_RPTPLACEMENT                 /* Repeater placement assist feature */ 
+    IEEE80211_RPT_CUSTPROTO_ENABLE,           /* Enable Custom Protocol bwn RootAP & RPT */
+    IEEE80211_RPT_GPUTCALC_ENABLE,            /* Enable goodput calculator */
+    IEEE80211_RPT_DEVUP,                      /* Indicate AP has sent out 1st beacon */ 
+    IEEE80211_RPT_MACDEV,                     /* Indicate device whose MAC Address follows */
+    IEEE80211_RPT_MACADDR1,                   /* Upper 4 bytes of device's MAC address */
+    IEEE80211_RPT_MACADDR2,                   /* Lower 2 bytes of device's MAC address */ 
+    IEEE80211_RPT_GPUTMODE,                   /* Indicates mode of operation of goodput calc */
+    IEEE80211_RPT_TXPROTOMSG,                 /* Protocol message number to be transmitted */
+    IEEE80211_RPT_RXPROTOMSG,                 /* Protocol message number received */
+    IEEE80211_RPT_STATUS,                     /* Repeater placement training status */
+    IEEE80211_RPT_ASSOC,                      /* Repeater placement association status */
+    IEEE80211_RPT_NUMSTAS,                    /* Number of STAs used in training */
+    IEEE80211_RPT_STA1ROUTE,                  /* Routing table for STA#1 */
+    IEEE80211_RPT_STA2ROUTE,                  /* Routing table for STA#2 */
+    IEEE80211_RPT_STA3ROUTE,                  /* Routing table for STA#3 */
+    IEEE80211_RPT_STA4ROUTE,                  /* Routing table for STA#4 */
+#endif //UMAC_SUPPORT_RPTPLACEMENT
+    IEEE80211_TDLS_MACADDR1,                  /* Upper 4 bytes of device's MAC address */
+    IEEE80211_TDLS_MACADDR2,                  /* Lower 2 bytes of device's MAC address */
+    IEEE80211_TDLS_ACTION,                    /* TDLS action requested                 */ 
+
+#ifdef  ATH_SUPPORT_AOW
+    IEEE80211_AOW_SWRETRIES,
+    IEEE80211_AOW_RTSRETRIES,
+    IEEE80211_AOW_LATENCY,
+    IEEE80211_AOW_PLAY_LOCAL,
+    IEEE80211_AOW_CLEAR_AUDIO_CHANNELS,
+    IEEE80211_AOW_STATS,
+    IEEE80211_AOW_INTERLEAVE,
+    IEEE80211_AOW_ER,
+    IEEE80211_AOW_EC,
+    IEEE80211_AOW_EC_RAMP,
+    IEEE80211_AOW_EC_FMAP,
+    IEEE80211_AOW_ES,
+    IEEE80211_AOW_ESS,
+    IEEE80211_AOW_ESS_COUNT,
+    IEEE80211_AOW_ESTATS,
+    IEEE80211_AOW_ENABLE_CAPTURE,
+    IEEE80211_AOW_FORCE_INPUT,
+    IEEE80211_AOW_PRINT_CAPTURE,
+    IEEE80211_AOW_LIST_AUDIO_CHANNELS,
+    IEEE80211_AOW_AS,
+    IEEE80211_AOW_PLAY_RX_CHANNEL,
+    IEEE80211_AOW_SIM_CTRL_CMD,
+    IEEE80211_AOW_FRAME_SIZE,
+    IEEE80211_AOW_ALT_SETTING,
+    IEEE80211_AOW_ASSOC_ONLY,
+    IEEE80211_AOW_DISCONNECT_DEVICE,
+#endif  /* ATH_SUPPORT_AOW */
+
+    IEEE80211_AUTO_ASSOC,
+    IEEE80211_PROTECTION_MODE,                /* per VAP protection mode*/
+    IEEE80211_AUTH_INACT_TIMEOUT,             /* inactivity time while waiting for 802.11x auth to complete */ 
+    IEEE80211_INIT_INACT_TIMEOUT,             /* inactivity time while waiting for 802.11 auth/assoc to complete */ 
+    IEEE80211_RUN_INACT_TIMEOUT,              /* inactivity time when fully authed*/ 
+    IEEE80211_PROBE_INACT_TIMEOUT,            /* inactivity counter value below which starts probing */
+    IEEE80211_QBSS_LOAD,
+    IEEE80211_WNM_CAP,
+    IEEE80211_WNM_BSS_CAP,
+    IEEE80211_WNM_TFS_CAP,
+    IEEE80211_WNM_TIM_CAP,
+    IEEE80211_WNM_SLEEP_CAP,
+    IEEE80211_WNM_FMS_CAP,
+    IEEE80211_AP_REJECT_DFS_CHAN,             /* AP to reject resuming on DFS Channel */
+	IEEE80211_ABOLT,
+	IEEE80211_COMP,
+	IEEE80211_FF,
+	IEEE80211_TURBO,
+	IEEE80211_BURST,
+	IEEE80211_AR,
+	IEEE80211_SLEEP,
+	IEEE80211_EOSPDROP,
+	IEEE80211_MARKDFS,
+	IEEE80211_DFSDOMAIN,
+	IEEE80211_WDS_AUTODETECT,
+	IEEE80211_WEP_TKIP_HT,
+	IEEE80211_ATH_RADIO,
+	IEEE80211_IGNORE_11DBEACON,
+    /* Video debug feature */
+    IEEE80211_VI_DBG_CFG,                     /* Video debug configuration - Bit0- enable dbg, Bit1 - enable stats log */
+    IEEE80211_VI_DBG_NUM_STREAMS,             /* Total number of receive streams */
+    IEEE80211_VI_STREAM_NUM,                  /* the stream number whose marker parameters are being set */
+    IEEE80211_VI_DBG_NUM_MARKERS,             /* total number of markers used to filter pkts */
+    IEEE80211_VI_MARKER_NUM,                  /* the marker number whose parameters (offset, size & match) are being set */
+    IEEE80211_VI_MARKER_OFFSET_SIZE,          /* byte offset from skb start (upper 16 bits) & size in bytes(lower 16 bits) */
+    IEEE80211_VI_MARKER_MATCH,                /* marker pattern match used in filtering */
+    IEEE80211_VI_RXSEQ_OFFSET_SIZE,           /* Rx Seq num offset skb start (upper 16 bits) & size in bytes(lower 16 bits) */
+    IEEE80211_VI_RX_SEQ_RSHIFT,               /* right-shift value in case field is not word aligned */
+    IEEE80211_VI_RX_SEQ_MAX,                  /* maximum Rx Seq number (to check wrap around) */
+    IEEE80211_VI_RX_SEQ_DROP,                 /* Indicator to the debug app that a particular seq num has been dropped */
+    IEEE80211_VI_TIME_OFFSET_SIZE,            /* Timestamp offset skb start (upper 16 bits) & size in bytes(lower 16 bits) */
+    IEEE80211_VI_RESTART,                     /* If set to 1 resets all internal variables/counters & restarts debug tool*/
+    IEEE80211_VI_RXDROP_STATUS,               /* Total RX drops in wireless */
+    IEEE80211_TRIGGER_MLME_RESP,              /* Option for App to trigger mlme response */
+#if UMAC_SUPPORT_SMARTANTENNA
+    IEEE80211_SMARTANT_TRAIN_MODE,            /* Implicit or Explicit training of antennas*/
+    IEEE80211_SMARTANT_TRAIN_TYPE,            /* Frame based or Protocol based */
+    IEEE80211_SMARTANT_PKT_LEN,               /* packet length used for training*/
+    IEEE80211_SMARTANT_NUM_PKTS,              /* number of packets used for training */
+    IEEE80211_SMARTANT_TRAIN_START,
+    IEEE80211_SMARTANT_NUM_ITR,               /* number of iterations needed to train on each antennas for all methods */
+    IEEE80211_SMARTANT_RETRAIN_THRESHOLD,     /* number of packets required for retrain check */
+    IEEE80211_SMARTANT_RETRAIN_INTERVAL,      /* periodic retrain interval */
+    IEEE80211_SMARTANT_RETRAIN_DROP,          /* % change in goodput to tigger performance training*/
+    IEEE80211_SMARTANT_MIN_GOODPUT_THRESHOLD, /* Minimum Good put threshold to tigger performance training */
+    IEEE80211_SMARTANT_GOODPUT_AVG_INTERVAL,  /* Number of intervals Good put need to be averaged to use in performance training tigger */
+    IEEE80211_SMARTANT_CURRENT_ANTENNA,       /* set current TX antenna for all node*/
+    IEEE80211_SMARTANT_DEFAULT_ANTENNA,       /* set default RX antenna */
+    IEEE80211_SMARTANT_TRAFFIC_GEN_TIMER,            /* Automation Mode */
+    IEEE80211_SMARTANT_RETRAIN,               /* Retraining enable/disable */
+#endif
+#ifdef ATH_SUPPORT_TxBF
+    IEEE80211_TXBF_AUTO_CVUPDATE,             /* auto CV update enable */
+    IEEE80211_TXBF_CVUPDATE_PER,              /* per threshold to initial CV update*/
+#endif  
+    IEEE80211_MAX_CLIENT_NUMBERS,
+	IEEE80211_SMARTNET,
+    IEEE80211_FEATURE_MFP_TEST,               /* MFP test */
+	IEEE80211_WEATHER_RADAR, 				  /* weather radar channel skip */
+#if UMAC_SUPPORT_CHANUTIL_MEASUREMENT
+    IEEE80211_CHAN_UTIL_ENAB,
+    IEEE80211_CHAN_UTIL,                      /* Get Channel Utilization value (scale: 0 - 255) */
+#endif /* UMAC_SUPPORT_CHANUTIL_MEASUREMENT */
+    IEEE80211_WEP_KEYCACHE,                   /* WEP KEYCACHE is enable */
+#if ATH_SUPPORT_WPA_SUPPLICANT_CHECK_TIME
+    IEEE80211_REJOINT_ATTEMP_TIME,
+#endif
+    IEEE80211_SEND_DEAUTH,                  /* send deauth instead of disassoc while doing interface down  */
+#if UMAC_SUPPORT_PROXY_ARP
+    IEEE80211_PROXYARP_CAP,
+#if UMAC_SUPPORT_DGAF_DISABLE
+    IEEE80211_DGAF_DISABLE,
+#endif
+#endif
+    IEEE80211_SET_TXPWRADJUST,
+    IEEE80211_RRM_CAP,
+    IEEE80211_RRM_DEBUG,
+    IEEE80211_RRM_STATS,
+    IEEE80211_RRM_SLWINDOW,
+#if ATH_SUPPORT_HYFI_ENHANCEMENTS
+    IEEE80211_NOPBN,                       /* no push button notification */
+#endif
+#if ATH_SUPPORT_DSCP_OVERRIDE
+	IEEE80211_DSCP_OVERRIDE,
+#endif 
+    IEEE80211_FEATURE_OFF_CHANNEL_SUPPORT,
+    IEEE80211_FIXED_VHT_MCS,                  /* VHT mcs index */
+    IEEE80211_FIXED_NSS,                      /* Spatial Streams count */
+    IEEE80211_SUPPORT_LDPC,                   /* LDPC Support */
+    IEEE80211_SUPPORT_TX_STBC,                /* TX STBC enable/disable */
+    IEEE80211_SUPPORT_RX_STBC,                /* RX STBC enable/disable */
+    IEEE80211_DEFAULT_KEYID,                  /* XMIT default key */
+    IEEE80211_OPMODE_NOTIFY_ENABLE,           /* Op mode notification enable/disable */
+    IEEE80211_ENABLE_RTSCTS,                  /* Enable/Disable RTS-CTS */
+    IEEE80211_RC_NUM_RETRIES,
+    IEEE80211_BCAST_RATE,                     /* Bcast Rate*/
+    IEEE80211_VHT_TX_MCSMAP,                  /* VHT TX MCS Map */
+    IEEE80211_VHT_RX_MCSMAP,                  /* VHT RX MCS Map */
+#if WDS_VENDOR_EXTENSION
+    IEEE80211_WDS_RX_POLICY,                  /* Rx filtering policy based on frame formats for vendor-specific WDS */
+#endif
+    IEEE80211_ENABLE_OL_STATS,                /* ENABLE/DISABLE Stats */
+    IEEE80211_GET_ACS_STATE,                  /* get acs state */
+    IEEE80211_GET_CAC_STATE,                  /* get cac state */
+    IEEE80211_EXT_IFACEUP_ACS,                /* Enable external auto channel selection
+                                                 entity at VAP init time */
+    IEEE80211_DESIRED_CHANNEL,                /* Get desired channel
+                                                 corresponding to desired PHY
+                                                 mode */
+    IEEE80211_DESIRED_PHYMODE,                /* Get desired PHY mode */
+    IEEE80211_SEND_ADDITIONAL_IES,            /* Enable/Disable Sending of Extra IEs to host */
+    IEEE80211_START_ACS_REPORT,               /* acs scan report */
+    IEEE80211_MIN_DWELL_ACS_REPORT,           /* min dwell for scan in acs scan report */
+    IEEE80211_MAX_DWELL_ACS_REPORT,           /* max dwell for scan in acs scan report */
+    IEEE80211_SET_CABQ_MAXDUR,                /* max tx percentage for cabq */
+    IEEE80211_256QAM,                         /* Enable/disabel 256QAM rate support in 2G mode*/
+    IEEE80211_11NG_VHT_INTEROP,                /* Enable/disabel 11NG VHT Interop */
+    IEEE80211_ACS_ENABLE_CH_HOP,              /* Enabling/disabling channel hopping in acs*/ 
+    IEEE80211_ACS_CH_HOP_LONG_DUR,            /* long duration timer in sec  used in ch hopping */
+    IEEE80211_ACS_CH_HOP_NO_HOP_DUR,          /* NO Hop timer in sec  used in ch hopping */
+    IEEE80211_ACS_CH_HOP_CNT_WIN_DUR,         /* cnt window timer in sec  used in ch hopping */ 
+    IEEE80211_ACS_CH_HOP_NOISE_TH,            /* Noise threshold to be used in detection algo */
+    IEEE80211_ACS_CH_HOP_CNT_TH,              /* cnt threshold used in ch hop algo */
+    IEEE80211_MAX_SCANENTRY,
+    IEEE80211_SCANENTRY_TIMEOUT,
+    IEEE80211_FEATURE_PURE11AC,               /* enable pure 11ac  mode */
+    IEEE80211_SCAN_MIN_DWELL,                 /*Scan MIN Dwell time set by user */
+    IEEE80211_SCAN_MAX_DWELL,                 /*Scan MAX Dwell time set by user */
+    IEEE80211_SCAN_REPEAT_PROBE_TIME,
+    IEEE80211_SCAN_REST_TIME,
+    IEEE80211_SCAN_IDLE_TIME,
+    IEEE80211_SCAN_PROBE_DELAY,
+    IEEE80211_MU_DELAY,
+	IEEE80211_VHT_SGIMASK,                    /* Set VHT SGI MASK */
+	IEEE80211_VHT80_RATEMASK,                 /* Set VHT80 Auto Rate MASK */
+#if ATH_PERF_PWR_OFFLOAD
+    IEEE80211_VAP_TX_ENCAP_TYPE,              /* Used to set the Tx encapsulation
+                                                 mode of the VAP - RAW/NWIFI/Ethernet */
+#if QCA_SUPPORT_RAWMODE_PKT_SIMULATION
+    IEEE80211_RAWMODE_PKT_SIM_STATS,          /* Get Raw mode packet simulation
+                                                 stats. */
+    IEEE80211_CLR_RAWMODE_PKT_SIM_STATS,      /* Clear Raw mode packet simulation
+                                                 stats. */
+    IEEE80211_RAWMODE_SIM_DEBUG,              /* Enable/disable raw mode simulation debug */
+#endif /* QCA_SUPPORT_RAWMODE_PKT_SIMULATION */
+#endif /* ATH_PERF_PWR_OFFLOAD*/
+#if QCA_AIRTIME_FAIRNESS
+    IEEE80211_ATF_OPT,                        /* Enable/Disable AirTime feature */
+    IEEE80211_ATF_PER_UNIT,                   /* Set percentage unit either 100 or 1000 */    
+#endif
+    IEEE80211_WIFI_TX_POWER,
+} ieee80211_param;
+
+#define  IEEE80211_PROTECTION_NONE         0
+#define  IEEE80211_PROTECTION_CTSTOSELF    1
+#define  IEEE80211_PROTECTION_RTS_CTS      2
+
+typedef enum _ieee80211_privacy_filter {
+    IEEE80211_PRIVACY_FILTER_ALLWAYS,
+    IEEE80211_PRIVACY_FILTER_KEY_UNAVAILABLE,
+} ieee80211_privacy_filter ;
+
+typedef enum _ieee80211_privacy_filter_packet_type {
+    IEEE80211_PRIVACY_FILTER_PACKET_UNICAST,
+    IEEE80211_PRIVACY_FILTER_PACKET_MULTICAST,
+    IEEE80211_PRIVACY_FILTER_PACKET_BOTH
+} ieee80211_privacy_filter_packet_type ;
+
+typedef struct _ieee80211_privacy_excemption_filter {
+    u_int16_t                               ether_type; /* type of ethernet to apply this filter, in host byte order*/
+    ieee80211_privacy_filter                filter_type; 
+    ieee80211_privacy_filter_packet_type    packet_type;
+} ieee80211_privacy_exemption;
+
+/*
+ * Authentication mode.
+ * NB: the usage of auth modes NONE, AUTO are deprecated,
+ * they are implemented through combinations of other auth modes
+ * and cipher types. The deprecated values are preserved here to
+ * maintain binary compatibility with applications like
+ * wpa_supplicant and hostapd.
+ */
+typedef enum _ieee80211_auth_mode {
+    IEEE80211_AUTH_NONE     = 0, /* deprecated */
+    IEEE80211_AUTH_OPEN     = 1, /* open */
+    IEEE80211_AUTH_SHARED   = 2, /* shared-key */
+    IEEE80211_AUTH_8021X    = 3, /* 802.1x */
+    IEEE80211_AUTH_AUTO     = 4, /* deprecated */
+    IEEE80211_AUTH_WPA      = 5, /* WPA */
+    IEEE80211_AUTH_RSNA     = 6, /* WPA2/RSNA */
+    IEEE80211_AUTH_CCKM     = 7, /* CCK */
+    IEEE80211_AUTH_WAPI     = 8, /* WAPI */
+} ieee80211_auth_mode;
+
+#define IEEE80211_AUTH_MAX      (IEEE80211_AUTH_WAPI+1)
+
+/*
+ * Cipher types.
+ * NB: The values are preserved here to maintain binary compatibility
+ * with applications like wpa_supplicant and hostapd.
+ */
+typedef enum _ieee80211_cipher_type {
+    IEEE80211_CIPHER_WEP        = 0,
+    IEEE80211_CIPHER_TKIP       = 1,
+    IEEE80211_CIPHER_AES_OCB    = 2,
+    IEEE80211_CIPHER_AES_CCM    = 3,
+    IEEE80211_CIPHER_WAPI       = 4,
+    IEEE80211_CIPHER_CKIP       = 5,
+    IEEE80211_CIPHER_AES_CMAC   = 6,
+    IEEE80211_CIPHER_NONE       = 7,
+} ieee80211_cipher_type;
+
+#define IEEE80211_CIPHER_MAX    (IEEE80211_CIPHER_NONE+1)
+
+/* key direction */
+typedef enum _ieee80211_key_direction {
+    IEEE80211_KEY_DIR_TX,
+    IEEE80211_KEY_DIR_RX,
+    IEEE80211_KEY_DIR_BOTH
+} ieee80211_key_direction;
+
+#define IEEE80211_KEYIX_NONE    ((u_int16_t) -1)
+
+typedef struct _ieee80211_keyval {
+    ieee80211_cipher_type   keytype;
+    ieee80211_key_direction keydir;
+    u_int                   persistent:1,   /* persistent key */
+                            mfp:1;          /* management frame protection */
+    u_int16_t               keylen;         /* length of the key data fields */
+    u_int8_t                *macaddr;       /* mac address of length IEEE80211_ADDR_LEN . all bytes are 0xff for multicast key */
+    u_int64_t               keyrsc;
+    u_int64_t               keytsc;
+    u_int16_t               txmic_offset;   /* TKIP/SMS4 only: offset to tx mic key */
+    u_int16_t               rxmic_offset;   /* TKIP/SMS4 only: offset to rx mic key */
+    u_int8_t                *keydata;
+#if ATH_SUPPORT_WAPI
+    u_int8_t                key_used;       /*index for WAPI rekey labeling*/
+#endif    
+} ieee80211_keyval;
+
+#define IEEE80211_AES_CMAC_LEN     128
+typedef enum _ieee80211_rsn_param {
+    IEEE80211_UCAST_CIPHER_LEN,
+    IEEE80211_MCAST_CIPHER_LEN,
+    IEEE80211_MCASTMGMT_CIPHER_LEN,    
+    IEEE80211_KEYMGT_ALGS,
+    IEEE80211_RSN_CAPS
+} ieee80211_rsn_param;
+
+#define IEEE80211_PMKID_LEN     16
+
+typedef struct _ieee80211_pmkid_entry {
+    u_int8_t    bssid[IEEE80211_ADDR_LEN];
+    u_int8_t    pmkid[IEEE80211_PMKID_LEN];
+} ieee80211_pmkid_entry;
+
+typedef enum _wlan_wme_param {
+    WLAN_WME_CWMIN,
+    WLAN_WME_CWMAX,
+    WLAN_WME_AIFS,
+    WLAN_WME_TXOPLIMIT,
+    WLAN_WME_ACM,      /*bss only*/
+    WLAN_WME_ACKPOLICY /*bss only*/
+} wlan_wme_param;
+
+typedef enum _ieee80211_frame_type {
+    IEEE80211_FRAME_TYPE_PROBEREQ,
+    IEEE80211_FRAME_TYPE_BEACON,
+    IEEE80211_FRAME_TYPE_PROBERESP,
+    IEEE80211_FRAME_TYPE_ASSOCREQ,
+    IEEE80211_FRAME_TYPE_ASSOCRESP,
+    IEEE80211_FRAME_TYPE_AUTH
+} ieee80211_frame_type; 
+
+#define IEEE80211_FRAME_TYPE_MAX    (IEEE80211_FRAME_TYPE_AUTH+1)
+
+typedef enum _ieee80211_ampdu_mode {
+    IEEE80211_AMPDU_MODE_OFF,   /* disable AMPDU */
+    IEEE80211_AMPDU_MODE_ON,    /* enable AMPDU */
+    IEEE80211_AMPDU_MODE_WDSVAR /* enable AMPDU with 4addr WAR */
+} ieee80211_ampdu_mode;
+
+typedef enum _ieee80211_reset_type {
+    IEEE80211_RESET_TYPE_DEVICE = 0,    /* device reset on error: tx timeout and etc. */
+    IEEE80211_RESET_TYPE_DOT11_INTF,    /* dot11 reset: only reset one network interface (vap) */
+    IEEE80211_RESET_TYPE_INTERNAL,      /* internal reset */
+} ieee80211_reset_type;
+
+typedef struct _ieee80211_reset_request {
+    ieee80211_reset_type    type;
+
+    u_int                   reset_hw:1,         /* reset the actual H/W */
+                            /*
+                             * The following fields are only valid for DOT11 reset, i.e.,
+                             * IEEE80211_RESET_TYPE_DOT11_INTF
+                             */
+                            reset_phy:1,        /* reset PHY */
+                            reset_mac:1,        /* reset MAC */
+                            set_default_mib:1,  /* set default MIB variables */
+                            no_flush:1;
+    u_int8_t                macaddr[IEEE80211_ADDR_LEN];
+    enum ieee80211_phymode  phy_mode;
+} ieee80211_reset_request;
+
+#define IEEE80211_MSG_MAX 63
+#define IEEE80211_MSG_SMARTANT 7            /* Bit 7 (0x80)for Smart Antenna debug */ 
+enum {
+    /* IEEE80211_PARAM_DBG_LVL */
+    IEEE80211_MSG_TDLS      = 0,            /* TDLS */
+    IEEE80211_MSG_ACS,                      /* auto channel selection */
+    IEEE80211_MSG_SCAN_SM,                  /* scan state machine */
+    IEEE80211_MSG_SCANENTRY,                /* scan entry */
+    IEEE80211_MSG_WDS,                      /* WDS handling */
+    IEEE80211_MSG_ACTION,                   /* action management frames */
+    IEEE80211_MSG_ROAM,                     /* sta-mode roaming */
+    IEEE80211_MSG_INACT,                    /* inactivity handling */
+    IEEE80211_MSG_DOTH      = 8,            /* 11.h */
+    IEEE80211_MSG_IQUE,                     /* IQUE features */
+    IEEE80211_MSG_WME,                      /* WME protocol */
+    IEEE80211_MSG_ACL,                      /* ACL handling */
+    IEEE80211_MSG_WPA,                      /* WPA/RSN protocol */
+    IEEE80211_MSG_RADKEYS,                  /* dump 802.1x keys */
+    IEEE80211_MSG_RADDUMP,                  /* dump 802.1x radius packets */
+    IEEE80211_MSG_RADIUS,                   /* 802.1x radius client */
+    IEEE80211_MSG_DOT1XSM   = 16,           /* 802.1x state machine */
+    IEEE80211_MSG_DOT1X,                    /* 802.1x authenticator */
+    IEEE80211_MSG_POWER,                    /* power save handling */
+    IEEE80211_MSG_STATE,                    /* state machine */
+    IEEE80211_MSG_OUTPUT,                   /* output handling */
+    IEEE80211_MSG_SCAN,                     /* scanning */
+    IEEE80211_MSG_AUTH,                     /* authentication handling */
+    IEEE80211_MSG_ASSOC,                    /* association handling */
+    IEEE80211_MSG_NODE      = 24,           /* node handling */
+    IEEE80211_MSG_ELEMID,                   /* element id parsing */
+    IEEE80211_MSG_XRATE,                    /* rate set handling */
+    IEEE80211_MSG_INPUT,                    /* input handling */
+    IEEE80211_MSG_CRYPTO,                   /* crypto work */
+    IEEE80211_MSG_DUMPPKTS,                 /* IFF_LINK2 equivalant */
+    IEEE80211_MSG_DEBUG,                    /* IFF_DEBUG equivalent */
+    IEEE80211_MSG_MLME,                     /* MLME */
+    /* IEEE80211_PARAM_DBG_LVL_HIGH */
+    IEEE80211_MSG_RRM       = 32,           /* Radio resource measurement */
+    IEEE80211_MSG_WNM,                      /* Wireless Network Management */
+    IEEE80211_MSG_P2P_PROT,                 /* P2P Protocol driver */
+    IEEE80211_MSG_PROXYARP,                 /* 11v Proxy ARP */
+    IEEE80211_MSG_L2TIF,                    /* Hotspot 2.0 L2 TIF */
+    IEEE80211_MSG_WIFIPOS,                  /* WifiPositioning Feature */
+    IEEE80211_MSG_WRAP,                     /* WRAP or Wireless ProxySTA */
+    IEEE80211_MSG_DFS,                      /* DFS debug mesg */
+    IEEE80211_MSG_ATF,                      /* ATF debug mesg */
+
+    IEEE80211_MSG_NUM_CATEGORIES,           /* total ieee80211 messages */
+    IEEE80211_MSG_UNMASKABLE = IEEE80211_MSG_MAX,  /* anything */
+    IEEE80211_MSG_ANY = IEEE80211_MSG_MAX,  /* anything */
+};
+
+/* verbosity levels */
+#define     IEEE80211_VERBOSE_OFF                  100 
+#define     IEEE80211_VERBOSE_FORCE               1
+#define     IEEE80211_VERBOSE_SERIOUS             2
+#define     IEEE80211_VERBOSE_NORMAL              3
+#define     IEEE80211_VERBOSE_LOUD                4
+#define     IEEE80211_VERBOSE_DETAILED            5
+#define     IEEE80211_VERBOSE_COMPLEX             6
+#define     IEEE80211_VERBOSE_FUNCTION            7 
+#define     IEEE80211_VERBOSE_TRACE               8
+
+#define IEEE80211_DEBUG_DEFAULT IEEE80211_MSG_DEBUG     
+
+/*
+ * the lower 4 bits of the msg flags are used for extending the
+ * debug flags. 
+ */ 
+
+/*
+ * flag defintions for wlan_mlme_stop_bss(vap) API.
+ */
+#define WLAN_MLME_STOP_BSS_F_SEND_DEAUTH                0x01
+#define WLAN_MLME_STOP_BSS_F_CLEAR_ASSOC_STATE          0x02
+#define WLAN_MLME_STOP_BSS_F_FORCE_STOP_RESET           0x04
+#define WLAN_MLME_STOP_BSS_F_WAIT_RX_DONE               0x08
+#define WLAN_MLME_STOP_BSS_F_NO_RESET                   0x10
+#define WLAN_MLME_STOP_BSS_F_STANDBY                    0x20
+
+/*
+ * WAPI commands to authenticator
+ */
+#define WAPI_WAI_REQUEST            (u_int16_t)0x00F1
+#define WAPI_UNICAST_REKEY          (u_int16_t)0x00F2
+#define WAPI_STA_AGING              (u_int16_t)0x00F3
+#define WAPI_MULTI_REKEY            (u_int16_t)0x00F4
+#define WAPI_STA_STATS              (u_int16_t)0x00F5
+
+/*
+ * IEEE80211 PHY Statistics.
+ */
+struct ieee80211_phy_stats {
+    u_int64_t   ips_tx_packets;      /* frames successfully transmitted */
+    u_int64_t   ips_tx_multicast;    /* multicast/broadcast frames successfully transmitted */
+    u_int64_t   ips_tx_fragments;    /* fragments successfully transmitted */
+    u_int64_t   ips_tx_xretries;     /* frames that are xretried. NB: not number of retries */
+    u_int64_t   ips_tx_retries;      /* frames transmitted after retries. NB: not number of retries */
+    u_int64_t   ips_tx_multiretries; /* frames transmitted after more than one retry. */
+    u_int64_t   ips_tx_timeout;      /* frames that expire the dot11MaxTransmitMSDULifetime */
+    u_int64_t   ips_rx_packets;      /* frames successfully received */
+    u_int64_t   ips_rx_multicast;    /* multicast/broadcast frames successfully received */
+    u_int64_t   ips_rx_fragments;    /* fragments successfully received */
+    u_int64_t   ips_rx_timeout;      /* frmaes that expired the dot11MaxReceiveLifetime */
+    u_int64_t   ips_rx_dup;          /* duplicated fragments */
+    u_int64_t   ips_rx_mdup;         /* multiple duplicated fragments */
+    u_int64_t   ips_rx_promiscuous;  /* frames that are received only because promiscuous filter is on */
+    u_int64_t   ips_rx_promiscuous_fragments; /* fragments that are received only because promiscuous filter is on */
+    u_int64_t   ips_tx_rts;          /* RTS success count */
+    u_int64_t   ips_tx_shortretry;   /* tx on-chip retries (short). RTSFailCnt */
+    u_int64_t   ips_tx_longretry;    /* tx on-chip retries (long). DataFailCnt */
+    u_int64_t   ips_rx_crcerr;       /* rx failed 'cuz of bad CRC */
+    u_int64_t   ips_rx_fifoerr;      /* rx failed 'cuz of FIFO overrun */
+    u_int64_t   ips_rx_decrypterr;   /* rx decryption error */
+};
+
+struct ieee80211_chan_stats {
+    u_int32_t   chan_clr_cnt;
+    u_int32_t   cycle_cnt;
+    u_int32_t   phy_err_cnt;
+};
+
+struct ieee80211_mac_stats {
+    u_int64_t   ims_tx_packets; /* frames successfully transmitted */
+    u_int64_t   ims_rx_packets; /* frames successfully received */
+    u_int64_t   ims_tx_bytes;	/* bytes successfully transmitted */
+    u_int64_t	ims_rx_bytes;   /* bytes successfully received */
+
+    /* TODO: For the byte counts below, we need to handle some scenarios
+       such as encryption related decaps, etc */
+    u_int64_t   ims_tx_data_packets;/* data frames successfully transmitted */
+    u_int64_t   ims_rx_data_packets;/* data frames successfully received */
+    u_int64_t   ims_tx_bcast_data_packets;/* bcast frames successfully transmitted */
+    u_int64_t   ims_rx_bcast_data_packets;/* bcast frames successfully received */
+    u_int64_t   ims_tx_data_bytes;  /* data bytes successfully transmitted,
+                                       inclusive of FCS. */
+    u_int64_t   ims_rx_data_bytes;  /* data bytes successfully received,
+                                       inclusive of FCS. */
+
+    u_int64_t   ims_tx_datapyld_bytes;  /* data payload bytes successfully
+                                           transmitted */
+    u_int64_t   ims_rx_datapyld_bytes;  /* data payload successfully 
+                                           received */
+
+    /* Decryption errors */
+    u_int64_t   ims_rx_unencrypted; /* rx w/o wep and privacy on */
+    u_int64_t   ims_rx_badkeyid;    /* rx w/ incorrect keyid */
+    u_int64_t   ims_rx_decryptok;   /* rx decrypt okay */
+    u_int64_t   ims_rx_decryptcrc;  /* rx decrypt failed on crc */
+    u_int64_t   ims_rx_wepfail;     /* rx wep processing failed */
+    u_int64_t   ims_rx_tkipreplay;  /* rx seq# violation (TKIP) */
+    u_int64_t   ims_rx_tkipformat;  /* rx format bad (TKIP) */
+    u_int64_t   ims_rx_tkipmic;     /* rx MIC check failed (TKIP) */
+    u_int64_t   ims_rx_tkipicv;     /* rx ICV check failed (TKIP) */
+    u_int64_t   ims_rx_ccmpreplay;  /* rx seq# violation (CCMP) */
+    u_int64_t   ims_rx_ccmpformat;  /* rx format bad (CCMP) */
+    u_int64_t   ims_rx_ccmpmic;     /* rx MIC check failed (CCMP) */
+    u_int64_t   ims_rx_fcserr;     /* rx MIC check failed (CCMP) */
+/*this file can be included by applications as 80211stats that has no such MACRO definition*/
+//#if ATH_SUPPORT_WAPI 
+    u_int64_t   ims_rx_wpireplay;  /* rx seq# violation (WPI) */
+    u_int64_t   ims_rx_wpimic;     /* rx MIC check failed (WPI) */
+//#endif
+    /* Other Tx/Rx errors */
+    u_int64_t   ims_tx_discard;     /* tx dropped by NIC */
+    u_int64_t   ims_rx_discard;     /* rx dropped by NIC */
+
+    u_int64_t   ims_rx_countermeasure; /* rx TKIP countermeasure activation count */
+    u_int64_t   ims_last_tx_rate;
+    u_int64_t   ims_last_tx_rate_mcs;
+};
+
+/*
+ * Summary statistics.
+ */
+struct ieee80211_stats {
+    u_int32_t   is_rx_badversion;          /* rx frame with bad version */
+    u_int32_t   is_rx_tooshort;            /* rx frame too short */
+    u_int32_t   is_rx_wrongbss;            /* rx from wrong bssid */
+    u_int32_t   is_rx_wrongdir;            /* rx w/ wrong direction */
+    u_int32_t   is_rx_mcastecho;           /* rx discard 'cuz mcast echo */
+    u_int32_t   is_rx_notassoc;            /* rx discard 'cuz sta !assoc */
+    u_int32_t   is_rx_noprivacy;           /* rx w/ wep but privacy off */
+    u_int32_t   is_rx_decap;               /* rx decapsulation failed */
+    u_int32_t   is_rx_mgtdiscard;          /* rx discard mgt frames */
+    u_int32_t   is_rx_ctl;                 /* rx discard ctrl frames */
+    u_int32_t   is_rx_beacon;              /* rx beacon frames */
+    u_int32_t   is_rx_rstoobig;            /* rx rate set truncated */
+    u_int32_t   is_rx_elem_missing;        /* rx required element missing*/
+    u_int32_t   is_rx_elem_toobig;         /* rx element too big */
+    u_int32_t   is_rx_elem_toosmall;       /* rx element too small */
+    u_int32_t   is_rx_elem_unknown;        /* rx element unknown */
+    u_int32_t   is_rx_badchan;             /* rx frame w/ invalid chan */
+    u_int32_t   is_rx_chanmismatch;        /* rx frame chan mismatch */
+    u_int32_t   is_rx_nodealloc;           /* rx frame dropped */
+    u_int32_t   is_rx_ssidmismatch;        /* rx frame ssid mismatch  */
+    u_int32_t   is_rx_auth_unsupported;    /* rx w/ unsupported auth alg */
+    u_int32_t   is_rx_auth_fail;           /* rx sta auth failure */
+    u_int32_t   is_rx_auth_countermeasures;/* rx auth discard 'cuz CM */
+    u_int32_t   is_rx_assoc_bss;           /* rx assoc from wrong bssid */
+    u_int32_t   is_rx_assoc_notauth;       /* rx assoc w/o auth */
+    u_int32_t   is_rx_assoc_capmismatch;   /* rx assoc w/ cap mismatch */
+    u_int32_t   is_rx_assoc_norate;        /* rx assoc w/ no rate match */
+    u_int32_t   is_rx_assoc_badwpaie;      /* rx assoc w/ bad WPA IE */
+    u_int32_t   is_rx_deauth;              /* rx deauthentication */
+    u_int32_t   is_rx_disassoc;            /* rx disassociation */
+    u_int32_t   is_rx_action;              /* rx action mgt */
+    u_int32_t   is_rx_badsubtype;          /* rx frame w/ unknown subtype*/
+    u_int32_t   is_rx_nobuf;               /* rx failed for lack of buf */
+    u_int32_t   is_rx_ahdemo_mgt;          /* rx discard ahdemo mgt frame*/
+    u_int32_t   is_rx_bad_auth;            /* rx bad auth request */
+    u_int32_t   is_rx_unauth;              /* rx on unauthorized port */
+    u_int32_t   is_rx_badcipher;           /* rx failed 'cuz key type */
+    u_int32_t   is_tx_nodefkey;            /* tx failed 'cuz no defkey */
+    u_int32_t   is_tx_noheadroom;          /* tx failed 'cuz no space */
+    u_int32_t   is_rx_nocipherctx;         /* rx failed 'cuz key !setup */
+    u_int32_t   is_rx_acl;                 /* rx discard 'cuz acl policy */
+    u_int32_t   is_rx_ffcnt;               /* rx fast frames */
+    u_int32_t   is_rx_badathtnl;           /* driver key alloc failed */
+    u_int32_t   is_rx_nowds;               /* 4-addr packets received with no wds enabled */
+    u_int32_t   is_tx_nobuf;               /* tx failed for lack of buf */
+    u_int32_t   is_tx_nonode;              /* tx failed for no node */
+    u_int32_t   is_tx_unknownmgt;          /* tx of unknown mgt frame */
+    u_int32_t   is_tx_badcipher;           /* tx failed 'cuz key type */
+    u_int32_t   is_tx_ffokcnt;             /* tx fast frames sent success */
+    u_int32_t   is_tx_fferrcnt;            /* tx fast frames sent success */
+    u_int32_t   is_tx_not_ok;            /* tx ok not set in desc */
+    u_int32_t   is_scan_active;            /* active scans started */
+    u_int32_t   is_scan_passive;           /* passive scans started */
+    u_int32_t   is_node_timeout;           /* nodes timed out inactivity */
+    u_int32_t   is_crypto_nomem;           /* no memory for crypto ctx */
+    u_int32_t   is_crypto_tkip;            /* tkip crypto done in s/w */
+    u_int32_t   is_crypto_tkipenmic;       /* tkip en-MIC done in s/w */
+    u_int32_t   is_crypto_tkipdemic;       /* tkip de-MIC done in s/w */
+    u_int32_t   is_crypto_tkipcm;          /* tkip counter measures */
+    u_int32_t   is_crypto_ccmp;            /* ccmp crypto done in s/w */
+    u_int32_t   is_crypto_wep;             /* wep crypto done in s/w */
+    u_int32_t   is_crypto_setkey_cipher;   /* cipher rejected key */
+    u_int32_t   is_crypto_setkey_nokey;    /* no key index for setkey */
+    u_int32_t   is_crypto_delkey;          /* driver key delete failed */
+    u_int32_t   is_crypto_badcipher;       /* unknown cipher */
+    u_int32_t   is_crypto_nocipher;        /* cipher not available */
+    u_int32_t   is_crypto_attachfail;      /* cipher attach failed */
+    u_int32_t   is_crypto_swfallback;      /* cipher fallback to s/w */
+    u_int32_t   is_crypto_keyfail;         /* driver key alloc failed */
+    u_int32_t   is_crypto_enmicfail;       /* en-MIC failed */
+    u_int32_t   is_ibss_capmismatch;       /* merge failed-cap mismatch */
+    u_int32_t   is_ibss_norate;            /* merge failed-rate mismatch */
+    u_int32_t   is_ps_unassoc;             /* ps-poll for unassoc. sta */
+    u_int32_t   is_ps_badaid;              /* ps-poll w/ incorrect aid */
+    u_int32_t   is_ps_qempty;              /* ps-poll w/ nothing to send */
+};
+
+typedef enum _ieee80211_send_frame_type {
+    IEEE80211_SEND_NULL,
+    IEEE80211_SEND_QOSNULL,
+} ieee80211_send_frame_type;
+
+typedef struct _ieee80211_tspec_info {
+    u_int8_t    traffic_type;
+    u_int8_t    direction;
+    u_int8_t    dot1Dtag;
+    u_int8_t    tid;
+    u_int8_t    acc_policy_edca;
+    u_int8_t    acc_policy_hcca;
+    u_int8_t    aggregation;
+    u_int8_t    psb;
+    u_int8_t    ack_policy;
+    u_int16_t   norminal_msdu_size;
+    u_int16_t   max_msdu_size;
+    u_int32_t   min_srv_interval;
+    u_int32_t   max_srv_interval;
+    u_int32_t   inactivity_interval;
+    u_int32_t   suspension_interval;
+    u_int32_t   srv_start_time;
+    u_int32_t   min_data_rate;
+    u_int32_t   mean_data_rate;
+    u_int32_t   peak_data_rate;
+    u_int32_t   max_burst_size;
+    u_int32_t   delay_bound;
+    u_int32_t   min_phy_rate;
+    u_int16_t   surplus_bw;
+    u_int16_t   medium_time;
+} ieee80211_tspec_info;
+
+#ifndef EXTERNAL_USE_ONLY
+/*
+ * Manual ADDBA support
+ */
+enum {
+    ADDBA_SEND     = 0,
+    ADDBA_STATUS   = 1,
+    DELBA_SEND     = 2,
+    ADDBA_RESP     = 3,
+    ADDBA_CLR_RESP = 4,
+    SINGLE_AMSDU   = 5,
+};
+
+enum {
+    ADDBA_MODE_AUTO   = 0,
+    ADDBA_MODE_MANUAL = 1,
+};
+
+struct ieee80211_addba_delba_request {
+    wlan_dev_t             ic;
+    u_int8_t               action;
+    u_int8_t               tid;
+    u_int16_t              status;
+    u_int16_t              aid;
+    u_int32_t              arg1;
+    u_int32_t              arg2;
+};
+#endif /* EXTERNAL_USE_ONLY */
+
+#ifdef ATH_BT_COEX
+typedef enum _ieee80211_bt_coex_info_type {
+    IEEE80211_BT_COEX_INFO_SCHEME        = 0,
+    IEEE80211_BT_COEX_INFO_BTBUSY        = 1,
+} ieee80211_bt_coex_info_type;
+#endif
+
+struct tkip_countermeasure {
+    u_int16_t   mic_count_in_60s;
+    u_int32_t   timestamp;
+} ;
+
+enum _ieee80211_qos_frame_direction {
+    IEEE80211_RX_QOS_FRAME = 0,
+    IEEE80211_TX_QOS_FRAME = 1,
+    IEEE80211_TX_COMPLETE_QOS_FRAME = 2
+};
+
+typedef struct ieee80211_vap_opmode_count {
+    int    total_vaps;
+    int    ibss_count;
+    int    sta_count;
+    int    wds_count;
+    int    ahdemo_count;
+    int    ap_count;
+    int    monitor_count;
+    int    btamp_count;
+    int    unknown_count;
+} ieee80211_vap_opmode_count;
+
+struct ieee80211_app_ie_t {
+        u_int32_t       length;
+        u_int8_t        *ie;
+};
+
+/* ACS debug structure to
+ * export report to user tool
+ */
+struct ieee80211_acs_dbg {
+    u_int8_t  nchans;
+    u_int8_t  entry_id;
+    u_int16_t chan_freq;
+    u_int8_t  ieee_chan;
+    u_int8_t  chan_nbss;
+    int32_t   chan_maxrssi;    
+    int32_t   chan_minrssi;    
+    int16_t   noisefloor;      
+    int16_t   channel_loading; 
+    u_int32_t chan_load;
+    u_int8_t  sec_chan;
+};
+
+/* 
+ * MAC ACL operations.
+ */
+enum {
+    IEEE80211_MACCMD_POLICY_OPEN    = 0,  /* set policy: no ACL's */
+    IEEE80211_MACCMD_POLICY_ALLOW   = 1,  /* set policy: allow traffic */
+    IEEE80211_MACCMD_POLICY_DENY    = 2,  /* set policy: deny traffic */
+    IEEE80211_MACCMD_FLUSH          = 3,  /* flush ACL database */
+    IEEE80211_MACCMD_DETACH         = 4,  /* detach ACL policy */
+    IEEE80211_MACCMD_POLICY_RADIUS  = 5,  /* set policy: RADIUS managed ACLs */
+};
+
+#define IEEE80211_CHAN_MAXHIST    32
+
+#endif
diff -Naur hostapd-2.9/src/drivers/ieee80211_ev.h hostapd-2.9-new/src/drivers/ieee80211_ev.h
--- hostapd-2.9/src/drivers/ieee80211_ev.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ieee80211_ev.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,6 @@
+
+struct ev_msg {
+    u_int8_t addr[6];
+    u_int32_t status;
+    u_int32_t reason;
+};
diff -Naur hostapd-2.9/src/drivers/ieee80211_external.h hostapd-2.9-new/src/drivers/ieee80211_external.h
--- hostapd-2.9/src/drivers/ieee80211_external.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ieee80211_external.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,91 @@
+/*****************************************************************************/
+/* \file ieee80211_external.h
+** \brief External Header File References
+**
+**  This header file refers to the internal header files that provide the
+**  data structure definitions and parameters required by external programs
+**  that interface via ioctl or similiar mechanisms.  This hides the location
+**  of the specific header files, and provides a control to limit what is
+**  being exported for external use.
+**
+**  Copyright (c) 2009 Atheros Communications Inc.  All rights reserved.
+**
+** Permission to use, copy, modify, and/or distribute this software for any
+** purpose with or without fee is hereby granted, provided that the above
+** copyright notice and this permission notice appear in all copies.
+**
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+** WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+** MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+** ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+** WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+** ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+** OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+**/
+
+/* 
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ * All Rights Reserved. 
+ * Qualcomm Atheros Confidential and Proprietary. 
+ */ 
+
+#ifndef IEEE80211_EXTERNAL_H
+#define IEEE80211_EXTERNAL_H
+
+#ifndef __packed
+#define __packed    __attribute__((__packed__))
+#endif
+#define EXTERNAL_USE_ONLY
+#if 0
+#include "include/ieee80211.h"
+#include "include/ieee80211_defines.h"
+#include "os/linux/include/ieee80211_ioctl.h"
+#include "lmac/ath_devif_athioctl.h"
+#include "os/linux/include/ath_ald_external.h"
+#include "os/linux/include/ieee80211_ev.h"
+#else
+#include "ieee80211.h"
+#include "ieee80211_defines.h"
+#include "ieee80211_ioctl.h"
+#include "if_athioctl.h"
+#include "ath_ald_external.h"
+#include "ieee80211_ev.h"
+#endif
+
+/*
+** Key definitions moved to here to allow them to be published externally
+** without having to export all of the other stuff.  These need to be consistent
+** with the definitions in ieee80211_crypto.h
+*/
+
+#define	IEEE80211_KEY_XMIT	0x01	/* key used for xmit */
+#define	IEEE80211_KEY_RECV	0x02	/* key used for recv */
+#define	IEEE80211_KEY_GROUP	0x04	/* key used for WPA group operation */
+#define IEEE80211_KEY_MFP   0x08    /* key also used for management frames */
+#define	IEEE80211_KEY_SWENCRYPT	0x10	/* host-based encryption */
+#define	IEEE80211_KEY_SWENMIC	0x20	/* host-based enmic */
+#define IEEE80211_KEY_PERSISTENT 0x40   /* do not remove unless OS commands us to do so */
+#define IEEE80211_KEY_PERSTA    0x80    /* per STA default key */
+#define IEEE80211_KEY_SWDECRYPT 0x100   /* host-based decryption */
+#define IEEE80211_KEY_SWDEMIC   0x200   /* host-based demic */
+#define IEEE80211_KEY_SWCRYPT   (IEEE80211_KEY_SWENCRYPT | IEEE80211_KEY_SWDECRYPT)
+#define IEEE80211_KEY_SWMIC     (IEEE80211_KEY_SWENMIC | IEEE80211_KEY_SWDEMIC)
+
+/*
+** Wireless Mode related definitions replicated here to allow them to be published
+** externally without having to export all of the other stuff.  These need to be consistent
+** with the definitions in ath_dev.h
+*/
+
+#ifndef WIRELESS_MODE_MAX
+#define WIRELESS_MODE_MAX   (12)
+#endif
+
+#ifndef IEEE80211_IPV4_LEN
+#define IEEE80211_IPV4_LEN 4
+#endif
+
+#ifndef IEEE80211_IPV6_LEN
+#define IEEE80211_IPV6_LEN 16
+#endif
+#endif /* IEEE80211_EXTERNAL_H */
diff -Naur hostapd-2.9/src/drivers/_ieee80211.h hostapd-2.9-new/src/drivers/_ieee80211.h
--- hostapd-2.9/src/drivers/_ieee80211.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/_ieee80211.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,558 @@
+/*
+ *  Copyright (c) 2008 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NET80211__IEEE80211_H_
+#define _NET80211__IEEE80211_H_
+#include "ieee80211_rrm.h"
+#include "ieee80211_wnm_proto.h"
+#include "ieee80211_band_steering_api.h"
+#include "ieee80211_phytype.h"
+
+/* These defines should match the table from ah_internal.h */
+typedef enum {
+	DFS_UNINIT_DOMAIN	= 0,	/* Uninitialized dfs domain */
+	DFS_FCC_DOMAIN		= 1,	/* FCC3 dfs domain */
+	DFS_ETSI_DOMAIN		= 2,	/* ETSI dfs domain */
+	DFS_MKK4_DOMAIN		= 3	/* Japan dfs domain */
+}HAL_DFS_DOMAIN;
+
+/* XXX not really a mode; there are really multiple PHY's */
+enum ieee80211_phymode {
+    IEEE80211_MODE_AUTO             = 0,    /* autoselect */
+    IEEE80211_MODE_11A              = 1,    /* 5GHz, OFDM */
+    IEEE80211_MODE_11B              = 2,    /* 2GHz, CCK */
+    IEEE80211_MODE_11G              = 3,    /* 2GHz, OFDM */
+    IEEE80211_MODE_FH               = 4,    /* 2GHz, GFSK */
+    IEEE80211_MODE_TURBO_A          = 5,    /* 5GHz, OFDM, 2x clock dynamic turbo */
+    IEEE80211_MODE_TURBO_G          = 6,    /* 2GHz, OFDM, 2x clock dynamic turbo */
+    IEEE80211_MODE_11NA_HT20        = 7,    /* 5Ghz, HT20 */
+    IEEE80211_MODE_11NG_HT20        = 8,    /* 2Ghz, HT20 */
+    IEEE80211_MODE_11NA_HT40PLUS    = 9,    /* 5Ghz, HT40 (ext ch +1) */
+    IEEE80211_MODE_11NA_HT40MINUS   = 10,   /* 5Ghz, HT40 (ext ch -1) */
+    IEEE80211_MODE_11NG_HT40PLUS    = 11,   /* 2Ghz, HT40 (ext ch +1) */
+    IEEE80211_MODE_11NG_HT40MINUS   = 12,   /* 2Ghz, HT40 (ext ch -1) */
+    IEEE80211_MODE_11NG_HT40        = 13,   /* 2Ghz, Auto HT40 */
+    IEEE80211_MODE_11NA_HT40        = 14,   /* 2Ghz, Auto HT40 */
+    IEEE80211_MODE_11AC_VHT20       = 15,   /* 5Ghz, VHT20 */
+    IEEE80211_MODE_11AC_VHT40PLUS   = 16,   /* 5Ghz, VHT40 (Ext ch +1) */
+    IEEE80211_MODE_11AC_VHT40MINUS  = 17,   /* 5Ghz  VHT40 (Ext ch -1) */
+    IEEE80211_MODE_11AC_VHT40       = 18,   /* 5Ghz, VHT40 */
+    IEEE80211_MODE_11AC_VHT80       = 19,   /* 5Ghz, VHT80 */
+};
+#define IEEE80211_MODE_MAX      (IEEE80211_MODE_11AC_VHT80 + 1)
+
+enum ieee80211_opmode {
+    IEEE80211_M_STA         = 1,                 /* infrastructure station */
+    IEEE80211_M_IBSS        = 0,                 /* IBSS (adhoc) station */
+    IEEE80211_M_AHDEMO      = 3,                 /* Old lucent compatible adhoc demo */
+    IEEE80211_M_HOSTAP      = 6,                 /* Software Access Point */
+    IEEE80211_M_MONITOR     = 8,                 /* Monitor mode */
+    IEEE80211_M_WDS         = 2,                 /* WDS link */
+    IEEE80211_M_BTAMP       = 9,                 /* VAP for BT AMP */
+
+    IEEE80211_M_P2P_GO      = 33,                /* P2P GO */
+    IEEE80211_M_P2P_CLIENT  = 34,                /* P2P Client */
+    IEEE80211_M_P2P_DEVICE  = 35,                /* P2P Device */
+
+
+    IEEE80211_OPMODE_MAX    = IEEE80211_M_BTAMP, /* Highest numbered opmode in the list */
+
+    IEEE80211_M_ANY         = 0xFF               /* Any of the above; used by NDIS 6.x */
+};
+
+/*
+ * 802.11n
+ */
+#define IEEE80211_CWM_EXTCH_BUSY_THRESHOLD 30
+
+enum ieee80211_cwm_mode {
+    IEEE80211_CWM_MODE20,
+    IEEE80211_CWM_MODE2040,         
+    IEEE80211_CWM_MODE40,
+    IEEE80211_CWM_MODEMAX
+
+};
+
+enum ieee80211_cwm_extprotspacing {
+    IEEE80211_CWM_EXTPROTSPACING20,
+    IEEE80211_CWM_EXTPROTSPACING25,
+    IEEE80211_CWM_EXTPROTSPACINGMAX
+};
+
+enum ieee80211_cwm_width {
+    IEEE80211_CWM_WIDTH20,
+    IEEE80211_CWM_WIDTH40,
+    IEEE80211_CWM_WIDTH80,
+    IEEE80211_CWM_WIDTHINVALID = 0xff    /* user invalid value */
+};
+
+enum ieee80211_cwm_extprotmode {
+    IEEE80211_CWM_EXTPROTNONE,      /* no protection */
+    IEEE80211_CWM_EXTPROTCTSONLY,   /* CTS to self */
+    IEEE80211_CWM_EXTPROTRTSCTS,    /* RTS-CTS */
+    IEEE80211_CWM_EXTPROTMAX
+};
+
+enum ieee80211_fixed_rate_mode {
+    IEEE80211_FIXED_RATE_NONE  = 0,
+    IEEE80211_FIXED_RATE_MCS   = 1,  /* HT rates */
+    IEEE80211_FIXED_RATE_LEGACY  = 2,   /* legacy rates */
+    IEEE80211_FIXED_RATE_VHT  = 3   /* VHT rates */
+};
+
+/* Holds the fixed rate information for each VAP */
+struct ieee80211_fixed_rate {
+    enum ieee80211_fixed_rate_mode  mode;
+    u_int32_t                       series;
+    u_int32_t                       retries;
+};
+
+/*
+ * 802.11g protection mode.
+ */
+enum ieee80211_protmode {
+    IEEE80211_PROT_NONE     = 0,    /* no protection */
+    IEEE80211_PROT_CTSONLY  = 1,    /* CTS to self */
+    IEEE80211_PROT_RTSCTS   = 2,    /* RTS-CTS */
+};
+
+/*
+ * Roaming mode is effectively who controls the operation
+ * of the 802.11 state machine when operating as a station.
+ * State transitions are controlled either by the driver
+ * (typically when management frames are processed by the
+ * hardware/firmware), the host (auto/normal operation of
+ * the 802.11 layer), or explicitly through ioctl requests
+ * when applications like wpa_supplicant want control.
+ */
+enum ieee80211_roamingmode {
+    IEEE80211_ROAMING_DEVICE= 0,    /* driver/hardware control */
+    IEEE80211_ROAMING_AUTO  = 1,    /* 802.11 layer control */
+    IEEE80211_ROAMING_MANUAL= 2,    /* application control */
+};
+
+/*
+ * Scanning mode controls station scanning work; this is
+ * used only when roaming mode permits the host to select
+ * the bss to join/channel to use.
+ */
+enum ieee80211_scanmode {
+    IEEE80211_SCAN_DEVICE   = 0,    /* driver/hardware control */
+    IEEE80211_SCAN_BEST     = 1,    /* 802.11 layer selects best */
+    IEEE80211_SCAN_FIRST    = 2,    /* take first suitable candidate */
+};
+
+/*
+ * Channels are specified by frequency and attributes.
+ */
+struct ieee80211_channel {
+    u_int16_t       ic_freq;        /* setting in Mhz */
+    u_int32_t       ic_flags;       /* see below */
+    u_int8_t        ic_flagext;     /* see below */
+    u_int8_t        ic_ieee;        /* IEEE channel number */
+    int8_t          ic_maxregpower; /* maximum regulatory tx power in dBm */
+    int8_t          ic_maxpower;    /* maximum tx power in dBm */
+    int8_t          ic_minpower;    /* minimum tx power in dBm */
+    u_int8_t        ic_regClassId;  /* regClassId of this channel */ 
+    u_int8_t        ic_antennamax;  /* antenna gain max from regulatory */
+    u_int8_t        ic_vhtop_ch_freq_seg1;         /* Channel Center frequency */
+    u_int8_t        ic_vhtop_ch_freq_seg2;         /* Channel Center frequency applicable
+                                                  * for 80+80MHz mode of operation */ 
+};
+
+#define IEE80211_MAX_20M_SUB_CH 8 /* In case of VHT160, we can have 8 20Mhz channels */
+struct ieee80211_channel_list {
+    int                         cl_nchans;
+    struct ieee80211_channel    *cl_channels[IEE80211_MAX_20M_SUB_CH];
+};
+
+#define	IEEE80211_NWID_LEN	32
+#define IEEE80211_CHAN_MAX      1023
+#define IEEE80211_CHAN_BYTES    128      /* howmany(IEEE80211_CHAN_MAX, NBBY) */
+#define IEEE80211_CHAN_ANY      (-1)    /* token for ``any channel'' */
+#define IEEE80211_CHAN_ANYC \
+        ((struct ieee80211_channel *) IEEE80211_CHAN_ANY)
+
+#define IEEE80211_CHAN_DEFAULT          11
+#define IEEE80211_CHAN_DEFAULT_11A      52
+#define IEEE80211_CHAN_ADHOC_DEFAULT1   10
+#define IEEE80211_CHAN_ADHOC_DEFAULT2   11
+
+#define IEEE80211_RADAR_11HCOUNT        5
+#define IEEE80211_RADAR_TEST_MUTE_CHAN_11A      36      /* Move to channel 36 for mute test */
+#define IEEE80211_RADAR_TEST_MUTE_CHAN_11NHT20  36
+#define IEEE80211_RADAR_TEST_MUTE_CHAN_11NHT40U 36
+#define IEEE80211_RADAR_TEST_MUTE_CHAN_11NHT40D 40      /* Move to channel 40 for HT40D mute test */
+#define IEEE80211_RADAR_DETECT_DEFAULT_DELAY    60000   /* STA ignore AP beacons during this period in millisecond */
+
+#define IEEE80211_2GCSA_TBTTCOUNT        3
+
+/* bits 0-3 are for private use by drivers */
+/* channel attributes */
+#define IEEE80211_CHAN_TURBO            0x00000010 /* Turbo channel */
+#define IEEE80211_CHAN_CCK              0x00000020 /* CCK channel */
+#define IEEE80211_CHAN_OFDM             0x00000040 /* OFDM channel */
+#define IEEE80211_CHAN_2GHZ             0x00000080 /* 2 GHz spectrum channel. */
+#define IEEE80211_CHAN_5GHZ             0x00000100 /* 5 GHz spectrum channel */
+#define IEEE80211_CHAN_PASSIVE          0x00000200 /* Only passive scan allowed */
+#define IEEE80211_CHAN_DYN              0x00000400 /* Dynamic CCK-OFDM channel */
+#define IEEE80211_CHAN_GFSK             0x00000800 /* GFSK channel (FHSS PHY) */
+#define IEEE80211_CHAN_RADAR            0x00001000 /* Radar found on channel */
+#define IEEE80211_CHAN_STURBO           0x00002000 /* 11a static turbo channel only */
+#define IEEE80211_CHAN_HALF             0x00004000 /* Half rate channel */
+#define IEEE80211_CHAN_QUARTER          0x00008000 /* Quarter rate channel */
+#define IEEE80211_CHAN_HT20             0x00010000 /* HT 20 channel */
+#define IEEE80211_CHAN_HT40PLUS         0x00020000 /* HT 40 with extension channel above */
+#define IEEE80211_CHAN_HT40MINUS        0x00040000 /* HT 40 with extension channel below */
+#define IEEE80211_CHAN_HT40INTOL        0x00080000 /* HT 40 Intolerant */
+#define IEEE80211_CHAN_VHT20            0x00100000 /* VHT 20 channel */
+#define IEEE80211_CHAN_VHT40PLUS        0x00200000 /* VHT 40 with extension channel above */
+#define IEEE80211_CHAN_VHT40MINUS       0x00400000 /* VHT 40 with extension channel below */
+#define IEEE80211_CHAN_VHT80            0x00800000 /* VHT 80 channel */
+#define IEEE80211_CHAN_HT40INTOLMARK    0x01000000 /* HT 40 Intolerant mark bit for ACS use */
+#define IEEE80211_CHAN_BLOCKED          0x02000000 /* channel temporarily blocked due to noise */
+
+/* flagext */
+#define	IEEE80211_CHAN_RADAR_FOUND    0x01
+#define IEEE80211_CHAN_DFS              0x0002  /* DFS required on channel */
+#define IEEE80211_CHAN_DFS_CLEAR        0x0008  /* if channel has been checked for DFS */
+#define IEEE80211_CHAN_11D_EXCLUDED     0x0010  /* excluded in 11D */
+#define IEEE80211_CHAN_CSA_RECEIVED     0x0020  /* Channel Switch Announcement received on this channel */
+#define IEEE80211_CHAN_DISALLOW_ADHOC   0x0040  /* ad-hoc is not allowed */
+#define IEEE80211_CHAN_DISALLOW_HOSTAP  0x0080  /* Station only channel */
+
+/*
+ * Useful combinations of channel characteristics.
+ */
+#define IEEE80211_CHAN_FHSS \
+    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_GFSK)
+#define IEEE80211_CHAN_A \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)
+#define IEEE80211_CHAN_B \
+    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK)
+#define IEEE80211_CHAN_PUREG \
+    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)
+#define IEEE80211_CHAN_G \
+    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN)
+#define IEEE80211_CHAN_108A \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)
+#define IEEE80211_CHAN_108G \
+    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)
+#define IEEE80211_CHAN_ST \
+    (IEEE80211_CHAN_108A | IEEE80211_CHAN_STURBO)
+
+#define IEEE80211_CHAN_11NG_HT20 \
+    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_HT20)
+#define IEEE80211_CHAN_11NA_HT20 \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_HT20)
+#define IEEE80211_CHAN_11NG_HT40PLUS \
+    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_HT40PLUS)
+#define IEEE80211_CHAN_11NG_HT40MINUS \
+    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_HT40MINUS)
+#define IEEE80211_CHAN_11NA_HT40PLUS \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_HT40PLUS)
+#define IEEE80211_CHAN_11NA_HT40MINUS \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_HT40MINUS)
+
+#define IEEE80211_CHAN_ALL \
+    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_GFSK | \
+    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_DYN | \
+    IEEE80211_CHAN_HT20 | IEEE80211_CHAN_HT40PLUS | IEEE80211_CHAN_HT40MINUS | \
+    IEEE80211_CHAN_VHT20 | IEEE80211_CHAN_VHT40PLUS | IEEE80211_CHAN_VHT40MINUS | IEEE80211_CHAN_VHT80 | \
+    IEEE80211_CHAN_HALF | IEEE80211_CHAN_QUARTER)
+#define IEEE80211_CHAN_ALLTURBO \
+    (IEEE80211_CHAN_ALL | IEEE80211_CHAN_TURBO | IEEE80211_CHAN_STURBO)
+
+#define IEEE80211_IS_CHAN_FHSS(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_FHSS) == IEEE80211_CHAN_FHSS)
+#define IEEE80211_IS_CHAN_A(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_A) == IEEE80211_CHAN_A)
+#define IEEE80211_IS_CHAN_B(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_B) == IEEE80211_CHAN_B)
+#define IEEE80211_IS_CHAN_PUREG(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_PUREG) == IEEE80211_CHAN_PUREG)
+#define IEEE80211_IS_CHAN_G(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_G) == IEEE80211_CHAN_G)
+#define IEEE80211_IS_CHAN_ANYG(_c) \
+    (IEEE80211_IS_CHAN_PUREG(_c) || IEEE80211_IS_CHAN_G(_c))
+#define IEEE80211_IS_CHAN_ST(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_ST) == IEEE80211_CHAN_ST)
+#define IEEE80211_IS_CHAN_108A(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_108A) == IEEE80211_CHAN_108A)
+#define IEEE80211_IS_CHAN_108G(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_108G) == IEEE80211_CHAN_108G)
+
+#define IEEE80211_IS_CHAN_2GHZ(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_2GHZ) != 0)
+#define IEEE80211_IS_CHAN_5GHZ(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_5GHZ) != 0)
+#define IEEE80211_IS_CHAN_OFDM(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_OFDM) != 0)
+#define IEEE80211_IS_CHAN_CCK(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_CCK) != 0)
+#define IEEE80211_IS_CHAN_GFSK(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_GFSK) != 0)
+#define IEEE80211_IS_CHAN_TURBO(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_TURBO) != 0)
+#define IEEE80211_IS_CHAN_WEATHER_RADAR(_c) \
+    ((((_c)->ic_freq >= 5600) && ((_c)->ic_freq <= 5650)) \
+     || (((_c)->ic_flags & IEEE80211_CHAN_HT40PLUS) && (5580 == (_c)->ic_freq)))
+#define IEEE80211_IS_CHAN_STURBO(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_STURBO) != 0)
+#define IEEE80211_IS_CHAN_DTURBO(_c) \
+    (((_c)->ic_flags & \
+    (IEEE80211_CHAN_TURBO | IEEE80211_CHAN_STURBO)) == IEEE80211_CHAN_TURBO)
+#define IEEE80211_IS_CHAN_HALF(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_HALF) != 0)
+#define IEEE80211_IS_CHAN_QUARTER(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_QUARTER) != 0)
+#define IEEE80211_IS_CHAN_PASSIVE(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_PASSIVE) != 0)
+
+#define IEEE80211_IS_CHAN_DFS(_c) \
+    (((_c)->ic_flagext & (IEEE80211_CHAN_DFS|IEEE80211_CHAN_DFS_CLEAR)) == IEEE80211_CHAN_DFS)
+#define IEEE80211_IS_CHAN_DFSFLAG(_c) \
+    (((_c)->ic_flagext & IEEE80211_CHAN_DFS) == IEEE80211_CHAN_DFS)
+#define IEEE80211_IS_CHAN_DISALLOW_ADHOC(_c) \
+    (((_c)->ic_flagext & IEEE80211_CHAN_DISALLOW_ADHOC) != 0)
+#define IEEE80211_IS_CHAN_11D_EXCLUDED(_c) \
+    (((_c)->ic_flagext & IEEE80211_CHAN_11D_EXCLUDED) != 0)
+#define IEEE80211_IS_CHAN_CSA(_c) \
+    (((_c)->ic_flagext & IEEE80211_CHAN_CSA_RECEIVED) != 0)
+#define IEEE80211_IS_CHAN_ODD(_c) \
+    (((_c)->ic_freq == 5170) || ((_c)->ic_freq == 5190) || \
+     ((_c)->ic_freq == 5210) || ((_c)->ic_freq == 5230))
+#define IEEE80211_IS_CHAN_DISALLOW_HOSTAP(_c) \
+    (((_c)->ic_flagext & IEEE80211_CHAN_DISALLOW_HOSTAP) != 0)
+
+#define IEEE80211_IS_CHAN_11NG_HT20(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11NG_HT20) == IEEE80211_CHAN_11NG_HT20)
+#define IEEE80211_IS_CHAN_11NA_HT20(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11NA_HT20) == IEEE80211_CHAN_11NA_HT20)
+#define IEEE80211_IS_CHAN_11NG_HT40PLUS(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11NG_HT40PLUS) == IEEE80211_CHAN_11NG_HT40PLUS)
+#define IEEE80211_IS_CHAN_11NG_HT40MINUS(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11NG_HT40MINUS) == IEEE80211_CHAN_11NG_HT40MINUS)
+#define IEEE80211_IS_CHAN_11NA_HT40PLUS(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11NA_HT40PLUS) == IEEE80211_CHAN_11NA_HT40PLUS)
+#define IEEE80211_IS_CHAN_11NA_HT40MINUS(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11NA_HT40MINUS) == IEEE80211_CHAN_11NA_HT40MINUS)
+
+#define IEEE80211_IS_CHAN_11N(_c) \
+    (((_c)->ic_flags & (IEEE80211_CHAN_HT20 | IEEE80211_CHAN_HT40PLUS | IEEE80211_CHAN_HT40MINUS)) != 0)
+#define IEEE80211_IS_CHAN_11N_HT20(_c) \
+    (((_c)->ic_flags & (IEEE80211_CHAN_HT20)) != 0)
+#define IEEE80211_IS_CHAN_11N_HT40(_c) \
+    (((_c)->ic_flags & (IEEE80211_CHAN_HT40PLUS | IEEE80211_CHAN_HT40MINUS)) != 0)
+#define IEEE80211_IS_CHAN_11NG(_c) \
+    (IEEE80211_IS_CHAN_2GHZ((_c)) && IEEE80211_IS_CHAN_11N((_c)))
+#define IEEE80211_IS_CHAN_11NA(_c) \
+    (IEEE80211_IS_CHAN_5GHZ((_c)) && IEEE80211_IS_CHAN_11N((_c)))
+#define IEEE80211_IS_CHAN_11N_HT40PLUS(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_HT40PLUS) != 0)
+#define IEEE80211_IS_CHAN_11N_HT40MINUS(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_HT40MINUS) != 0)
+
+#define IEEE80211_IS_CHAN_HT20_CAPABLE(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_HT20) == IEEE80211_CHAN_HT20)
+#define IEEE80211_IS_CHAN_HT40PLUS_CAPABLE(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_HT40PLUS) == IEEE80211_CHAN_HT40PLUS)
+#define IEEE80211_IS_CHAN_HT40MINUS_CAPABLE(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_HT40MINUS) == IEEE80211_CHAN_HT40MINUS)
+#define IEEE80211_IS_CHAN_HT40_CAPABLE(_c) \
+    (IEEE80211_IS_CHAN_HT40PLUS_CAPABLE(_c) || IEEE80211_IS_CHAN_HT40MINUS_CAPABLE(_c))
+#define IEEE80211_IS_CHAN_HT_CAPABLE(_c) \
+    (IEEE80211_IS_CHAN_HT20_CAPABLE(_c) || IEEE80211_IS_CHAN_HT40_CAPABLE(_c))
+#define IEEE80211_IS_CHAN_11N_CTL_CAPABLE(_c)  IEEE80211_IS_CHAN_HT20_CAPABLE(_c)
+#define IEEE80211_IS_CHAN_11N_CTL_U_CAPABLE(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_HT40PLUS) == IEEE80211_CHAN_HT40PLUS)
+#define IEEE80211_IS_CHAN_11N_CTL_L_CAPABLE(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_HT40MINUS) == IEEE80211_CHAN_HT40MINUS)
+#define IEEE80211_IS_CHAN_11N_CTL_40_CAPABLE(_c) \
+    (IEEE80211_IS_CHAN_11N_CTL_U_CAPABLE((_c)) || IEEE80211_IS_CHAN_11N_CTL_L_CAPABLE((_c)))
+
+
+#define IEEE80211_IS_CHAN_VHT(_c) \
+    (((_c)->ic_flags & (IEEE80211_CHAN_VHT20 | \
+      IEEE80211_CHAN_VHT40PLUS | IEEE80211_CHAN_VHT40MINUS | IEEE80211_CHAN_VHT80)) != 0)
+#define IEEE80211_IS_CHAN_11AC(_c) \
+    ( IEEE80211_IS_CHAN_5GHZ((_c)) && IEEE80211_IS_CHAN_VHT((_c)) )
+#define IEEE80211_CHAN_11AC_VHT20 \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_VHT20)
+#define IEEE80211_CHAN_11AC_VHT40 \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_VHT40PLUS | IEEE80211_CHAN_VHT40MINUS )
+#define IEEE80211_CHAN_11AC_VHT40PLUS \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_VHT40PLUS)
+#define IEEE80211_CHAN_11AC_VHT40MINUS \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_VHT40MINUS)    
+#define IEEE80211_CHAN_11AC_VHT80 \
+    (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_VHT80)
+#define IEEE80211_IS_CHAN_11AC_VHT20(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11AC_VHT20) == IEEE80211_CHAN_11AC_VHT20)
+    
+#define IEEE80211_IS_CHAN_11AC_VHT40(_c) \
+    (((_c)->ic_flags & (IEEE80211_CHAN_VHT40PLUS | IEEE80211_CHAN_VHT40MINUS)) !=0)
+#define IEEE80211_IS_CHAN_11AC_VHT40PLUS(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11AC_VHT40PLUS) == IEEE80211_CHAN_11AC_VHT40PLUS)
+#define IEEE80211_IS_CHAN_11AC_VHT40MINUS(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11AC_VHT40MINUS) == IEEE80211_CHAN_11AC_VHT40MINUS)    
+#define IEEE80211_IS_CHAN_11AC_VHT80(_c) \
+    (((_c)->ic_flags & IEEE80211_CHAN_11AC_VHT80) == IEEE80211_CHAN_11AC_VHT80)
+#define IEEE80211_CH_HOPPING_SET_CHAN_BLOCKED(_c)    \
+    ((_c)->ic_flags |= IEEE80211_CHAN_BLOCKED)
+#define IEEE80211_CH_HOPPING_IS_CHAN_BLOCKED(_c)    \
+    (((_c)->ic_flags & IEEE80211_CHAN_BLOCKED) == IEEE80211_CHAN_BLOCKED)
+#define IEEE80211_CH_HOPPING_CLEAR_CHAN_BLOCKED(_c)    \
+    ((_c)->ic_flags &= ~IEEE80211_CHAN_BLOCKED)
+#define IEEE80211_IS_CHAN_RADAR(_c)    \
+    (((_c)->ic_flags & IEEE80211_CHAN_RADAR) == IEEE80211_CHAN_RADAR)
+#define IEEE80211_CHAN_SET_RADAR(_c)    \
+    ((_c)->ic_flags |= IEEE80211_CHAN_RADAR)
+#define IEEE80211_CHAN_CLR_RADAR(_c)    \
+    ((_c)->ic_flags &= ~IEEE80211_CHAN_RADAR)
+#define IEEE80211_CHAN_SET_DISALLOW_ADHOC(_c)   \
+    ((_c)->ic_flagext |= IEEE80211_CHAN_DISALLOW_ADHOC)
+#define IEEE80211_CHAN_SET_DISALLOW_HOSTAP(_c)   \
+    ((_c)->ic_flagext |= IEEE80211_CHAN_DISALLOW_HOSTAP)
+#define IEEE80211_CHAN_SET_DFS(_c)  \
+    ((_c)->ic_flagext |= IEEE80211_CHAN_DFS)
+#define IEEE80211_CHAN_SET_DFS_CLEAR(_c)  \
+    ((_c)->ic_flagext |= IEEE80211_CHAN_DFS_CLEAR)
+#define IEEE80211_CHAN_EXCLUDE_11D(_c)  \
+    ((_c)->ic_flagext |= IEEE80211_CHAN_11D_EXCLUDED)
+
+/* channel encoding for FH phy */
+#define IEEE80211_FH_CHANMOD            80
+#define IEEE80211_FH_CHAN(set,pat)      (((set)-1)*IEEE80211_FH_CHANMOD+(pat))
+#define IEEE80211_FH_CHANSET(chan)      ((chan)/IEEE80211_FH_CHANMOD+1)
+#define IEEE80211_FH_CHANPAT(chan)      ((chan)%IEEE80211_FH_CHANMOD)
+
+/*
+ * 802.11 rate set.
+ */
+#define IEEE80211_RATE_SIZE     8               /* 802.11 standard */
+#define IEEE80211_RATE_MAXSIZE  36              /* max rates we'll handle */
+#define IEEE80211_HT_RATE_SIZE  128
+#define IEEE80211_RATE_SINGLE_STREAM_MCS_MAX     7  /* MCS7 */
+
+#define IEEE80211_RATE_MCS      0x8000
+#define IEEE80211_RATE_MCS_VAL  0x7FFF
+
+#define IEEE80211_RATE_IDX_ENTRY(val, idx) (((val&(0xff<<(idx*8)))>>(idx*8)))
+
+/*
+ * RSSI range
+ */
+#define IEEE80211_RSSI_MAX           -10   /* in db */
+#define IEEE80211_RSSI_MIN           -200
+
+/*
+ * 11n A-MPDU & A-MSDU limits
+ */
+#define IEEE80211_AMPDU_LIMIT_MIN           (1 * 1024)
+#define IEEE80211_AMPDU_LIMIT_MAX           (64 * 1024 - 1)
+#define IEEE80211_AMPDU_LIMIT_DEFAULT       IEEE80211_AMPDU_LIMIT_MAX
+#define IEEE80211_AMPDU_SUBFRAME_MIN        2 
+#define IEEE80211_AMPDU_SUBFRAME_MAX        64 
+#define IEEE80211_AMPDU_SUBFRAME_DEFAULT    32 
+#define IEEE80211_AMSDU_LIMIT_MAX           4096
+#define IEEE80211_RIFS_AGGR_DIV             10
+#define IEEE80211_MAX_AMPDU_MIN             0
+#define IEEE80211_MAX_AMPDU_MAX             3
+
+/*
+ * 11ac A-MPDU limits
+ */
+#define IEEE80211_VHT_MAX_AMPDU_MIN         0
+#define IEEE80211_VHT_MAX_AMPDU_MAX         7
+
+
+
+struct ieee80211_rateset {
+    u_int8_t                rs_nrates;
+    u_int8_t                rs_rates[IEEE80211_RATE_MAXSIZE];
+};
+
+struct ieee80211_beacon_info{
+    u_int8_t    essid[IEEE80211_NWID_LEN+1];
+    u_int8_t    esslen;
+    u_int8_t	rssi_ctl_0;
+    u_int8_t	rssi_ctl_1;
+    u_int8_t	rssi_ctl_2;
+    int         numchains;
+};
+
+struct ieee80211_ibss_peer_list{
+    u_int8_t    bssid[6];
+};
+
+struct ieee80211_roam {
+    int8_t                  rssi11a;        /* rssi thresh for 11a bss */
+    int8_t                  rssi11b;        /* for 11g sta in 11b bss */
+    int8_t                  rssi11bOnly;    /* for 11b sta */
+    u_int8_t                pad1;
+    u_int8_t                rate11a;        /* rate thresh for 11a bss */
+    u_int8_t                rate11b;        /* for 11g sta in 11b bss */
+    u_int8_t                rate11bOnly;    /* for 11b sta */
+    u_int8_t                pad2;
+};
+
+#define IEEE80211_TID_SIZE      17 /* total number of TIDs */
+#define IEEE80211_NON_QOS_SEQ   16 /* index for non-QoS (including management) sequence number space */
+#define IEEE80211_SEQ_MASK      0xfff   /* sequence generator mask*/
+#define MIN_SW_SEQ              0x100   /* minimum sequence for SW generate packect*/
+
+#define IEEE80211_ADDR_LEN  6       /* size of 802.11 address */
+
+/* crypto related defines*/
+#define IEEE80211_KEYBUF_SIZE   16
+#define IEEE80211_MICBUF_SIZE   (8+8)   /* space for both tx+rx keys */
+#define IEEE80211_KEY_WEP40_LEN  5    /* 40 bit key */
+#define IEEE80211_KEY_WEP104_LEN  13  /* 104 bit key */
+#define IEEE80211_KEY_WEP128_LEN  16  /* 128 bit key */
+
+enum ieee80211_clist_cmd {
+    CLIST_UPDATE,
+    CLIST_DFS_UPDATE,
+    CLIST_NEW_COUNTRY,
+    CLIST_NOL_UPDATE
+};
+
+enum ieee80211_nawds_param {
+    IEEE80211_NAWDS_PARAM_NUM = 0,
+    IEEE80211_NAWDS_PARAM_MODE,
+    IEEE80211_NAWDS_PARAM_DEFCAPS,
+    IEEE80211_NAWDS_PARAM_OVERRIDE,
+};
+
+struct ieee80211_mib_cycle_cnts {
+    u_int32_t   tx_frame_count;
+    u_int32_t   rx_frame_count;
+    u_int32_t   rx_clear_count;
+    u_int32_t   cycle_count;
+    u_int8_t    is_rx_active;
+    u_int8_t    is_tx_active;
+};
+
+struct ieee80211_chanutil_info {
+    u_int32_t    rx_clear_count;
+    u_int32_t    cycle_count;
+    u_int8_t     value;
+    u_int32_t    beacon_count;
+    u_int8_t     beacon_intervals;
+};
+
+#endif /* __NET80211__IEEE80211_H_ */
diff -Naur hostapd-2.9/src/drivers/ieee80211.h hostapd-2.9-new/src/drivers/ieee80211.h
--- hostapd-2.9/src/drivers/ieee80211.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ieee80211.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,2294 @@
+/*
+ *  Copyright (c) 2008 Atheros Communications Inc. 
+ * All Rights Reserved.
+ * 
+ * Copyright (c) 2011 Qualcomm Atheros, Inc.
+ * All Rights Reserved.
+ * Qualcomm Atheros Confidential and Proprietary.
+ * 
+ */
+
+#ifndef EXTERNAL_USE_ONLY
+#include <osdep.h>
+#endif /* EXTERNAL_USE_ONLY */
+#include "_ieee80211.h"
+
+#ifndef _NET80211_IEEE80211_H_
+#define _NET80211_IEEE80211_H_
+
+#ifdef WIN32
+#include <pshpack1.h>
+#endif
+
+/*
+ * 802.11 protocol definitions.
+ */
+
+/* is 802.11 address multicast/broadcast? */
+#define IEEE80211_IS_MULTICAST(_a)  (*(_a) & 0x01)
+
+#define IEEE80211_IS_IPV4_MULTICAST(_a)  (*(_a) == 0x01)
+
+#define IEEE80211_IS_IPV6_MULTICAST(_a)         \
+    ((_a)[0] == 0x33 &&                         \
+     (_a)[1] == 0x33)
+
+
+#define IEEE80211_IS_BROADCAST(_a)              \
+    ((_a)[0] == 0xff &&                         \
+     (_a)[1] == 0xff &&                         \
+     (_a)[2] == 0xff &&                         \
+     (_a)[3] == 0xff &&                         \
+     (_a)[4] == 0xff &&                         \
+     (_a)[5] == 0xff)
+
+/* IEEE 802.11 PLCP header */
+struct ieee80211_plcp_hdr {
+    u_int16_t   i_sfd;
+    u_int8_t    i_signal;
+    u_int8_t    i_service;
+    u_int16_t   i_length;
+    u_int16_t   i_crc;
+} __packed;
+
+#define IEEE80211_PLCP_SFD      0xF3A0 
+#define IEEE80211_PLCP_SERVICE  0x00
+
+/*
+ * generic definitions for IEEE 802.11 frames
+ */
+struct ieee80211_frame {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    union {
+        struct {
+            u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+            u_int8_t    i_addr2[IEEE80211_ADDR_LEN];
+            u_int8_t    i_addr3[IEEE80211_ADDR_LEN];
+        };
+        u_int8_t    i_addr_all[3 * IEEE80211_ADDR_LEN];
+    };
+    u_int8_t    i_seq[2];
+    /* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
+    /* see below */
+} __packed;
+
+struct ieee80211_qosframe {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr2[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr3[IEEE80211_ADDR_LEN];
+    u_int8_t    i_seq[2];
+    u_int8_t    i_qos[2];
+    /* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
+    /* see below */
+} __packed;
+
+struct ieee80211_qoscntl {
+    u_int8_t    i_qos[2];
+};
+
+struct ieee80211_frame_addr4 {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr2[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr3[IEEE80211_ADDR_LEN];
+    u_int8_t    i_seq[2];
+    u_int8_t    i_addr4[IEEE80211_ADDR_LEN];
+} __packed;
+
+struct ieee80211_qosframe_addr4 {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr2[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr3[IEEE80211_ADDR_LEN];
+    u_int8_t    i_seq[2];
+    u_int8_t    i_addr4[IEEE80211_ADDR_LEN];
+    u_int8_t    i_qos[2];
+} __packed;
+
+/* HTC frame for TxBF*/
+// for TxBF RC
+struct ieee80211_frame_min_one {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+
+} __packed;// For TxBF RC
+
+struct ieee80211_qosframe_htc {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr2[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr3[IEEE80211_ADDR_LEN];
+    u_int8_t    i_seq[2];
+    u_int8_t    i_qos[2];
+    u_int8_t    i_htc[4];
+    /* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
+    /* see below */
+} __packed;
+struct ieee80211_qosframe_htc_addr4 {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr2[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr3[IEEE80211_ADDR_LEN];
+    u_int8_t    i_seq[2];
+    u_int8_t    i_addr4[IEEE80211_ADDR_LEN];
+    u_int8_t    i_qos[2];
+    u_int8_t    i_htc[4];
+} __packed;
+struct ieee80211_htc {
+    u_int8_t    i_htc[4];
+};
+/*HTC frame for TxBF*/
+
+struct ieee80211_ctlframe_addr2 {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_aidordur[2]; /* AID or duration */
+    u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr2[IEEE80211_ADDR_LEN];
+} __packed;
+
+#define	IEEE80211_WHQ(wh)		((struct ieee80211_qosframe *)(wh))
+#define	IEEE80211_WH4(wh)		((struct ieee80211_frame_addr4 *)(wh))
+#define	IEEE80211_WHQ4(wh)		((struct ieee80211_qosframe_addr4 *)(wh))
+
+#define IEEE80211_FC0_VERSION_MASK          0x03
+#define IEEE80211_FC0_VERSION_SHIFT         0
+#define IEEE80211_FC0_VERSION_0             0x00
+#define IEEE80211_FC0_TYPE_MASK             0x0c
+#define IEEE80211_FC0_TYPE_SHIFT            2
+#define IEEE80211_FC0_TYPE_MGT              0x00
+#define IEEE80211_FC0_TYPE_CTL              0x04
+#define IEEE80211_FC0_TYPE_DATA             0x08
+
+#define IEEE80211_FC0_SUBTYPE_MASK          0xf0
+#define IEEE80211_FC0_SUBTYPE_SHIFT         4
+/* for TYPE_MGT */
+#define IEEE80211_FC0_SUBTYPE_ASSOC_REQ     0x00
+#define IEEE80211_FC0_SUBTYPE_ASSOC_RESP    0x10
+#define IEEE80211_FC0_SUBTYPE_REASSOC_REQ   0x20
+#define IEEE80211_FC0_SUBTYPE_REASSOC_RESP  0x30
+#define IEEE80211_FC0_SUBTYPE_PROBE_REQ     0x40
+#define IEEE80211_FC0_SUBTYPE_PROBE_RESP    0x50
+#define IEEE80211_FC0_SUBTYPE_BEACON        0x80
+#define IEEE80211_FC0_SUBTYPE_ATIM          0x90
+#define IEEE80211_FC0_SUBTYPE_DISASSOC      0xa0
+#define IEEE80211_FC0_SUBTYPE_AUTH          0xb0
+#define IEEE80211_FC0_SUBTYPE_DEAUTH        0xc0
+#define IEEE80211_FC0_SUBTYPE_ACTION        0xd0
+#define IEEE80211_FCO_SUBTYPE_ACTION_NO_ACK 0xe0
+/* for TYPE_CTL */
+#define IEEE80211_FCO_SUBTYPE_Control_Wrapper   0x70    // For TxBF RC
+#define IEEE80211_FC0_SUBTYPE_BAR           0x80
+#define IEEE80211_FC0_SUBTYPE_PS_POLL       0xa0
+#define IEEE80211_FC0_SUBTYPE_RTS           0xb0
+#define IEEE80211_FC0_SUBTYPE_CTS           0xc0
+#define IEEE80211_FC0_SUBTYPE_ACK           0xd0
+#define IEEE80211_FC0_SUBTYPE_CF_END        0xe0
+#define IEEE80211_FC0_SUBTYPE_CF_END_ACK    0xf0
+/* for TYPE_DATA (bit combination) */
+#define IEEE80211_FC0_SUBTYPE_DATA          0x00
+#define IEEE80211_FC0_SUBTYPE_CF_ACK        0x10
+#define IEEE80211_FC0_SUBTYPE_CF_POLL       0x20
+#define IEEE80211_FC0_SUBTYPE_CF_ACPL       0x30
+#define IEEE80211_FC0_SUBTYPE_NODATA        0x40
+#define IEEE80211_FC0_SUBTYPE_CFACK         0x50
+#define IEEE80211_FC0_SUBTYPE_CFPOLL        0x60
+#define IEEE80211_FC0_SUBTYPE_CF_ACK_CF_ACK 0x70
+#define IEEE80211_FC0_SUBTYPE_QOS           0x80
+#define IEEE80211_FC0_SUBTYPE_QOS_NULL      0xc0
+
+#define IEEE80211_FC1_DIR_MASK              0x03
+#define IEEE80211_FC1_DIR_NODS              0x00    /* STA->STA */
+#define IEEE80211_FC1_DIR_TODS              0x01    /* STA->AP  */
+#define IEEE80211_FC1_DIR_FROMDS            0x02    /* AP ->STA */
+#define IEEE80211_FC1_DIR_DSTODS            0x03    /* AP ->AP  */
+
+#define IEEE80211_FC1_MORE_FRAG             0x04
+#define IEEE80211_FC1_RETRY                 0x08
+#define IEEE80211_FC1_PWR_MGT               0x10
+#define IEEE80211_FC1_MORE_DATA             0x20
+#define IEEE80211_FC1_WEP                   0x40
+#define IEEE80211_FC1_ORDER                 0x80
+
+#define IEEE80211_SEQ_FRAG_MASK             0x000f
+#define IEEE80211_SEQ_FRAG_SHIFT            0
+#define IEEE80211_SEQ_SEQ_MASK              0xfff0
+#define IEEE80211_SEQ_SEQ_SHIFT             4
+#define IEEE80211_SEQ_MAX                   4096
+
+#define IEEE80211_SEQ_LEQ(a,b)  ((int)((a)-(b)) <= 0)
+
+
+#define IEEE80211_QOS_TXOP                  0x00ff
+
+#define IEEE80211_QOS_AMSDU                 0x80
+#define IEEE80211_QOS_AMSDU_S               7
+#define IEEE80211_QOS_ACKPOLICY             0x60
+#define IEEE80211_QOS_ACKPOLICY_S           5
+#define IEEE80211_QOS_EOSP                  0x10
+#define IEEE80211_QOS_EOSP_S                4
+#define IEEE80211_QOS_TID                   0x0f
+#define IEEE80211_MFP_TID                   0xff
+
+#define IEEE80211_HTC0_TRQ                  0x02
+#define	IEEE80211_HTC2_CalPos               0x03
+#define	IEEE80211_HTC2_CalSeq               0x0C
+#define	IEEE80211_HTC2_CSI_NONCOMP_BF       0x80
+#define	IEEE80211_HTC2_CSI_COMP_BF          0xc0
+
+/* Set bits 14 and 15 to 1 when duration field carries Association ID */
+#define IEEE80211_FIELD_TYPE_AID            0xC000
+
+#define IEEE80211_IS_BEACON(_frame)    ((((_frame)->i_fc[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_MGT) && \
+                                        (((_frame)->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_BEACON))
+#define IEEE80211_IS_DATA(_frame)      (((_frame)->i_fc[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_DATA)
+
+#define IEEE80211_IS_MFP_FRAME(_frame) ((((_frame)->i_fc[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_MGT) && \
+                                        ((_frame)->i_fc[1] & IEEE80211_FC1_WEP) && \
+                                        ((((_frame)->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_DEAUTH) || \
+                                         (((_frame)->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_DISASSOC) || \
+                                         (((_frame)->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_ACTION)))
+#define IEEE80211_IS_AUTH(_frame)      ((((_frame)->i_fc[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_MGT) && \
+                                        (((_frame)->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_AUTH))
+
+/* MCS Set */
+#define IEEE80211_RX_MCS_1_STREAM_BYTE_OFFSET 0
+#define IEEE80211_RX_MCS_2_STREAM_BYTE_OFFSET 1
+#define IEEE80211_RX_MCS_3_STREAM_BYTE_OFFSET 2
+#define IEEE80211_RX_MCS_ALL_NSTREAM_RATES 0xff
+#define IEEE80211_TX_MCS_OFFSET 12
+
+#define IEEE80211_TX_MCS_SET_DEFINED 0x01
+#define IEEE80211_TX_RX_MCS_SET_NOT_EQUAL 0x02
+#define IEEE80211_TX_1_SPATIAL_STREAMS 0x0
+#define IEEE80211_TX_2_SPATIAL_STREAMS 0x06
+#define IEEE80211_TX_3_SPATIAL_STREAMS 0x08
+#define IEEE80211_TX_4_SPATIAL_STREAMS 0x0c
+
+#define IEEE80211_TX_MAXIMUM_STREAMS_MASK     0x0c 
+#define IEEE80211_TX_UNEQUAL_MODULATION_MASK  0x10
+
+#define IEEE80211_TX_MCS_SET 0x1f
+
+/*
+ * Subtype data: If bit 6 is set then the data frame contains no actual data.
+ */
+#define IEEE80211_FC0_SUBTYPE_NO_DATA_MASK  0x40
+#define IEEE80211_CONTAIN_DATA(_subtype) \
+    (! ((_subtype) & IEEE80211_FC0_SUBTYPE_NO_DATA_MASK))
+    
+#define IEEE8023_MAX_LEN 0x600 /* 1536 - larger is Ethernet II */
+#define RFC1042_SNAP_ORGCODE_0 0x00
+#define RFC1042_SNAP_ORGCODE_1 0x00
+#define RFC1042_SNAP_ORGCODE_2 0x00
+
+#define BTEP_SNAP_ORGCODE_0 0x00
+#define BTEP_SNAP_ORGCODE_1 0x00
+#define BTEP_SNAP_ORGCODE_2 0xf8
+
+/* BT 3.0 */
+#define BTAMP_SNAP_ORGCODE_0 0x00
+#define BTAMP_SNAP_ORGCODE_1 0x19
+#define BTAMP_SNAP_ORGCODE_2 0x58
+
+/* Aironet OUI Codes */
+#define AIRONET_SNAP_CODE_0  0x00
+#define AIRONET_SNAP_CODE_1  0x40
+#define AIRONET_SNAP_CODE_2  0x96
+
+#define IEEE80211_LSIG_LEN  3
+#define IEEE80211_HTSIG_LEN 6
+#define IEEE80211_SB_LEN    2
+
+/* 
+ * Information element header format
+ */
+struct ieee80211_ie_header {
+    u_int8_t    element_id;     /* Element Id */
+    u_int8_t    length;         /* IE Length */
+} __packed;
+
+/* 
+ * Country information element.
+ */
+#define IEEE80211_COUNTRY_MAX_TRIPLETS (83)
+struct ieee80211_ie_country {
+    u_int8_t    country_id;
+    u_int8_t    country_len;
+    u_int8_t    country_str[3];
+    u_int8_t    country_triplet[IEEE80211_COUNTRY_MAX_TRIPLETS*3];
+} __packed;
+
+/* does frame have QoS sequence control data */
+#define IEEE80211_QOS_HAS_SEQ(wh) \
+    (((wh)->i_fc[0] & \
+      (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) == \
+      (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS))
+
+#define WME_QOSINFO_UAPSD   0x80  /* Mask for U-APSD field */
+#define WME_QOSINFO_COUNT   0x0f  /* Mask for Param Set Count field */
+/*
+ * WME/802.11e information element.
+ */
+struct ieee80211_ie_wme {
+    u_int8_t    wme_id;         /* IEEE80211_ELEMID_VENDOR */
+    u_int8_t    wme_len;        /* length in bytes */
+    u_int8_t    wme_oui[3];     /* 0x00, 0x50, 0xf2 */
+    u_int8_t    wme_type;       /* OUI type */
+    u_int8_t    wme_subtype;    /* OUI subtype */
+    u_int8_t    wme_version;    /* spec revision */
+    u_int8_t    wme_info;       /* QoS info */
+} __packed;
+
+/*
+ * TS INFO part of the tspec element is a collection of bit flags
+ */
+#if _BYTE_ORDER == _BIG_ENDIAN
+struct ieee80211_tsinfo_bitmap {
+    u_int8_t    one       : 1,
+                direction : 2,
+                tid       : 4,
+                reserved1 : 1;
+    u_int8_t    reserved2 : 2,
+                dot1Dtag  : 3,
+                psb       : 1,
+                reserved3 : 1,
+                zero      : 1;
+    u_int8_t    reserved5 : 7,
+                reserved4 : 1;
+} __packed;
+#else
+struct ieee80211_tsinfo_bitmap {
+    u_int8_t    reserved1 : 1,
+                tid       : 4,
+                direction : 2,
+                one       : 1;
+    u_int8_t    zero      : 1,
+                reserved3 : 1,
+                psb       : 1,
+                dot1Dtag  : 3,
+                reserved2 : 2;
+    u_int8_t    reserved4 : 1,
+                reserved5 : 7;
+}  __packed;
+#endif
+
+/*
+ * WME/802.11e Tspec Element
+ */
+struct ieee80211_wme_tspec {
+    u_int8_t    ts_id;
+    u_int8_t    ts_len;
+    u_int8_t    ts_oui[3];
+    u_int8_t    ts_oui_type;
+    u_int8_t    ts_oui_subtype;
+    u_int8_t    ts_version;
+    union {
+        struct {
+            u_int8_t    ts_tsinfo[3];
+            u_int8_t    ts_nom_msdu[2];
+            u_int8_t    ts_max_msdu[2];
+            u_int8_t    ts_min_svc[4];
+            u_int8_t    ts_max_svc[4];
+            u_int8_t    ts_inactv_intv[4];
+            u_int8_t    ts_susp_intv[4];
+            u_int8_t    ts_start_svc[4];
+            u_int8_t    ts_min_rate[4];
+            u_int8_t    ts_mean_rate[4];
+            u_int8_t    ts_peak_rate[4];
+            u_int8_t    ts_max_burst[4];
+            u_int8_t    ts_delay[4];
+            u_int8_t    ts_min_phy[4];
+            u_int8_t    ts_surplus[2];
+            u_int8_t    ts_medium_time[2];
+        };
+        u_int8_t wme_info_all[55];
+    };
+} __packed;
+
+/*
+ * WME AC parameter field
+ */
+struct ieee80211_wme_acparams {
+    u_int8_t    acp_aci_aifsn;
+    u_int8_t    acp_logcwminmax;
+    u_int16_t   acp_txop;
+} __packed;
+
+#define IEEE80211_WME_PARAM_LEN 24
+#define WME_NUM_AC              4       /* 4 AC categories */
+
+#define WME_PARAM_ACI           0x60    /* Mask for ACI field */
+#define WME_PARAM_ACI_S         5       /* Shift for ACI field */
+#define WME_PARAM_ACM           0x10    /* Mask for ACM bit */
+#define WME_PARAM_ACM_S         4       /* Shift for ACM bit */
+#define WME_PARAM_AIFSN         0x0f    /* Mask for aifsn field */
+#define WME_PARAM_AIFSN_S       0       /* Shift for aifsn field */
+#define WME_PARAM_LOGCWMIN      0x0f    /* Mask for CwMin field (in log) */
+#define WME_PARAM_LOGCWMIN_S    0       /* Shift for CwMin field */
+#define WME_PARAM_LOGCWMAX      0xf0    /* Mask for CwMax field (in log) */
+#define WME_PARAM_LOGCWMAX_S    4       /* Shift for CwMax field */
+
+#define WME_AC_TO_TID(_ac) (       \
+    ((_ac) == WME_AC_VO) ? 6 : \
+    ((_ac) == WME_AC_VI) ? 5 : \
+    ((_ac) == WME_AC_BK) ? 1 : \
+    0)
+
+#define TID_TO_WME_AC(_tid) (      \
+    (((_tid) == 0) || ((_tid) == 3)) ? WME_AC_BE : \
+    (((_tid) == 1) || ((_tid) == 2)) ? WME_AC_BK : \
+    (((_tid) == 4) || ((_tid) == 5)) ? WME_AC_VI : \
+    WME_AC_VO)
+
+/*
+ * WME Parameter Element
+ */
+struct ieee80211_wme_param {
+    u_int8_t                        param_id;
+    u_int8_t                        param_len;
+    u_int8_t                        param_oui[3];
+    u_int8_t                        param_oui_type;
+    u_int8_t                        param_oui_sybtype;
+    u_int8_t                        param_version;
+    u_int8_t                        param_qosInfo;
+    u_int8_t                        param_reserved;
+    struct ieee80211_wme_acparams   params_acParams[WME_NUM_AC];
+} __packed;
+
+/*
+ * WME U-APSD qos info field defines
+ */
+#define WME_CAPINFO_UAPSD_EN                    0x00000080
+#define WME_CAPINFO_UAPSD_VO                    0x00000001
+#define WME_CAPINFO_UAPSD_VI                    0x00000002
+#define WME_CAPINFO_UAPSD_BK                    0x00000004
+#define WME_CAPINFO_UAPSD_BE                    0x00000008
+#define WME_CAPINFO_UAPSD_ACFLAGS_SHIFT         0
+#define WME_CAPINFO_UAPSD_ACFLAGS_MASK          0xF
+#define WME_CAPINFO_UAPSD_MAXSP_SHIFT           5
+#define WME_CAPINFO_UAPSD_MAXSP_MASK            0x3
+#define WME_CAPINFO_IE_OFFSET                   8
+#define WME_UAPSD_MAXSP(_qosinfo) (((_qosinfo) >> WME_CAPINFO_UAPSD_MAXSP_SHIFT) & WME_CAPINFO_UAPSD_MAXSP_MASK)
+#define WME_UAPSD_AC_ENABLED(_ac, _qosinfo) ( (1<<(3 - (_ac))) &   \
+        (((_qosinfo) >> WME_CAPINFO_UAPSD_ACFLAGS_SHIFT) & WME_CAPINFO_UAPSD_ACFLAGS_MASK) )
+
+/* Mask used to determined whether all queues are UAPSD-enabled */
+#define WME_CAPINFO_UAPSD_ALL                   (WME_CAPINFO_UAPSD_VO | \
+                                                 WME_CAPINFO_UAPSD_VI | \
+                                                 WME_CAPINFO_UAPSD_BK | \
+                                                 WME_CAPINFO_UAPSD_BE)
+#define WME_CAPINFO_UAPSD_NONE                  0
+
+#define WME_UAPSD_AC_MAX_VAL 		1
+#define WME_UAPSD_AC_INVAL		 	WME_UAPSD_AC_MAX_VAL+1
+
+/*
+ * Atheros Advanced Capability information element.
+ */
+struct ieee80211_ie_athAdvCap {
+    u_int8_t    athAdvCap_id;           /* IEEE80211_ELEMID_VENDOR */
+    u_int8_t    athAdvCap_len;          /* length in bytes */
+    u_int8_t    athAdvCap_oui[3];       /* 0x00, 0x03, 0x7f */
+    u_int8_t    athAdvCap_type;         /* OUI type */
+    u_int16_t   athAdvCap_version;      /* spec revision */
+    u_int8_t    athAdvCap_capability;   /* Capability info */
+    u_int16_t   athAdvCap_defKeyIndex;
+} __packed;
+
+/*
+ * Atheros Extended Capability information element.
+ */
+struct ieee80211_ie_ath_extcap {
+    u_int8_t    ath_extcap_id;          /* IEEE80211_ELEMID_VENDOR */
+    u_int8_t    ath_extcap_len;         /* length in bytes */
+    u_int8_t    ath_extcap_oui[3];      /* 0x00, 0x03, 0x7f */
+    u_int8_t    ath_extcap_type;        /* OUI type */
+    u_int8_t    ath_extcap_subtype;     /* OUI subtype */
+    u_int8_t    ath_extcap_version;     /* spec revision */
+    u_int32_t   ath_extcap_extcap              : 16,  /* B0-15  extended capabilities */
+                ath_extcap_weptkipaggr_rxdelim : 8,   /* B16-23 num delimiters for receiving WEP/TKIP aggregates */
+                ath_extcap_reserved            : 8;   /* B24-31 reserved */
+} __packed;
+
+/*
+ * Atheros XR information element.
+ */
+struct ieee80211_xr_param {
+    u_int8_t    param_id;
+    u_int8_t    param_len;
+    u_int8_t    param_oui[3];
+    u_int8_t    param_oui_type;
+    u_int8_t    param_oui_sybtype;
+    u_int8_t    param_version;
+    u_int8_t    param_Info;
+    u_int8_t    param_base_bssid[IEEE80211_ADDR_LEN];
+    u_int8_t    param_xr_bssid[IEEE80211_ADDR_LEN];
+    u_int16_t   param_xr_beacon_interval;
+    u_int8_t    param_base_ath_capability;
+    u_int8_t    param_xr_ath_capability;
+} __packed;
+
+/*
+ * SFA information element.
+ */
+struct ieee80211_ie_sfa {
+    u_int8_t    sfa_id;         /* IEEE80211_ELEMID_VENDOR */
+    u_int8_t    sfa_len;        /* length in bytes */
+    u_int8_t    sfa_oui[3];     /* 0x00, 0x40, 0x96 */
+    u_int8_t    sfa_type;       /* OUI type */
+    u_int8_t    sfa_caps;       /* Capabilities */
+} __packed;
+
+/* Atheros capabilities */
+#define IEEE80211_ATHC_TURBOP   0x0001      /* Turbo Prime */
+#define IEEE80211_ATHC_COMP     0x0002      /* Compression */
+#define IEEE80211_ATHC_FF       0x0004      /* Fast Frames */
+#define IEEE80211_ATHC_XR       0x0008      /* Xtended Range support */
+#define IEEE80211_ATHC_AR       0x0010      /* Advanced Radar support */
+#define IEEE80211_ATHC_BURST    0x0020      /* Bursting - not negotiated */
+#define IEEE80211_ATHC_WME      0x0040      /* CWMin tuning */
+#define IEEE80211_ATHC_BOOST    0x0080      /* Boost */
+#define IEEE80211_ATHC_TDLS     0x0100      /* TDLS */
+
+/* Atheros extended capabilities */
+/* OWL device capable of WDS workaround */
+#define IEEE80211_ATHEC_OWLWDSWAR        0x0001
+#define IEEE80211_ATHEC_WEPTKIPAGGR	     0x0002
+#define IEEE80211_ATHEC_EXTRADELIMWAR    0x0004
+#define IEEE80211_ATHEC_PN_CHECK_WAR     0x0008
+/* 
+ * Management Frames 
+ */
+
+/*
+ * *** Platform-specific code?? ***
+ * In Vista one must use bit fields of type (unsigned short = u_int16_t) to 
+ * ensure data structure is of the correct size. ANSI C used to specify only
+ * "int" bit fields, which led to a larger structure size in Windows (32 bits).
+ * 
+ * We must make sure the following construction is valid in all OS's.
+ */ 
+union ieee80211_capability {
+    struct {
+        u_int16_t    ess                 : 1;
+        u_int16_t    ibss                : 1;
+        u_int16_t    cf_pollable         : 1;
+        u_int16_t    cf_poll_request     : 1;
+        u_int16_t    privacy             : 1;
+        u_int16_t    short_preamble      : 1;
+        u_int16_t    pbcc                : 1;
+        u_int16_t    channel_agility     : 1;
+        u_int16_t    spectrum_management : 1;
+        u_int16_t    qos                 : 1;
+        u_int16_t    short_slot_time     : 1;
+        u_int16_t    apsd                : 1;
+        u_int16_t    reserved2           : 1;
+        u_int16_t    dsss_ofdm           : 1;
+        u_int16_t    del_block_ack       : 1;
+        u_int16_t    immed_block_ack     : 1;
+    };
+
+    u_int16_t   value;
+} __packed;
+
+struct ieee80211_beacon_frame {
+    u_int8_t                      timestamp[8];    /* the value of sender's TSFTIMER */
+    u_int16_t                     beacon_interval; /* the number of time units between target beacon transmission times */
+    union ieee80211_capability    capability;
+/* Value of capability for every bit    
+#define IEEE80211_CAPINFO_ESS               0x0001
+#define IEEE80211_CAPINFO_IBSS              0x0002
+#define IEEE80211_CAPINFO_CF_POLLABLE       0x0004
+#define IEEE80211_CAPINFO_CF_POLLREQ        0x0008
+#define IEEE80211_CAPINFO_PRIVACY           0x0010
+#define IEEE80211_CAPINFO_SHORT_PREAMBLE    0x0020
+#define IEEE80211_CAPINFO_PBCC              0x0040
+#define IEEE80211_CAPINFO_CHNL_AGILITY      0x0080
+#define IEEE80211_CAPINFO_SPECTRUM_MGMT     0x0100
+#define IEEE80211_CAPINFO_QOS               0x0200
+#define IEEE80211_CAPINFO_SHORT_SLOTTIME    0x0400
+#define IEEE80211_CAPINFO_APSD              0x0800
+#define IEEE80211_CAPINFO_RADIOMEAS         0x1000
+#define IEEE80211_CAPINFO_DSSSOFDM          0x2000
+bits 14-15 are reserved
+*/
+    struct ieee80211_ie_header    info_elements;
+} __packed;
+
+/* 
+ * Management Action Frames 
+ */
+
+/* generic frame format */
+struct ieee80211_action {
+    u_int8_t    ia_category;
+    u_int8_t    ia_action;
+} __packed;
+
+/* spectrum action frame header */
+struct ieee80211_action_measrep_header {
+    struct ieee80211_action action_header;
+    u_int8_t                dialog_token;
+} __packed;
+
+/* categories */
+#define IEEE80211_ACTION_CAT_SPECTRUM       0   /* Spectrum management */
+#define IEEE80211_ACTION_CAT_QOS            1   /* IEEE QoS  */
+#define IEEE80211_ACTION_CAT_DLS            2   /* DLS */
+#define IEEE80211_ACTION_CAT_BA             3   /* BA */
+#define IEEE80211_ACTION_CAT_PUBLIC         4   /* Public Action Frame */
+#define IEEE80211_ACTION_CAT_HT             7   /* HT per IEEE802.11n-D1.06 */
+#define IEEE80211_ACTION_CAT_SA_QUERY       8   /* SA Query per IEEE802.11w, PMF */
+#define IEEE80211_ACTION_CAT_PROT_DUAL      9   /* Protected Dual of public action frame */
+#define IEEE80211_ACTION_CAT_WMM_QOS       17   /* QoS from WMM specification */
+#define IEEE80211_ACTION_CAT_VHT           21   /* VHT Action */
+
+/* Spectrum Management actions */
+#define IEEE80211_ACTION_MEAS_REQUEST       0   /* Measure channels */
+#define IEEE80211_ACTION_MEAS_REPORT        1
+#define IEEE80211_ACTION_TPC_REQUEST        2   /* Transmit Power control */
+#define IEEE80211_ACTION_TPC_REPORT         3
+#define IEEE80211_ACTION_CHAN_SWITCH        4   /* 802.11h Channel Switch Announcement */
+
+/* HT actions */
+#define IEEE80211_ACTION_HT_TXCHWIDTH       0   /* recommended transmission channel width */
+#define IEEE80211_ACTION_HT_SMPOWERSAVE     1   /* Spatial Multiplexing (SM) Power Save */
+#define IEEE80211_ACTION_HT_CSI             4   /* CSI Frame */
+#define IEEE80211_ACTION_HT_NONCOMP_BF      5   /* Non-compressed Beamforming*/
+#define IEEE80211_ACTION_HT_COMP_BF         6   /* Compressed Beamforming*/
+
+/* VHT actions */
+#define IEEE80211_ACTION_VHT_OPMODE         2  /* Operating  mode notification */
+
+/* Spectrum channel switch action frame after IE*/
+/* Public Actions*/
+#define IEEE80211_ACTION_TDLS_DISCRESP  14      /* TDLS Discovery Response frame */
+
+/* HT - recommended transmission channel width */
+struct ieee80211_action_ht_txchwidth {
+    struct ieee80211_action     at_header;
+    u_int8_t                    at_chwidth; 
+} __packed;
+
+#define IEEE80211_A_HT_TXCHWIDTH_20         0
+#define IEEE80211_A_HT_TXCHWIDTH_2040       1
+
+/* HT - Spatial Multiplexing (SM) Power Save */
+struct ieee80211_action_ht_smpowersave {
+    struct ieee80211_action     as_header;
+    u_int8_t                    as_control;
+} __packed;
+
+/*HT - CSI Frame */     //for TxBF RC
+#define MIMO_CONTROL_LEN 6
+struct ieee80211_action_ht_CSI {
+    struct ieee80211_action     as_header;
+    u_int8_t                   mimo_control[MIMO_CONTROL_LEN];
+} __packed;
+
+/*HT - V/CV report frame*/
+struct ieee80211_action_ht_txbf_rpt {
+    struct ieee80211_action     as_header;
+    u_int8_t                   mimo_control[MIMO_CONTROL_LEN];
+} __packed;
+
+/*
+ * 802.11ac Operating Mode  Notification
+ */
+struct ieee80211_ie_op_mode {
+#if _BYTE_ORDER == _BIG_ENDIAN
+        u_int8_t rx_nss_type        : 1,
+                 rx_nss             : 3,
+                 reserved           : 2,
+                 ch_width           : 2;
+#else
+        u_int8_t ch_width           : 2,
+                 reserved           : 2,
+                 rx_nss             : 3,
+                 rx_nss_type        : 1;
+#endif
+} __packed;
+
+struct ieee80211_ie_op_mode_ntfy {
+        u_int8_t    elem_id;
+        u_int8_t    elem_len;
+        struct ieee80211_ie_op_mode opmode;
+} __packed;
+
+
+/* VHT - recommended Channel width and Nss */
+struct ieee80211_action_vht_opmode {
+    struct ieee80211_action     at_header;
+    struct ieee80211_ie_op_mode at_op_mode;
+} __packed;
+
+/* values defined for 'as_control' field per 802.11n-D1.06 */
+#define IEEE80211_A_HT_SMPOWERSAVE_DISABLED     0x00   /* SM Power Save Disabled, SM packets ok  */
+#define IEEE80211_A_HT_SMPOWERSAVE_ENABLED      0x01   /* SM Power Save Enabled bit  */
+#define IEEE80211_A_HT_SMPOWERSAVE_MODE         0x02   /* SM Power Save Mode bit */
+#define IEEE80211_A_HT_SMPOWERSAVE_RESERVED     0xFC   /* SM Power Save Reserved bits */
+
+/* values defined for SM Power Save Mode bit */
+#define IEEE80211_A_HT_SMPOWERSAVE_STATIC       0x00   /* Static, SM packets not ok */
+#define IEEE80211_A_HT_SMPOWERSAVE_DYNAMIC      0x02   /* Dynamic, SM packets ok if preceded by RTS */
+
+/* DLS actions */
+#define IEEE80211_ACTION_DLS_REQUEST            0
+#define IEEE80211_ACTION_DLS_RESPONSE           1
+#define IEEE80211_ACTION_DLS_TEARDOWN           2
+
+struct ieee80211_dls_request {
+	struct ieee80211_action hdr;
+    u_int8_t dst_addr[IEEE80211_ADDR_LEN];
+    u_int8_t src_addr[IEEE80211_ADDR_LEN];
+    u_int16_t capa_info;
+    u_int16_t timeout;
+} __packed;
+
+struct ieee80211_dls_response {
+	struct ieee80211_action hdr;
+    u_int16_t statuscode;
+    u_int8_t dst_addr[IEEE80211_ADDR_LEN];
+    u_int8_t src_addr[IEEE80211_ADDR_LEN];
+} __packed;
+
+/* BA actions */
+#define IEEE80211_ACTION_BA_ADDBA_REQUEST       0   /* ADDBA request */
+#define IEEE80211_ACTION_BA_ADDBA_RESPONSE      1   /* ADDBA response */
+#define IEEE80211_ACTION_BA_DELBA               2   /* DELBA */
+
+struct ieee80211_ba_parameterset {
+#if _BYTE_ORDER == _BIG_ENDIAN
+        u_int16_t   buffersize      : 10,   /* B6-15  buffer size */
+                    tid             : 4,    /* B2-5   TID */
+                    bapolicy        : 1,    /* B1   block ack policy */
+                    amsdusupported  : 1;    /* B0   amsdu supported */
+#else
+        u_int16_t   amsdusupported  : 1,    /* B0   amsdu supported */
+                    bapolicy        : 1,    /* B1   block ack policy */
+                    tid             : 4,    /* B2-5   TID */
+                    buffersize      : 10;   /* B6-15  buffer size */
+#endif
+} __packed;
+
+#define  IEEE80211_BA_POLICY_DELAYED      0
+#define  IEEE80211_BA_POLICY_IMMEDIATE    1
+#define  IEEE80211_BA_AMSDU_SUPPORTED     1
+
+struct ieee80211_ba_seqctrl {
+#if _BYTE_ORDER == _BIG_ENDIAN
+        u_int16_t   startseqnum     : 12,    /* B4-15  starting sequence number */
+                    fragnum         : 4;     /* B0-3  fragment number */
+#else
+        u_int16_t   fragnum         : 4,     /* B0-3  fragment number */
+                    startseqnum     : 12;    /* B4-15  starting sequence number */
+#endif
+} __packed;
+
+struct ieee80211_delba_parameterset {
+#if _BYTE_ORDER == _BIG_ENDIAN
+        u_int16_t   tid             : 4,     /* B12-15  tid */
+                    initiator       : 1,     /* B11     initiator */
+                    reserved0       : 11;    /* B0-10   reserved */
+#else
+        u_int16_t   reserved0       : 11,    /* B0-10   reserved */
+                    initiator       : 1,     /* B11     initiator */
+                    tid             : 4;     /* B12-15  tid */
+#endif
+} __packed;
+
+/* BA - ADDBA request */
+struct ieee80211_action_ba_addbarequest {
+    struct ieee80211_action             rq_header;
+    u_int8_t                            rq_dialogtoken;
+    struct ieee80211_ba_parameterset    rq_baparamset; 
+    u_int16_t                           rq_batimeout;   /* in TUs */
+    struct ieee80211_ba_seqctrl         rq_basequencectrl;
+} __packed;
+
+/* BA - ADDBA response */
+struct ieee80211_action_ba_addbaresponse {
+    struct ieee80211_action             rs_header;
+    u_int8_t                            rs_dialogtoken;
+    u_int16_t                           rs_statuscode;
+    struct ieee80211_ba_parameterset    rs_baparamset; 
+    u_int16_t                           rs_batimeout;   /* in TUs */
+} __packed;
+
+/* BA - DELBA */
+struct ieee80211_action_ba_delba {
+    struct ieee80211_action                dl_header;
+    struct ieee80211_delba_parameterset    dl_delbaparamset;
+    u_int16_t                              dl_reasoncode;
+} __packed;
+
+/* MGT Notif actions */
+#define IEEE80211_WMM_QOS_ACTION_SETUP_REQ    0
+#define IEEE80211_WMM_QOS_ACTION_SETUP_RESP   1
+#define IEEE80211_WMM_QOS_ACTION_TEARDOWN     2
+
+#define IEEE80211_WMM_QOS_DIALOG_TEARDOWN     0
+#define IEEE80211_WMM_QOS_DIALOG_SETUP        1
+
+#define IEEE80211_WMM_QOS_TSID_DATA_TSPEC     6
+#define IEEE80211_WMM_QOS_TSID_SIG_TSPEC      7
+
+struct ieee80211_action_wmm_qos {
+    struct ieee80211_action             ts_header;
+    u_int8_t                            ts_dialogtoken;
+    u_int8_t                            ts_statuscode;
+    struct ieee80211_wme_tspec          ts_tspecie;
+} __packed;
+
+/*
+ * Control frames.
+ */
+struct ieee80211_frame_min {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+    u_int8_t    i_addr2[IEEE80211_ADDR_LEN];
+    /* FCS */
+} __packed;
+
+/*
+ * BAR frame format
+ */
+#define IEEE80211_BAR_CTL_TID_M     0xF000      /* tid mask             */
+#define IEEE80211_BAR_CTL_TID_S         12      /* tid shift            */
+#define IEEE80211_BAR_CTL_NOACK     0x0001      /* no-ack policy        */
+#define IEEE80211_BAR_CTL_COMBA     0x0004      /* compressed block-ack */
+
+/*
+ * SA Query Action mgmt Frame
+ */
+struct ieee80211_action_sa_query {
+    struct ieee80211_action     sa_header;
+    u_int16_t                   sa_transId;
+};
+
+typedef enum ieee80211_action_sa_query_type{
+    IEEE80211_ACTION_SA_QUERY_REQUEST,
+    IEEE80211_ACTION_SA_QUERY_RESPONSE
+}ieee80211_action_sa_query_type_t;
+
+struct ieee80211_frame_bar {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_ra[IEEE80211_ADDR_LEN];
+    u_int8_t    i_ta[IEEE80211_ADDR_LEN];
+    u_int16_t   i_ctl;
+    u_int16_t   i_seq;
+    /* FCS */
+} __packed;
+
+struct ieee80211_frame_rts {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_ra[IEEE80211_ADDR_LEN];
+    u_int8_t    i_ta[IEEE80211_ADDR_LEN];
+    /* FCS */
+} __packed;
+
+struct ieee80211_frame_cts {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_ra[IEEE80211_ADDR_LEN];
+    /* FCS */
+} __packed;
+
+struct ieee80211_frame_ack {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+    u_int8_t    i_ra[IEEE80211_ADDR_LEN];
+    /* FCS */
+} __packed;
+
+struct ieee80211_frame_pspoll {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_aid[2];
+    u_int8_t    i_bssid[IEEE80211_ADDR_LEN];
+    u_int8_t    i_ta[IEEE80211_ADDR_LEN];
+    /* FCS */
+} __packed;
+
+struct ieee80211_frame_cfend {      /* NB: also CF-End+CF-Ack */
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];   /* should be zero */
+    u_int8_t    i_ra[IEEE80211_ADDR_LEN];
+    u_int8_t    i_bssid[IEEE80211_ADDR_LEN];
+    /* FCS */
+} __packed;
+
+/*
+ * BEACON management packets
+ *
+ *  octet timestamp[8]
+ *  octet beacon interval[2]
+ *  octet capability information[2]
+ *  information element
+ *      octet elemid
+ *      octet length
+ *      octet information[length]
+ */
+
+typedef u_int8_t *ieee80211_mgt_beacon_t;
+
+#define IEEE80211_BEACON_INTERVAL(beacon) \
+    ((beacon)[8] | ((beacon)[9] << 8))
+#define IEEE80211_BEACON_CAPABILITY(beacon) \
+    ((beacon)[10] | ((beacon)[11] << 8))
+
+#define IEEE80211_CAPINFO_ESS               0x0001
+#define IEEE80211_CAPINFO_IBSS              0x0002
+#define IEEE80211_CAPINFO_CF_POLLABLE       0x0004
+#define IEEE80211_CAPINFO_CF_POLLREQ        0x0008
+#define IEEE80211_CAPINFO_PRIVACY           0x0010
+#define IEEE80211_CAPINFO_SHORT_PREAMBLE    0x0020
+#define IEEE80211_CAPINFO_PBCC              0x0040
+#define IEEE80211_CAPINFO_CHNL_AGILITY      0x0080
+#define IEEE80211_CAPINFO_SPECTRUM_MGMT     0x0100
+#define IEEE80211_CAPINFO_QOS               0x0200
+#define IEEE80211_CAPINFO_SHORT_SLOTTIME    0x0400
+#define IEEE80211_CAPINFO_APSD              0x0800
+#define IEEE80211_CAPINFO_RADIOMEAS         0x1000
+#define IEEE80211_CAPINFO_DSSSOFDM          0x2000
+/* bits 14-15 are reserved */
+
+/*
+ * 802.11i/WPA information element (maximally sized).
+ */
+struct ieee80211_ie_wpa {
+    u_int8_t    wpa_id;          /* IEEE80211_ELEMID_VENDOR */
+    u_int8_t    wpa_len;         /* length in bytes */
+    u_int8_t    wpa_oui[3];      /* 0x00, 0x50, 0xf2 */
+    u_int8_t    wpa_type;        /* OUI type */
+    u_int16_t   wpa_version;     /* spec revision */
+    u_int32_t   wpa_mcipher[1];  /* multicast/group key cipher */
+    u_int16_t   wpa_uciphercnt;  /* # pairwise key ciphers */
+    u_int32_t   wpa_uciphers[8]; /* ciphers */
+    u_int16_t   wpa_authselcnt;  /* authentication selector cnt */
+    u_int32_t   wpa_authsels[8]; /* selectors */
+    u_int16_t   wpa_caps;        /* 802.11i capabilities */
+    u_int16_t   wpa_pmkidcnt;    /* 802.11i pmkid count */
+    u_int16_t   wpa_pmkids[8];   /* 802.11i pmkids */
+} __packed;
+
+#ifndef _BYTE_ORDER
+#error "Don't know native byte order"
+#endif
+
+#ifndef IEEE80211N_IE
+/* Temporary vendor specific IE for 11n pre-standard interoperability */
+#define VENDOR_HT_OUI       0x00904c
+#define VENDOR_HT_CAP_ID    51
+#define VENDOR_HT_INFO_ID   52
+#endif
+
+#ifdef ATH_SUPPORT_TxBF
+union ieee80211_hc_txbf {
+    struct {
+#if _BYTE_ORDER == _BIG_ENDIAN
+        u_int32_t   reserved              : 3,
+                channel_estimation_cap    : 2,
+                csi_max_rows_bfer         : 2,
+                comp_bfer_antennas        : 2,
+                noncomp_bfer_antennas     : 2,
+                csi_bfer_antennas         : 2,
+                minimal_grouping          : 2,
+                explicit_comp_bf          : 2,
+                explicit_noncomp_bf       : 2,
+                explicit_csi_feedback     : 2,
+                explicit_comp_steering    : 1,
+                explicit_noncomp_steering : 1,
+                explicit_csi_txbf_capable : 1,
+                calibration               : 2,
+                implicit_txbf_capable     : 1,
+                tx_ndp_capable            : 1,
+                rx_ndp_capable            : 1,
+                tx_staggered_sounding     : 1,
+                rx_staggered_sounding     : 1,
+                implicit_rx_capable       : 1;
+#else
+        u_int32_t   implicit_rx_capable   : 1,
+                rx_staggered_sounding     : 1,
+                tx_staggered_sounding     : 1,
+                rx_ndp_capable            : 1,
+                tx_ndp_capable            : 1,
+                implicit_txbf_capable     : 1,
+                calibration               : 2,
+                explicit_csi_txbf_capable : 1,
+                explicit_noncomp_steering : 1,
+                explicit_comp_steering    : 1,
+                explicit_csi_feedback     : 2,
+                explicit_noncomp_bf       : 2,
+                explicit_comp_bf          : 2,
+                minimal_grouping          : 2,
+                csi_bfer_antennas         : 2,
+                noncomp_bfer_antennas     : 2,
+                comp_bfer_antennas        : 2,
+                csi_max_rows_bfer         : 2,
+                channel_estimation_cap    : 2,
+                reserved                  : 3;
+#endif
+    };
+
+    u_int32_t value;
+} __packed;
+#endif
+
+struct ieee80211_ie_htcap_cmn {
+    u_int16_t   hc_cap;         /* HT capabilities */
+#if _BYTE_ORDER == _BIG_ENDIAN
+    u_int8_t    hc_reserved     : 3,    /* B5-7 reserved */
+                hc_mpdudensity  : 3,    /* B2-4 MPDU density (aka Minimum MPDU Start Spacing) */
+                hc_maxampdu     : 2;    /* B0-1 maximum rx A-MPDU factor */
+#else
+    u_int8_t    hc_maxampdu     : 2,    /* B0-1 maximum rx A-MPDU factor */
+                hc_mpdudensity  : 3,    /* B2-4 MPDU density (aka Minimum MPDU Start Spacing) */
+                hc_reserved     : 3;    /* B5-7 reserved */
+#endif
+    u_int8_t    hc_mcsset[16];          /* supported MCS set */
+    u_int16_t   hc_extcap;              /* extended HT capabilities */
+#ifdef ATH_SUPPORT_TxBF
+    union ieee80211_hc_txbf hc_txbf;    /* txbf capabilities */
+#else
+    u_int32_t   hc_txbf;                /* txbf capabilities */
+#endif
+    u_int8_t    hc_antenna;             /* antenna capabilities */
+} __packed;
+
+/*
+ * 802.11n HT Capability IE
+ */
+struct ieee80211_ie_htcap {
+    u_int8_t                         hc_id;      /* element ID */
+    u_int8_t                         hc_len;     /* length in bytes */
+    struct ieee80211_ie_htcap_cmn    hc_ie;
+} __packed;
+
+/*
+ * Temporary vendor private HT Capability IE
+ */
+struct vendor_ie_htcap {
+    u_int8_t                         hc_id;          /* element ID */
+    u_int8_t                         hc_len;         /* length in bytes */
+    u_int8_t                         hc_oui[3];
+    u_int8_t                         hc_ouitype;
+    struct ieee80211_ie_htcap_cmn    hc_ie;
+} __packed;
+
+/* HT capability flags */
+#define IEEE80211_HTCAP_C_ADVCODING             0x0001
+#define IEEE80211_HTCAP_C_CHWIDTH40             0x0002  
+#define IEEE80211_HTCAP_C_SMPOWERSAVE_STATIC    0x0000 /* Capable of SM Power Save (Static) */
+#define IEEE80211_HTCAP_C_SMPOWERSAVE_DYNAMIC   0x0004 /* Capable of SM Power Save (Dynamic) */
+#define IEEE80211_HTCAP_C_SM_RESERVED           0x0008 /* Reserved */
+#define IEEE80211_HTCAP_C_SM_ENABLED            0x000c /* SM enabled, no SM Power Save */
+#define IEEE80211_HTCAP_C_GREENFIELD            0x0010
+#define IEEE80211_HTCAP_C_SHORTGI20             0x0020
+#define IEEE80211_HTCAP_C_SHORTGI40             0x0040
+#define IEEE80211_HTCAP_C_TXSTBC                0x0080
+#define IEEE80211_HTCAP_C_TXSTBC_S                   7
+#define IEEE80211_HTCAP_C_RXSTBC                0x0300  /* 2 bits */
+#define IEEE80211_HTCAP_C_RXSTBC_S                   8
+#define IEEE80211_HTCAP_C_DELAYEDBLKACK         0x0400
+#define IEEE80211_HTCAP_C_MAXAMSDUSIZE          0x0800  /* 1 = 8K, 0 = 3839B */
+#define IEEE80211_HTCAP_C_DSSSCCK40             0x1000  
+#define IEEE80211_HTCAP_C_PSMP                  0x2000  
+#define IEEE80211_HTCAP_C_INTOLERANT40          0x4000  
+#define IEEE80211_HTCAP_C_LSIGTXOPPROT          0x8000  
+
+#define IEEE80211_HTCAP_C_SM_MASK               0x000c /* Spatial Multiplexing (SM) capabitlity bitmask */
+
+/* ldpc */
+#define IEEE80211_HTCAP_C_LDPC_NONE		0
+#define IEEE80211_HTCAP_C_LDPC_RX		0x1
+#define IEEE80211_HTCAP_C_LDPC_TX		0x2
+#define IEEE80211_HTCAP_C_LDPC_TXRX		0x3
+
+/* B0-1 maximum rx A-MPDU factor 2^(13+Max Rx A-MPDU Factor) */
+enum {
+    IEEE80211_HTCAP_MAXRXAMPDU_8192,    /* 2 ^ 13 */
+    IEEE80211_HTCAP_MAXRXAMPDU_16384,   /* 2 ^ 14 */
+    IEEE80211_HTCAP_MAXRXAMPDU_32768,   /* 2 ^ 15 */
+    IEEE80211_HTCAP_MAXRXAMPDU_65536,   /* 2 ^ 16 */
+};
+#define IEEE80211_HTCAP_MAXRXAMPDU_FACTOR   13
+
+/* B2-4 MPDU density (usec) */
+enum {
+    IEEE80211_HTCAP_MPDUDENSITY_NA,     /* No time restriction */
+    IEEE80211_HTCAP_MPDUDENSITY_0_25,   /* 1/4 usec */
+    IEEE80211_HTCAP_MPDUDENSITY_0_5,    /* 1/2 usec */
+    IEEE80211_HTCAP_MPDUDENSITY_1,      /* 1 usec */
+    IEEE80211_HTCAP_MPDUDENSITY_2,      /* 2 usec */
+    IEEE80211_HTCAP_MPDUDENSITY_4,      /* 4 usec */
+    IEEE80211_HTCAP_MPDUDENSITY_8,      /* 8 usec */
+    IEEE80211_HTCAP_MPDUDENSITY_16,     /* 16 usec */
+};
+
+/* HT extended capability flags */
+#define IEEE80211_HTCAP_EXTC_PCO                0x0001
+#define IEEE80211_HTCAP_EXTC_TRANS_TIME_RSVD    0x0000  
+#define IEEE80211_HTCAP_EXTC_TRANS_TIME_400     0x0002 /* 20-40 switch time */
+#define IEEE80211_HTCAP_EXTC_TRANS_TIME_1500    0x0004 /* in us             */
+#define IEEE80211_HTCAP_EXTC_TRANS_TIME_5000    0x0006 
+#define IEEE80211_HTCAP_EXTC_RSVD_1             0x00f8
+#define IEEE80211_HTCAP_EXTC_MCS_FEEDBACK_NONE  0x0000
+#define IEEE80211_HTCAP_EXTC_MCS_FEEDBACK_RSVD  0x0100
+#define IEEE80211_HTCAP_EXTC_MCS_FEEDBACK_UNSOL 0x0200
+#define IEEE80211_HTCAP_EXTC_MCS_FEEDBACK_FULL  0x0300
+#define IEEE80211_HTCAP_EXTC_RSVD_2             0xfc00
+#ifdef ATH_SUPPORT_TxBF
+#define IEEE80211_HTCAP_EXTC_HTC_SUPPORT        0x0400
+#endif
+
+struct ieee80211_ie_htinfo_cmn {
+    u_int8_t    hi_ctrlchannel;     /* control channel */
+#if _BYTE_ORDER == _BIG_ENDIAN
+    u_int8_t    hi_serviceinterval    : 3,    /* B5-7 svc interval granularity */
+                hi_ctrlaccess         : 1,    /* B4   controlled access only */
+                hi_rifsmode           : 1,    /* B3   rifs mode */
+                hi_txchwidth          : 1,    /* B2   recommended xmiss width set */
+                hi_extchoff           : 2;    /* B0-1 extension channel offset */
+
+
+/* 
+
+ * The following 2 consecutive bytes are defined in word in 80211n spec.
+
+ * Some processors store MSB byte into lower memory address which causes wrong
+
+ * wrong byte sequence in beacon. Thus we break into byte definition which should 
+
+ * avoid the problem for all processors 
+
+ */
+
+    u_int8_t    hi_reserved3          : 3,    /* B5-7 reserved */
+
+                hi_obssnonhtpresent   : 1,    /* B4   OBSS non-HT STA present */
+
+                hi_txburstlimit       : 1,    /* B3   transmit burst limit */
+
+                hi_nongfpresent       : 1,    /* B2   non greenfield devices present */
+
+                hi_opmode             : 2;    /* B0-1 operating mode */
+
+    u_int8_t    hi_reserved0             ;    /* B0-7 (B8-15 in 11n) reserved */
+
+
+
+/* The following 2 consecutive bytes are defined in word in 80211n spec. */
+
+    u_int8_t    hi_dualctsprot        : 1,    /* B7   dual CTS protection */
+                hi_dualbeacon         : 1,    /* B6   dual beacon */
+                hi_reserved2          : 6;    /* B0-5 reserved */
+    u_int8_t    hi_reserved1          : 4,    /* B4-7 (B12-15 in 11n) reserved */
+                hi_pcophase           : 1,    /* B3   (B11 in 11n)  pco phase */
+                hi_pcoactive          : 1,    /* B2   (B10 in 11n)  pco active */
+                hi_lsigtxopprot       : 1,    /* B1   (B9 in 11n)   l-sig txop protection full support */
+                hi_stbcbeacon         : 1;    /* B0   (B8 in 11n)   STBC beacon */
+#else
+    u_int8_t    hi_extchoff           : 2,    /* B0-1 extension channel offset */
+                hi_txchwidth          : 1,    /* B2   recommended xmiss width set */
+                hi_rifsmode           : 1,    /* B3   rifs mode */
+                hi_ctrlaccess         : 1,    /* B4   controlled access only */
+                hi_serviceinterval    : 3;    /* B5-7 svc interval granularity */
+    u_int16_t   hi_opmode             : 2,    /* B0-1 operating mode */
+                hi_nongfpresent       : 1,    /* B2   non greenfield devices present */
+                hi_txburstlimit       : 1,    /* B3   transmit burst limit */
+                hi_obssnonhtpresent   : 1,    /* B4   OBSS non-HT STA present */
+                hi_reserved0          : 11;   /* B5-15 reserved */
+    u_int16_t   hi_reserved2          : 6,    /* B0-5 reserved */
+                hi_dualbeacon         : 1,    /* B6   dual beacon */
+                hi_dualctsprot        : 1,    /* B7   dual CTS protection */
+                hi_stbcbeacon         : 1,    /* B8   STBC beacon */
+                hi_lsigtxopprot       : 1,    /* B9   l-sig txop protection full support */
+                hi_pcoactive          : 1,    /* B10  pco active */
+                hi_pcophase           : 1,    /* B11  pco phase */
+                hi_reserved1          : 4;    /* B12-15 reserved */
+#endif
+    u_int8_t    hi_basicmcsset[16];     /* basic MCS set */
+} __packed;
+
+/*
+ * 802.11n HT Information IE
+ */
+struct ieee80211_ie_htinfo {
+    u_int8_t                        hi_id;          /* element ID */
+    u_int8_t                        hi_len;         /* length in bytes */
+    struct ieee80211_ie_htinfo_cmn  hi_ie;
+} __packed;
+
+/*
+ * Temporary vendor private HT Information IE
+ */
+struct vendor_ie_htinfo {
+    u_int8_t                        hi_id;          /* element ID */
+    u_int8_t                        hi_len;         /* length in bytes */
+    u_int8_t                        hi_oui[3];
+    u_int8_t                        hi_ouitype;
+    struct ieee80211_ie_htinfo_cmn  hi_ie;
+} __packed;
+
+/* extension channel offset (2 bit signed number) */
+enum {
+    IEEE80211_HTINFO_EXTOFFSET_NA    = 0,   /* 0  no extension channel is present */            
+    IEEE80211_HTINFO_EXTOFFSET_ABOVE = 1,   /* +1 extension channel above control channel */ 
+    IEEE80211_HTINFO_EXTOFFSET_UNDEF = 2,   /* -2 undefined */ 
+    IEEE80211_HTINFO_EXTOFFSET_BELOW = 3    /* -1 extension channel below control channel*/
+};
+
+/* recommended transmission width set */
+enum {
+    IEEE80211_HTINFO_TXWIDTH_20,        
+    IEEE80211_HTINFO_TXWIDTH_2040       
+};
+
+/* operating flags */
+#define IEEE80211_HTINFO_OPMODE_PURE                0x00 /* no protection */
+#define IEEE80211_HTINFO_OPMODE_MIXED_PROT_OPT      0x01 /* prot optional (legacy device maybe present) */          
+#define IEEE80211_HTINFO_OPMODE_MIXED_PROT_40       0x02 /* prot required (20 MHz) */   
+#define IEEE80211_HTINFO_OPMODE_MIXED_PROT_ALL      0x03 /* prot required (legacy devices present) */       
+#define IEEE80211_HTINFO_OPMODE_NON_GF_PRESENT      0x04 /* non-greenfield devices present */
+
+#define IEEE80211_HTINFO_OPMODE_MASK                0x03 /* For protection 0x00-0x03 */
+
+/* Non-greenfield STAs present */
+enum {
+    IEEE80211_HTINFO_NON_GF_NOT_PRESENT,    /* Non-greenfield STAs not present */
+    IEEE80211_HTINFO_NON_GF_PRESENT,        /* Non-greenfield STAs present */
+};
+
+/* Transmit Burst Limit */
+enum {
+    IEEE80211_HTINFO_TXBURST_UNLIMITED,     /* Transmit Burst is unlimited */
+    IEEE80211_HTINFO_TXBURST_LIMITED,       /* Transmit Burst is limited */
+};
+
+/* OBSS Non-HT STAs present */
+enum {
+    IEEE80211_HTINFO_OBSS_NONHT_NOT_PRESENT, /* OBSS Non-HT STAs not present */
+    IEEE80211_HTINFO_OBSS_NONHT_PRESENT,     /* OBSS Non-HT STAs present */
+};
+
+/* misc flags */
+#define IEEE80211_HTINFO_DUALBEACON               0x0040 /* B6   dual beacon */
+#define IEEE80211_HTINFO_DUALCTSPROT              0x0080 /* B7   dual stbc protection */
+#define IEEE80211_HTINFO_STBCBEACON               0x0100 /* B8   secondary beacon */
+#define IEEE80211_HTINFO_LSIGTXOPPROT             0x0200 /* B9   lsig txop prot full support */
+#define IEEE80211_HTINFO_PCOACTIVE                0x0400 /* B10  pco active */
+#define IEEE80211_HTINFO_PCOPHASE                 0x0800 /* B11  pco phase */
+
+/* Secondary Channel offset for for 40MHz direct link */
+#define IEEE80211_SECONDARY_CHANNEL_ABOVE         1
+#define IEEE80211_SECONDARY_CHANNEL_BELOW         3
+
+#define IEEE80211_TDLS_CHAN_SX_PROHIBIT         0x00000002 /* bit-2 TDLS Channel Switch Prohibit */
+
+/* RIFS mode */
+enum {
+    IEEE80211_HTINFO_RIFSMODE_PROHIBITED,   /* use of rifs prohibited */
+    IEEE80211_HTINFO_RIFSMODE_ALLOWED,      /* use of rifs permitted */
+};
+
+/*
+ * Management information element payloads.
+ */
+enum {
+    IEEE80211_ELEMID_SSID             = 0,
+    IEEE80211_ELEMID_RATES            = 1,
+    IEEE80211_ELEMID_FHPARMS          = 2,
+    IEEE80211_ELEMID_DSPARMS          = 3,
+    IEEE80211_ELEMID_CFPARMS          = 4,
+    IEEE80211_ELEMID_TIM              = 5,
+    IEEE80211_ELEMID_IBSSPARMS        = 6,
+    IEEE80211_ELEMID_COUNTRY          = 7,
+    IEEE80211_ELEMID_REQINFO          = 10,
+    IEEE80211_ELEMID_QBSS_LOAD        = 11,
+    IEEE80211_ELEMID_TCLAS            = 14,
+    IEEE80211_ELEMID_CHALLENGE        = 16,
+    /* 17-31 reserved for challenge text extension */
+    IEEE80211_ELEMID_PWRCNSTR         = 32,
+    IEEE80211_ELEMID_PWRCAP           = 33,
+    IEEE80211_ELEMID_TPCREQ           = 34,
+    IEEE80211_ELEMID_TPCREP           = 35,
+    IEEE80211_ELEMID_SUPPCHAN         = 36,
+    IEEE80211_ELEMID_CHANSWITCHANN    = 37,
+    IEEE80211_ELEMID_MEASREQ          = 38,
+    IEEE80211_ELEMID_MEASREP          = 39,
+    IEEE80211_ELEMID_QUIET            = 40,
+    IEEE80211_ELEMID_IBSSDFS          = 41,
+    IEEE80211_ELEMID_ERP              = 42,
+    IEEE80211_ELEMID_TCLAS_PROCESS    = 44,
+    IEEE80211_ELEMID_HTCAP_ANA        = 45,
+    IEEE80211_ELEMID_RESERVED_47      = 47,
+    IEEE80211_ELEMID_RSN              = 48,
+    IEEE80211_ELEMID_XRATES           = 50,
+    IEEE80211_ELEMID_HTCAP_VENDOR     = 51,
+    IEEE80211_ELEMID_HTINFO_VENDOR    = 52,
+    IEEE80211_ELEMID_MOBILITY_DOMAIN  = 54,
+    IEEE80211_ELEMID_FT               = 55,
+    IEEE80211_ELEMID_TIMEOUT_INTERVAL = 56,
+    IEEE80211_ELEMID_EXTCHANSWITCHANN = 60,
+    IEEE80211_ELEMID_HTINFO_ANA       = 61,
+    IEEE80211_ELEMID_SECCHANOFFSET    = 62,
+	IEEE80211_ELEMID_WAPI		      = 68,   /*IE for WAPI*/
+    IEEE80211_ELEMID_TIME_ADVERTISEMENT = 69,
+    IEEE80211_ELEMID_RRM              = 70,   /* Radio resource measurement */
+    IEEE80211_ELEMID_2040_COEXT       = 72,
+    IEEE80211_ELEMID_2040_INTOL       = 73,
+    IEEE80211_ELEMID_OBSS_SCAN        = 74,
+    IEEE80211_ELEMID_MMIE             = 76,   /* 802.11w Management MIC IE */
+    IEEE80211_ELEMID_FMS_DESCRIPTOR   = 86,   /* 802.11v FMS descriptor IE */
+    IEEE80211_ELEMID_FMS_REQUEST      = 87,   /* 802.11v FMS request IE */
+    IEEE80211_ELEMID_FMS_RESPONSE     = 88,   /* 802.11v FMS response IE */
+    IEEE80211_ELEMID_BSSMAX_IDLE_PERIOD = 90, /* BSS MAX IDLE PERIOD */ 
+    IEEE80211_ELEMID_TFS_REQUEST      = 91,
+    IEEE80211_ELEMID_TFS_RESPONSE     = 92,
+    IEEE80211_ELEMID_TIM_BCAST_REQUEST  = 94,
+    IEEE80211_ELEMID_TIM_BCAST_RESPONSE = 95,
+    IEEE80211_ELEMID_INTERWORKING     = 107,
+    IEEE80211_ELEMID_XCAPS            = 127,
+    IEEE80211_ELEMID_RESERVED_133     = 133,
+    IEEE80211_ELEMID_TPC              = 150,
+    IEEE80211_ELEMID_CCKM             = 156,
+    IEEE80211_ELEMID_VHTCAP           = 191,  /* VHT Capabilities */
+    IEEE80211_ELEMID_VHTOP            = 192,  /* VHT Operation */
+    IEEE80211_ELEMID_EXT_BSS_LOAD     = 193,  /* Extended BSS Load */
+    IEEE80211_ELEMID_WIDE_BAND_CHAN_SWITCH = 194,  /* Wide Band Channel Switch */
+    IEEE80211_ELEMID_VHT_TX_PWR_ENVLP = 195,  /* VHT Transmit Power Envelope */
+    IEEE80211_ELEMID_CHAN_SWITCH_WRAP = 196,  /* Channel Switch Wrapper */
+    IEEE80211_ELEMID_AID              = 197,  /* AID */
+    IEEE80211_ELEMID_QUIET_CHANNEL    = 198,  /* Quiet Channel */
+    IEEE80211_ELEMID_OP_MODE_NOTIFY   = 199,  /* Operating Mode Notification */
+    IEEE80211_ELEMID_VENDOR           = 221,  /* vendor private */
+};
+
+#define IEEE80211_MAX_IE_LEN                255
+#define IEEE80211_RSN_IE_LEN                22
+
+#define IEEE80211_CHANSWITCHANN_BYTES        5
+#define IEEE80211_CHANSWITCHANN_MODE_QUIET   1
+#define IEEE80211_EXTCHANSWITCHANN_BYTES     6
+
+struct ieee80211_tim_ie {
+    u_int8_t    tim_ie;         /* IEEE80211_ELEMID_TIM */
+    u_int8_t    tim_len;
+    u_int8_t    tim_count;      /* DTIM count */
+    u_int8_t    tim_period;     /* DTIM period */
+    u_int8_t    tim_bitctl;     /* bitmap control */
+    u_int8_t    tim_bitmap[1];  /* variable-length bitmap */
+} __packed;
+
+/* Country IE channel triplet */
+struct country_ie_triplet {
+    union{
+        u_int8_t schan;             /* starting channel */
+        u_int8_t regextid;          /* Regulatory Extension Identifier */
+    };
+    union{
+        u_int8_t nchan;             /* number of channels */
+        u_int8_t regclass;          /* Regulatory Class */
+    };
+    union{
+        u_int8_t maxtxpwr;          /* tx power  */
+        u_int8_t coverageclass;     /* Coverage Class */
+    };
+}__packed;
+
+struct ieee80211_country_ie {
+    u_int8_t    ie;                 /* IEEE80211_ELEMID_COUNTRY */
+    u_int8_t    len;
+    u_int8_t    cc[3];              /* ISO CC+(I)ndoor/(O)utdoor */
+    struct country_ie_triplet triplet[1];
+} __packed;
+
+struct ieee80211_fh_ie {
+    u_int8_t    ie;                 /* IEEE80211_ELEMID_FHPARMS */
+    u_int8_t    len;
+    u_int16_t   dwell_time;    // endianess??
+    u_int8_t    hop_set;
+    u_int8_t    hop_pattern;
+    u_int8_t    hop_index;
+} __packed;
+
+struct ieee80211_ds_ie {
+    u_int8_t    ie;                 /* IEEE80211_ELEMID_DSPARMS */
+    u_int8_t    len;
+    u_int8_t    current_channel;
+} __packed;
+
+struct ieee80211_erp_ie {
+    u_int8_t    ie;                 /* IEEE80211_ELEMID_ERP */
+    u_int8_t    len;
+    u_int8_t    value;
+} __packed;
+
+struct ieee80211_quiet_ie {
+    u_int8_t    ie;                 /* IEEE80211_ELEMID_QUIET */
+    u_int8_t    len;
+    u_int8_t    tbttcount;          /* quiet start */
+    u_int8_t    period;             /* beacon intervals between quiets*/
+    u_int16_t   duration;           /* TUs of each quiet*/
+    u_int16_t   offset;             /* TUs of from TBTT of quiet start*/
+} __packed;
+
+#if ATH_SUPPORT_IBSS_DFS
+struct map_field {
+#if _BYTE_ORDER == _BIG_ENDIAN
+        u_int8_t       reserved:3,
+                       unmeasured:1,
+                       radar:1,
+                       und_signal:1,
+                       ofdem_preamble:1,
+                       bss:1;
+#else 
+        u_int8_t       bss:1,
+                       ofdem_preamble:1,
+                       und_signal:1,
+                       radar:1,
+                       unmeasured:1,
+                       reserved:3;
+#endif 
+}__packed;
+
+#define IEEE80211_MEASUREMENT_REPORT_BASIC_SIZE 12
+struct ieee80211_measurement_report_basic_report {
+    u_int8_t          channel;
+    u_int64_t         measurement_start_time;
+    u_int16_t         measurement_duration;
+    union {
+        struct map_field  map;
+        u_int8_t          chmap_in_byte;
+    };
+}__packed;
+
+struct ieee80211_measurement_report_ie {
+    u_int8_t    ie;                         /* IEEE80211_ELEMID_MEASREP */
+    u_int8_t    len;
+    u_int8_t    measurement_token;
+    u_int8_t    measurement_report_mode;
+    u_int8_t    measurement_type;
+    u_int8_t    pmeasurement_report[IEEE80211_MEASUREMENT_REPORT_BASIC_SIZE];    /* variable, assume basic report */
+}__packed;
+
+struct channel_map_field {
+    u_int8_t            ch_num;             /* channel number*/
+    union {
+        struct map_field  ch_map;
+        u_int8_t          chmap_in_byte;
+    };
+}__packed;
+
+struct ieee80211_ibssdfs_ie {
+    u_int8_t    ie;                 /* IEEE80211_ELEMID_QUIET */
+    u_int8_t    len;
+    u_int8_t    owner[IEEE80211_ADDR_LEN];           /*dfs owner */
+    u_int8_t    rec_interval;       /* dfs_recover_interval*/
+    struct channel_map_field    ch_map_list[IEEE80211_CHAN_MAX+1];    /* channel map filed */ //need to be max
+} __packed;
+#endif /* ATH_SUPPORT_IBSS_DFS */
+
+struct ieee80211_channelswitch_ie {
+    u_int8_t    ie;                 /* IEEE80211_ELEMID_CHANSWITCHANN */
+    u_int8_t    len;
+    u_int8_t    switchmode;
+    u_int8_t    newchannel;
+    u_int8_t    tbttcount;
+} __packed;
+
+/* channel switch action frame format definition */
+struct ieee80211_action_spectrum_channel_switch {
+    struct ieee80211_action             csa_header;
+    struct ieee80211_channelswitch_ie   csa_element;
+}__packed;
+
+struct ieee80211_extendedchannelswitch_ie {
+    u_int8_t    ie;                 /* IEEE80211_ELEMID_EXTCHANSWITCHANN */
+    u_int8_t    len;
+    u_int8_t    switchmode;
+    u_int8_t    newClass;
+    u_int8_t    newchannel;
+    u_int8_t    tbttcount;
+} __packed;
+
+struct ieee80211_tpc_ie {
+    u_int8_t    ie;
+    u_int8_t    len;
+    u_int8_t    pwrlimit;
+} __packed;
+
+/*
+ * MHDRIE included in TKIP MFP protected management frames
+ */
+struct ieee80211_ccx_mhdr_ie {
+    u_int8_t    mhdr_id;
+    u_int8_t    mhdr_len;
+    u_int8_t    mhdr_oui[3];
+    u_int8_t    mhdr_oui_type;
+    u_int8_t    mhdr_fc[2];
+    u_int8_t    mhdr_bssid[6];
+} __packed;
+
+/*
+ * SSID IE
+ */
+struct ieee80211_ie_ssid {
+    u_int8_t    ssid_id;
+    u_int8_t    ssid_len;
+    u_int8_t    ssid[32];
+} __packed;
+
+/* 
+ * Supported rates
+ */
+#define IEEE80211_MAX_SUPPORTED_RATES      8
+
+struct ieee80211_ie_rates {
+    u_int8_t    rate_id;     /* Element Id */
+    u_int8_t    rate_len;    /* IE Length */
+    u_int8_t    rate[IEEE80211_MAX_SUPPORTED_RATES];     /* IE Length */
+} __packed;
+
+/* 
+ * Extended rates
+ */
+#define IEEE80211_MAX_EXTENDED_RATES     256
+
+struct ieee80211_ie_xrates {
+    u_int8_t    xrate_id;     /* Element Id */
+    u_int8_t    xrate_len;    /* IE Length */
+    u_int8_t    xrate[IEEE80211_MAX_EXTENDED_RATES];   /* IE Length */
+} __packed;
+
+/*
+ * WPS SSID list information element (maximally sized).
+ */
+struct ieee80211_ie_ssidl {
+    u_int8_t    ssidl_id;     /* IEEE80211_ELEMID_VENDOR */
+    u_int8_t    ssidl_len;    /* length in bytes */
+    u_int8_t    ssidl_oui[3]; /* 0x00, 0x50, 0xf2 */
+    u_int8_t    ssidl_type;   /* OUI type */
+    u_int8_t    ssidl_prim_cap; /* Primary capabilities */
+    u_int8_t    ssidl_count;  /* # of secondary SSIDs */
+    u_int16_t   ssidl_value[248];
+} __packed;
+
+#if _BYTE_ORDER == _BIG_ENDIAN
+struct ieee80211_sec_ssid_cap {
+    u_int32_t       reserved0   :1,
+                    akmlist     :6,
+                    reserved1   :4,
+                    reeserved2  :2,
+                    ucipher     :15,
+                    mcipher     :4;
+};
+#else
+struct ieee80211_sec_ssid_cap {
+    u_int32_t       mcipher     :4,
+                    ucipher     :15,
+                    reserved2   :2,
+                    reserved1   :4,
+                    akmlist     :6,
+                    reserved0   :1;
+};
+#endif
+
+struct ieee80211_ie_qbssload {
+    u_int8_t     elem_id;                /* IEEE80211_ELEMID_QBSS_LOAD */
+    u_int8_t     length;                 /* length in bytes */
+    u_int16_t    station_count;          /* number of station associated */
+    u_int8_t     channel_utilization;    /* channel busy time in 0-255 scale */
+    u_int16_t    aac;                    /* available admission capacity */
+} __packed;
+
+#define SEC_SSID_HEADER_LEN  6
+#define SSIDL_IE_HEADER_LEN  6
+
+struct ieee80211_sec_ssid {
+    u_int8_t                        sec_ext_cap;
+    struct ieee80211_sec_ssid_cap   sec_cap;
+    u_int8_t                        sec_ssid_len;
+    u_int8_t                        sec_ssid[32];
+} __packed;
+
+/* Definitions of SSIDL IE */
+enum {
+    CAP_MCIPHER_ENUM_NONE = 0,
+    CAP_MCIPHER_ENUM_WEP40,
+    CAP_MCIPHER_ENUM_WEP104,
+    CAP_MCIPHER_ENUM_TKIP,
+    CAP_MCIPHER_ENUM_CCMP,
+    CAP_MCIPHER_ENUM_CKIP_CMIC,
+    CAP_MCIPHER_ENUM_CKIP,
+    CAP_MCIPHER_ENUM_CMIC
+};
+
+
+#define CAP_UCIPHER_BIT_NONE           0x0001
+#define CAP_UCIPHER_BIT_WEP40          0x0002
+#define CAP_UCIPHER_BIT_WEP104         0x0004
+#define CAP_UCIPHER_BIT_TKIP           0x0008
+#define CAP_UCIPHER_BIT_CCMP           0x0010
+#define CAP_UCIPHER_BIT_CKIP_CMIC      0x0020
+#define CAP_UCIPHER_BIT_CKIP           0x0040
+#define CAP_UCIPHER_BIT_CMIC           0x0080
+#define CAP_UCIPHER_BIT_WPA2_WEP40     0x0100
+#define CAP_UCIPHER_BIT_WPA2_WEP104    0x0200
+#define CAP_UCIPHER_BIT_WPA2_TKIP      0x0400
+#define CAP_UCIPHER_BIT_WPA2_CCMP      0x0800
+#define CAP_UCIPHER_BIT_WPA2_CKIP_CMIC 0x1000
+#define CAP_UCIPHER_BIT_WPA2_CKIP      0x2000
+#define CAP_UCIPHER_BIT_WPA2_CMIC      0x4000
+
+#define CAP_AKM_BIT_WPA1_1X            0x01
+#define CAP_AKM_BIT_WPA1_PSK           0x02
+#define CAP_AKM_BIT_WPA2_1X            0x04
+#define CAP_AKM_BIT_WPA2_PSK           0x08
+#define CAP_AKM_BIT_WPA1_CCKM          0x10
+#define CAP_AKM_BIT_WPA2_CCKM          0x20
+
+#define IEEE80211_CHALLENGE_LEN         128
+
+#define IEEE80211_SUPPCHAN_LEN          26
+
+#define IEEE80211_RATE_BASIC            0x80
+#define IEEE80211_RATE_VAL              0x7f
+
+/* EPR information element flags */
+#define IEEE80211_ERP_NON_ERP_PRESENT   0x01
+#define IEEE80211_ERP_USE_PROTECTION    0x02
+#define IEEE80211_ERP_LONG_PREAMBLE     0x04
+
+/* Atheros private advanced capabilities info */
+#define ATHEROS_CAP_TURBO_PRIME         0x01
+#define ATHEROS_CAP_COMPRESSION         0x02
+#define ATHEROS_CAP_FAST_FRAME          0x04
+/* bits 3-6 reserved */
+#define ATHEROS_CAP_BOOST               0x80
+
+#define ATH_OUI                     0x7f0300    /* Atheros OUI */
+#define ATH_OUI_TYPE                    0x01
+#define ATH_OUI_SUBTYPE                 0x01
+#define ATH_OUI_VERSION                 0x00
+#define ATH_OUI_TYPE_XR                 0x03
+#define ATH_OUI_VER_XR                  0x01
+#define ATH_OUI_EXTCAP_TYPE             0x04    /* Atheros Extended Cap Type */
+#define ATH_OUI_EXTCAP_SUBTYPE          0x01    /* Atheros Extended Cap Sub-type */
+#define ATH_OUI_EXTCAP_VERSION          0x00    /* Atheros Extended Cap Version */
+
+#define WPA_OUI                     0xf25000
+#define WPA_OUI_TYPE                    0x01
+#define WPA_VERSION                        1    /* current supported version */
+
+#define AOW_OUI                     0x4a0100    /* AoW OUI, workaround */
+#define AOW_OUI_TYPE                    0x01
+#define AOW_OUI_VERSION                 0x01
+
+#define WSC_OUI                   0x0050f204
+
+#define WPA_CSE_NULL                    0x00
+#define WPA_CSE_WEP40                   0x01
+#define WPA_CSE_TKIP                    0x02
+#define WPA_CSE_CCMP                    0x04
+#define WPA_CSE_WEP104                  0x05
+
+#define WPA_ASE_NONE                    0x00
+#define WPA_ASE_8021X_UNSPEC            0x01
+#define WPA_ASE_8021X_PSK               0x02
+#define WPA_ASE_FT_IEEE8021X            0x20
+#define WPA_ASE_FT_PSK                  0x40
+#define WPA_ASE_SHA256_IEEE8021X        0x80
+#define WPA_ASE_SHA256_PSK              0x100
+#define WPA_ASE_WPS                     0x200
+
+
+#define RSN_OUI                     0xac0f00
+#define RSN_VERSION                        1    /* current supported version */
+
+#define RSN_CSE_NULL                    0x00
+#define RSN_CSE_WEP40                   0x01
+#define RSN_CSE_TKIP                    0x02
+#define RSN_CSE_WRAP                    0x03
+#define RSN_CSE_CCMP                    0x04
+#define RSN_CSE_WEP104                  0x05
+#define RSN_CSE_AES_CMAC                0x06
+
+#define RSN_ASE_NONE                    0x00
+#define RSN_ASE_8021X_UNSPEC            0x01
+#define RSN_ASE_8021X_PSK               0x02
+#define RSN_ASE_FT_IEEE8021X            0x20
+#define RSN_ASE_FT_PSK                  0x40
+#define RSN_ASE_SHA256_IEEE8021X        0x80
+#define RSN_ASE_SHA256_PSK              0x100
+#define RSN_ASE_WPS                     0x200
+
+#define AKM_SUITE_TYPE_IEEE8021X        0x01
+#define AKM_SUITE_TYPE_PSK              0x02
+#define AKM_SUITE_TYPE_FT_IEEE8021X     0x03
+#define AKM_SUITE_TYPE_FT_PSK           0x04
+#define AKM_SUITE_TYPE_SHA256_IEEE8021X 0x05
+#define AKM_SUITE_TYPE_SHA256_PSK       0x06
+
+#define RSN_CAP_PREAUTH                 0x01
+#define RSN_CAP_MFP_REQUIRED            0x40
+#define RSN_CAP_MFP_ENABLED             0x80
+
+#define CCKM_OUI                    0x964000
+#define CCKM_ASE_UNSPEC                    0
+#define WPA_CCKM_AKM              0x00964000
+#define RSN_CCKM_AKM              0x00964000
+
+#define WME_OUI                     0xf25000
+#define WME_OUI_TYPE                    0x02
+#define WME_INFO_OUI_SUBTYPE            0x00
+#define WME_PARAM_OUI_SUBTYPE           0x01
+#define WME_TSPEC_OUI_SUBTYPE           0x02
+
+#define VHT_INTEROP_OUI                 0x00904c
+#define VHT_INTEROP_TYPE                0x04
+#define VHT_INTEROP_OUI_SUBTYPE         0x08
+
+#define WME_PARAM_OUI_VERSION              1
+#define WME_TSPEC_OUI_VERSION              1
+#define WME_VERSION                        1
+
+/* WME stream classes */
+#define WME_AC_BE                          0    /* best effort */
+#define WME_AC_BK                          1    /* background */
+#define WME_AC_VI                          2    /* video */
+#define WME_AC_VO                          3    /* voice */
+
+#define WPS_OUI                     0xf25000    /* Microsoft OUI */
+#define WPS_OUI_TYPE                    0x05    /* Wireless Provisioning Services */
+#define SSIDL_OUI_TYPE          WPS_OUI_TYPE
+
+/* WCN IE */
+#define WCN_OUI                     0xf25000    /* Microsoft OUI */
+#define WCN_OUI_TYPE                    0x04    /* WCN */
+
+/* Atheros htoui  for ht vender ie; use Epigram OUI for compatibility with pre11n devices */
+#define ATH_HTOUI                   0x00904c
+
+#define SFA_OUI                     0x964000
+#define SFA_OUI_TYPE                    0x14
+#define SFA_IE_CAP_MFP                  0x01
+#define SFA_IE_CAP_DIAG_CHANNEL         0x02
+#define SFA_IE_CAP_LOCATION_SVCS        0x04
+#define SFA_IE_CAP_EXP_BANDWIDTH        0x08
+
+#define WPA_OUI_BYTES       0x00, 0x50, 0xf2
+#define RSN_OUI_BYTES       0x00, 0x0f, 0xac
+#define WME_OUI_BYTES       0x00, 0x50, 0xf2
+#define ATH_OUI_BYTES       0x00, 0x03, 0x7f
+#define SFA_OUI_BYTES       0x00, 0x40, 0x96
+#define CCKM_OUI_BYTES      0x00, 0x40, 0x96
+#define WPA_SEL(x)          (((x)<<24)|WPA_OUI)
+#define RSN_SEL(x)          (((x)<<24)|RSN_OUI)
+#define SFA_SEL(x)          (((x)<<24)|SFA_OUI)
+#define CCKM_SEL(x)         (((x)<<24)|CCKM_OUI)
+
+#define IEEE80211_RV(v)     ((v) & IEEE80211_RATE_VAL)
+#define IEEE80211_N(a)      (sizeof(a) / sizeof(a[0]))
+
+/*
+ * AUTH management packets
+ *
+ *  octet algo[2]
+ *  octet seq[2]
+ *  octet status[2]
+ *  octet chal.id
+ *  octet chal.length
+ *  octet chal.text[253]
+ */
+
+typedef u_int8_t *ieee80211_mgt_auth_t;
+
+#define IEEE80211_AUTH_ALGORITHM(auth) \
+    ((auth)[0] | ((auth)[1] << 8))
+#define IEEE80211_AUTH_TRANSACTION(auth) \
+    ((auth)[2] | ((auth)[3] << 8))
+#define IEEE80211_AUTH_STATUS(auth) \
+    ((auth)[4] | ((auth)[5] << 8))
+
+#define IEEE80211_AUTH_ALG_OPEN     0x0000
+#define IEEE80211_AUTH_ALG_SHARED   0x0001
+#define IEEE80211_AUTH_ALG_FT       0x0002
+#define IEEE80211_AUTH_ALG_LEAP     0x0080
+
+enum {
+    IEEE80211_AUTH_OPEN_REQUEST     = 1,
+    IEEE80211_AUTH_OPEN_RESPONSE    = 2,
+};
+
+enum {
+    IEEE80211_AUTH_SHARED_REQUEST   = 1,
+    IEEE80211_AUTH_SHARED_CHALLENGE = 2,
+    IEEE80211_AUTH_SHARED_RESPONSE  = 3,
+    IEEE80211_AUTH_SHARED_PASS      = 4,
+};
+
+/*
+ * Reason codes
+ *
+ * Unlisted codes are reserved
+ */
+
+enum {
+    IEEE80211_REASON_UNSPECIFIED        = 1,
+    IEEE80211_REASON_AUTH_EXPIRE        = 2,
+    IEEE80211_REASON_AUTH_LEAVE         = 3,
+    IEEE80211_REASON_ASSOC_EXPIRE       = 4,
+    IEEE80211_REASON_ASSOC_TOOMANY      = 5,
+    IEEE80211_REASON_NOT_AUTHED         = 6,
+    IEEE80211_REASON_NOT_ASSOCED        = 7,
+    IEEE80211_REASON_ASSOC_LEAVE        = 8,
+    IEEE80211_REASON_ASSOC_NOT_AUTHED   = 9,
+
+    IEEE80211_REASON_RSN_REQUIRED       = 11,
+    IEEE80211_REASON_RSN_INCONSISTENT   = 12,
+    IEEE80211_REASON_IE_INVALID         = 13,
+    IEEE80211_REASON_MIC_FAILURE        = 14,
+
+    IEEE80211_REASON_QOS                = 32,
+    IEEE80211_REASON_QOS_BANDWITDH      = 33,
+    IEEE80211_REASON_QOS_CH_CONDITIONS  = 34,
+    IEEE80211_REASON_QOS_TXOP           = 35,
+    IEEE80211_REASON_QOS_LEAVE          = 36,
+    IEEE80211_REASON_QOS_DECLINED       = 37,
+    IEEE80211_REASON_QOS_SETUP_REQUIRED = 38,
+    IEEE80211_REASON_QOS_TIMEOUT        = 39,
+    IEEE80211_REASON_QOS_CIPHER         = 45,
+
+    IEEE80211_STATUS_SUCCESS            = 0,
+    IEEE80211_STATUS_UNSPECIFIED        = 1,
+    IEEE80211_STATUS_CAPINFO            = 10,
+    IEEE80211_STATUS_NOT_ASSOCED        = 11,
+    IEEE80211_STATUS_OTHER              = 12,
+    IEEE80211_STATUS_ALG                = 13,
+    IEEE80211_STATUS_SEQUENCE           = 14,
+    IEEE80211_STATUS_CHALLENGE          = 15,
+    IEEE80211_STATUS_TIMEOUT            = 16,
+    IEEE80211_STATUS_TOOMANY            = 17,
+    IEEE80211_STATUS_BASIC_RATE         = 18,
+    IEEE80211_STATUS_SP_REQUIRED        = 19,
+    IEEE80211_STATUS_PBCC_REQUIRED      = 20,
+    IEEE80211_STATUS_CA_REQUIRED        = 21,
+    IEEE80211_STATUS_TOO_MANY_STATIONS  = 22,
+    IEEE80211_STATUS_RATES              = 23,
+    IEEE80211_STATUS_SHORTSLOT_REQUIRED = 25,
+    IEEE80211_STATUS_DSSSOFDM_REQUIRED  = 26,
+    IEEE80211_STATUS_NO_HT              = 27,
+    IEEE80211_STATUS_REJECT_TEMP        = 30,
+    IEEE80211_STATUS_MFP_VIOLATION      = 31,
+    IEEE80211_STATUS_REFUSED            = 37,
+    IEEE80211_STATUS_INVALID_PARAM      = 38,
+
+    IEEE80211_STATUS_DLS_NOT_ALLOWED    = 48,
+    IEEE80211_STATUS_NO_VHT             = 104,
+};
+
+/* private IEEE80211_STATUS */
+#define    IEEE80211_STATUS_CANCEL             -1
+#define    IEEE80211_STATUS_INVALID_IE         -2
+#define    IEEE80211_STATUS_INVALID_CHANNEL    -3
+
+#define IEEE80211_WEP_KEYLEN        5   /* 40bit */
+#define IEEE80211_WEP_IVLEN         3   /* 24bit */
+#define IEEE80211_WEP_KIDLEN        1   /* 1 octet */
+#define IEEE80211_WEP_CRCLEN        4   /* CRC-32 */
+#define IEEE80211_WEP_NKID          4   /* number of key ids */
+
+/*
+ * 802.11i defines an extended IV for use with non-WEP ciphers.
+ * When the EXTIV bit is set in the key id byte an additional
+ * 4 bytes immediately follow the IV for TKIP.  For CCMP the
+ * EXTIV bit is likewise set but the 8 bytes represent the
+ * CCMP header rather than IV+extended-IV.
+ */
+#define IEEE80211_WEP_EXTIV      0x20
+#define IEEE80211_WEP_EXTIVLEN      4   /* extended IV length */
+#define IEEE80211_WEP_MICLEN        8   /* trailing MIC */
+
+#define IEEE80211_CRC_LEN           4
+
+#define IEEE80211_8021Q_HEADER_LEN  4
+/*
+ * Maximum acceptable MTU is:
+ *  IEEE80211_MAX_LEN - WEP overhead - CRC -
+ *      QoS overhead - RSN/WPA overhead
+ * Min is arbitrarily chosen > IEEE80211_MIN_LEN.  The default
+ * mtu is Ethernet-compatible; it's set by ether_ifattach.
+ */
+#define IEEE80211_MTU_MAX       2290
+#define IEEE80211_MTU_MIN       32
+
+/* Rather than using this default value, customer platforms can provide a custom value for this constant. 
+  Coustomer platform will use the different define value by themself */
+#ifndef IEEE80211_MAX_MPDU_LEN
+#define IEEE80211_MAX_MPDU_LEN      (3840 + IEEE80211_CRC_LEN + \
+    (IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN))
+#endif
+#define IEEE80211_ACK_LEN \
+    (sizeof(struct ieee80211_frame_ack) + IEEE80211_CRC_LEN)
+#define IEEE80211_MIN_LEN \
+    (sizeof(struct ieee80211_frame_min) + IEEE80211_CRC_LEN)
+
+/* An 802.11 data frame can be one of three types:
+1. An unaggregated frame: The maximum length of an unaggregated data frame is 2324 bytes + headers.
+2. A data frame that is part of an AMPDU: The maximum length of an AMPDU may be upto 65535 bytes, but data frame is limited to 2324 bytes + header.
+3. An AMSDU: The maximum length of an AMSDU is eihther 3839 or 7095 bytes.
+The maximum frame length supported by hardware is 4095 bytes.
+A length of 3839 bytes is chosen here to support unaggregated data frames, any size AMPDUs and 3839 byte AMSDUs.
+*/
+#define IEEE80211N_MAX_FRAMELEN  3839
+#define IEEE80211N_MAX_LEN (IEEE80211N_MAX_FRAMELEN + IEEE80211_CRC_LEN + \
+    (IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN))
+
+#define IEEE80211_TX_CHAINMASK_MIN  1
+#define IEEE80211_TX_CHAINMASK_MAX  7
+
+#define IEEE80211_RX_CHAINMASK_MIN  1
+#define IEEE80211_RX_CHAINMASK_MAX  7
+
+/*
+ * The 802.11 spec says at most 2007 stations may be
+ * associated at once.  For most AP's this is way more
+ * than is feasible so we use a default of 128.  This
+ * number may be overridden by the driver and/or by
+ * user configuration.
+ */
+#define IEEE80211_AID_MAX       2007
+#define IEEE80211_AID_DEF       128
+#define IEEE80211_MAX_AID_DEF   200
+
+#define IEEE80211_AID(b)    ((b) &~ 0xc000)
+
+/* 
+ * RTS frame length parameters.  The default is specified in
+ * the 802.11 spec.  The max may be wrong for jumbo frames.
+ */
+#define IEEE80211_RTS_DEFAULT       512
+#define IEEE80211_RTS_MIN           0
+#define IEEE80211_RTS_MAX           2347
+
+/*
+ * Fragmentation limits
+ */
+#define IEEE80211_FRAGMT_THRESHOLD_MIN        540      /* min frag threshold */
+#define IEEE80211_FRAGMT_THRESHOLD_MAX       2346      /* max frag threshold */
+
+/* 
+ * Regulatory extention identifier for country IE.
+ */
+#define IEEE80211_REG_EXT_ID        201
+
+/*
+ * overlapping BSS
+ */
+#define IEEE80211_OBSS_SCAN_PASSIVE_DWELL_DEF  20
+#define IEEE80211_OBSS_SCAN_ACTIVE_DWELL_DEF   10
+#define IEEE80211_OBSS_SCAN_INTERVAL_DEF       300
+#define IEEE80211_OBSS_SCAN_PASSIVE_TOTAL_DEF  200
+#define IEEE80211_OBSS_SCAN_ACTIVE_TOTAL_DEF   20
+#define IEEE80211_OBSS_SCAN_THRESH_DEF   25
+#define IEEE80211_OBSS_SCAN_DELAY_DEF   5
+
+/*
+ * overlapping BSS scan ie
+ */
+struct ieee80211_ie_obss_scan {
+        u_int8_t elem_id;
+        u_int8_t elem_len;
+        u_int16_t scan_passive_dwell;
+        u_int16_t scan_active_dwell;
+        u_int16_t scan_interval;
+        u_int16_t scan_passive_total;
+        u_int16_t scan_active_total;
+        u_int16_t scan_delay;
+        u_int16_t scan_thresh;
+} __packed;
+
+/*
+ * Extended capability ie
+ */
+struct ieee80211_ie_ext_cap {
+        u_int8_t elem_id;
+        u_int8_t elem_len;
+        u_int32_t ext_capflags;
+        u_int32_t ext_capflags2;
+} __packed;
+
+/* Extended capability IE flags */
+#define IEEE80211_EXTCAPIE_2040COEXTMGMT        0x00000001
+#define IEEE80211_EXTCAPIE_TFS                  0x00010000
+#define IEEE80211_EXTCAPIE_FMS                  0x00000800
+#define IEEE80211_EXTCAPIE_WNMSLEEPMODE         0x00020000
+#define IEEE80211_EXTCAPIE_TIMBROADCAST         0x00040000
+#define IEEE80211_EXTCAPIE_PROXYARP             0x00001000
+#define IEEE80211_EXTCAPIE_BSSTRANSITION        0x00080000
+/* Tunneled Direct Link Setup (TDLS) extended capability bits */
+#define IEEE80211_EXTCAPIE_PEER_UAPSD_BUF_STA   0x10000000
+#define IEEE80211_EXTCAPIE_TDLS_PEER_PSM        0x20000000
+#define IEEE80211_EXTCAPIE_TDLS_CHAN_SX         0x40000000
+/* 2nd Extended capability IE flags bit32-bit63*/
+#define IEEE80211_EXTCAPIE_TDLSSUPPORT      0x00000020 /* bit-37 TDLS Support */
+#define IEEE80211_EXTCAPIE_TDLSPROHIBIT     0x00000040 /* bit-38 TDLS Prohibit Support */
+#define IEEE80211_EXTCAPIE_TDLSCHANSXPROHIBIT   0x00000080 /* bit-39 TDLS Channel Switch Prohibit */
+#define IEEE80211_EXTCAPIE_TDLS_WIDE_BAND   0x20000080 /* bit-61 TDLS Wide Bandwidth support */
+#define IEEE80211_EXTCAPIE_OP_MODE_NOTIFY   0x40000000 /* bit-62 Operating Mode notification */
+
+/* 
+ * These caps are populated when we recieve beacon/probe response
+ * This is used to maintain local TDLS cap bit masks
+ */
+
+#define IEEE80211_TDLS_PROHIBIT     0x00000001 /* bit-1 TDLS Prohibit Support */
+
+/* 
+ * 20/40 BSS coexistence ie
+ */
+struct ieee80211_ie_bss_coex {
+        u_int8_t elem_id;
+        u_int8_t elem_len;
+#if _BYTE_ORDER == _BIG_ENDIAN
+        u_int8_t reserved1          : 1,
+                 reserved2          : 1,
+                 reserved3          : 1,
+                 obss_exempt_grant  : 1,
+                 obss_exempt_req    : 1,
+                 ht20_width_req       : 1,
+                 ht40_intolerant      : 1,
+                 inf_request        : 1;
+#else
+        u_int8_t inf_request        : 1,
+                 ht40_intolerant      : 1,
+                 ht20_width_req       : 1,
+                 obss_exempt_req    : 1,
+                 obss_exempt_grant  : 1,
+                 reserved3          : 1,
+                 reserved2          : 1,
+                 reserved1          : 1;
+#endif
+} __packed;
+
+/*
+ * 20/40 BSS intolerant channel report ie
+ */
+struct ieee80211_ie_intolerant_report {
+        u_int8_t elem_id;
+        u_int8_t elem_len;
+        u_int8_t reg_class;
+        u_int8_t chan_list[1];          /* variable-length channel list */
+} __packed;
+ 
+/*
+ * 20/40 coext management action frame 
+ */
+struct ieee80211_action_bss_coex_frame {
+        struct ieee80211_action                ac_header;
+        struct ieee80211_ie_bss_coex           coex;
+        struct ieee80211_ie_intolerant_report    chan_report;
+} __packed;
+
+typedef enum ieee80211_tie_interval_type{
+    IEEE80211_TIE_INTERVAL_TYPE_RESERVED                  = 0,
+    IEEE80211_TIE_INTERVAL_TYPE_REASSOC_DEADLINE_INTERVAL = 1,
+    IEEE80211_TIE_INTERVAL_TYPE_KEY_LIFETIME_INTERVAL     = 2,
+    IEEE80211_TIE_INTERVAL_TYPE_ASSOC_COMEBACK_TIME       = 3,
+}ieee80211_tie_interval_type_t;
+
+struct ieee80211_ie_timeout_interval {
+        u_int8_t elem_id;
+        u_int8_t elem_len;
+        u_int8_t interval_type;
+        u_int32_t value;
+} __packed;
+
+
+/* Management MIC information element (IEEE 802.11w) */
+struct ieee80211_mmie {
+    u_int8_t element_id;
+    u_int8_t length;
+    u_int16_t key_id;
+    u_int8_t sequence_number[6];
+    u_int8_t mic[8];
+} __packed;
+
+/* VHT capability flags */
+/* B0-B1 Maximum MPDU Length */
+#define IEEE80211_VHTCAP_MAX_MPDU_LEN_3839     0x00000000 /* A-MSDU Length 3839 octets */
+#define IEEE80211_VHTCAP_MAX_MPDU_LEN_7935     0x00000001 /* A-MSDU Length 7991 octets */
+#define IEEE80211_VHTCAP_MAX_MPDU_LEN_11454    0x00000002 /* A-MSDU Length 11454 octets */
+
+/* B2-B3 Supported Channel Width */
+#define IEEE80211_VHTCAP_SUP_CHAN_WIDTH_80     0x00000000 /* Does not support 160 or 80+80 */
+#define IEEE80211_VHTCAP_SUP_CHAN_WIDTH_160    0x00000004 /* Supports 160 */
+#define IEEE80211_VHTCAP_SUP_CHAN_WIDTH_80_160 0x00000008 /* Support both 160 or 80+80 */
+#define IEEE80211_VHTCAP_SUP_CHAN_WIDTH_S      2          /* B2-B3 */
+
+#define IEEE80211_VHTCAP_RX_LDPC             0x00000010 /* B4 RX LDPC */
+#define IEEE80211_VHTCAP_SHORTGI_80          0x00000020 /* B5 Short GI for 80MHz */
+#define IEEE80211_VHTCAP_SHORTGI_160         0x00000040 /* B6 Short GI for 160 and 80+80 MHz */
+#define IEEE80211_VHTCAP_TX_STBC             0x00000080 /* B7 Tx STBC */
+#define IEEE80211_VHTCAP_TX_STBC_S           7
+
+#define IEEE80211_VHTCAP_RX_STBC             0x00000700 /* B8-B10 Rx STBC */
+#define IEEE80211_VHTCAP_RX_STBC_S           8
+
+#define IEEE80211_VHTCAP_SU_BFORMER          0x00000800 /* B11 SU Beam former capable */
+#define IEEE80211_VHTCAP_SU_BFORMEE          0x00001000 /* B12 SU Beam formee capable */
+#define IEEE80211_VHTCAP_BF_MAX_ANT          0x0000E000 /* B13-B15 Compressed steering number of
+                                                         * beacomformer Antennas supported */
+#define IEEE80211_VHTCAP_BF_MAX_ANT_S        13
+
+#define IEEE80211_VHTCAP_SOUND_DIMENSIONS    0x00070000 /* B16-B18 Sounding Dimensions */
+#define IEEE80211_VHTCAP_SOUND_DIMENSIONS_S  16
+
+#define IEEE80211_VHTCAP_MU_BFORMER          0x00080000 /* B19 MU Beam Former */
+#define IEEE80211_VHTCAP_MU_BFORMEE          0x00100000 /* B20 MU Beam Formee */
+#define IEEE80211_VHTCAP_TXOP_PS             0x00200000 /* B21 VHT TXOP PS */
+#define IEEE80211_VHTCAP_PLUS_HTC_VHT        0x00400000 /* B22 +HTC-VHT capable */
+
+#define IEEE80211_VHTCAP_MAX_AMPDU_LEN_FACTOR  13
+#define IEEE80211_VHTCAP_MAX_AMPDU_LEN_EXP   0x03800000 /* B23-B25 maximum AMPDU Length Exponent */
+#define IEEE80211_VHTCAP_MAX_AMPDU_LEN_EXP_S 23
+
+#define IEEE80211_VHTCAP_LINK_ADAPT          0x0C000000 /* B26-B27 VHT Link Adaptation capable */
+#define IEEE80211_VHTCAP_RESERVED            0xF0000000 /* B28-B31 Reserved */
+
+/*
+ * 802.11ac VHT Capability IE
+ */
+struct ieee80211_ie_vhtcap {
+        u_int8_t    elem_id;
+        u_int8_t    elem_len;
+        u_int32_t   vht_cap_info;
+        u_int16_t   rx_mcs_map;          /* B0-B15 Max Rx MCS for each SS */
+        u_int16_t   rx_high_data_rate;   /* B16-B28 Max Rx data rate,
+                                            Note:  B29-B31 reserved */
+        u_int16_t   tx_mcs_map;          /* B32-B47 Max Tx MCS for each SS */
+        u_int16_t   tx_high_data_rate;   /* B48-B60 Max Tx data rate,
+                                            Note: B61-B63 reserved */
+} __packed;
+
+
+/* VHT Operation  */
+#define IEEE80211_VHTOP_CHWIDTH_2040      0 /* 20/40 MHz Operating Channel */
+#define IEEE80211_VHTOP_CHWIDTH_80        1 /* 80 MHz Operating Channel */
+#define IEEE80211_VHTOP_CHWIDTH_160       2 /* 160 MHz Operating Channel */
+#define IEEE80211_VHTOP_CHWIDTH_80_80     3 /* 80 + 80 MHz Operating Channel */
+
+/*
+ * 802.11ac VHT Operation IE
+ */
+struct ieee80211_ie_vhtop {
+        u_int8_t    elem_id;
+        u_int8_t    elem_len;
+        u_int8_t    vht_op_chwidth;              /* BSS Operational Channel width */
+        u_int8_t    vht_op_ch_freq_seg1;         /* Channel Center frequency */
+        u_int8_t    vht_op_ch_freq_seg2;         /* Channel Center frequency applicable
+                                                  * for 80+80MHz mode of operation */ 
+        u_int16_t   vhtop_basic_mcs_set;         /* Basic MCS set */
+} __packed;
+
+
+/*
+ * 802.11ng vendor specific VHT Interop Capability 
+ * with Vht cap & Vht op IE
+ */
+struct ieee80211_ie_interop_vhtcap {
+        u_int8_t    elem_id;
+        u_int8_t    elem_len;
+        u_int32_t   vht_interop_oui;
+        u_int8_t    sub_type;
+        struct ieee80211_ie_vhtcap  vhtcapie;
+        struct ieee80211_ie_vhtop   vhtopie;
+} __packed;
+
+
+/*
+ * 802.11n Secondary Channel Offset element
+ */
+#define IEEE80211_SEC_CHAN_OFFSET_SCN               0 /* no secondary channel */
+#define IEEE80211_SEC_CHAN_OFFSET_SCA               1 /* secondary channel above */
+#define IEEE80211_SEC_CHAN_OFFSET_SCB               3 /* secondary channel below */
+
+struct ieee80211_ie_sec_chan_offset {
+     u_int8_t    elem_id;
+     u_int8_t    len;
+     u_int8_t    sec_chan_offset;
+} __packed;
+
+/*
+ * 802.11ac Transmit Power Envelope element
+ */
+#define IEEE80211_VHT_TXPWR_IS_SUB_ELEMENT          1  /* It checks whether its  sub element */
+#define IEEE80211_VHT_TXPWR_MAX_POWER_COUNT         4 /* Max TX power elements valid */
+#define IEEE80211_VHT_TXPWR_NUM_POWER_SUPPORTED     3 /* Max TX power elements supported */
+#define IEEE80211_VHT_TXPWR_LCL_MAX_PWR_UNITS_SHFT  3 /* B3-B5 Local Max transmit power units */ 
+
+struct ieee80211_ie_vht_txpwr_env {
+        u_int8_t    elem_id;
+        u_int8_t    elem_len;
+        u_int8_t    txpwr_info;       /* Transmit Power Information */
+        u_int8_t    local_max_txpwr[4]; /* Local Max TxPower for 20,40,80,160MHz */
+} __packed;
+
+/*
+ * 802.11ac Wide Bandwidth Channel Switch Element
+ */
+
+#define IEEE80211_VHT_EXTCH_SWITCH             1  /* For extension channel switch */
+#define CHWIDTH_VHT20                          20  /* Channel width 20 */
+#define CHWIDTH_VHT40                          40  /* Channel width 40 */
+#define CHWIDTH_VHT80                          80  /* Channel width 80 */
+#define CHWIDTH_VHT160                         160  /* Channel width 160 */
+
+struct ieee80211_ie_wide_bw_switch {
+        u_int8_t    elem_id;
+        u_int8_t    elem_len;
+        u_int8_t    new_ch_width;       /* New channel width */
+        u_int8_t    new_ch_freq_seg1;   /* Channel Center frequency 1 */
+        u_int8_t    new_ch_freq_seg2;   /* Channel Center frequency 2 */ 
+} __packed;
+
+#define IEEE80211_RSSI_RX       0x00000001
+#define IEEE80211_RSSI_TX       0x00000002
+#define IEEE80211_RSSI_EXTCHAN  0x00000004
+#define IEEE80211_RSSI_BEACON   0x00000008
+#define IEEE80211_RSSI_RXDATA   0x00000010
+
+#define IEEE80211_RATE_TX 0
+#define IEEE80211_RATE_RX 1
+#define IEEE80211_LASTRATE_TX 2
+#define IEEE80211_LASTRATE_RX 3
+#define IEEE80211_RATECODE_TX 4
+#define IEEE80211_RATECODE_RX 5
+
+#define IEEE80211_MAX_RATE_PER_CLIENT 8
+/* Define for the P2P Wildcard SSID */
+#if MAV_P2P_OUI
+#define IEEE80211_P2P_WILDCARD_SSID         "Air-"
+#else
+#define IEEE80211_P2P_WILDCARD_SSID         "DIRECT-"
+#endif
+
+#define IEEE80211_P2P_WILDCARD_SSID_LEN     (sizeof(IEEE80211_P2P_WILDCARD_SSID) - 1)
+
+#ifdef WIN32
+#include <poppack.h>
+#endif
+
+#endif /* _NET80211_IEEE80211_H_ */
diff -Naur hostapd-2.9/src/drivers/ieee80211_ioctl.h hostapd-2.9-new/src/drivers/ieee80211_ioctl.h
--- hostapd-2.9/src/drivers/ieee80211_ioctl.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ieee80211_ioctl.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,1793 @@
+/*
+ * Copyright (c) 2010, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * Copyright (c) 2013-2014 Qualcomm Atheros, Inc.
+ * All Rights Reserved.
+ * Qualcomm Atheros Confidential and Proprietary.
+ */
+
+#ifndef _NET80211_IEEE80211_IOCTL_H_
+#define _NET80211_IEEE80211_IOCTL_H_
+
+/*
+ * IEEE 802.11 ioctls.
+ */
+#ifndef EXTERNAL_USE_ONLY
+#include <_ieee80211.h>
+/* duplicate defination - to avoid including ieee80211_var.h */
+#ifndef __ubicom32__
+#define IEEE80211_ADDR_COPY(dst,src)    OS_MEMCPY(dst, src, IEEE80211_ADDR_LEN)
+#else
+#define IEEE80211_ADDR_COPY(dst,src)    OS_MACCPY(dst, src)
+#endif
+#define IEEE80211_KEY_XMIT      0x01    /* key used for xmit */
+#define IEEE80211_KEY_RECV      0x02    /* key used for recv */
+#ifndef __ubicom32__
+#define IEEE80211_ADDR_EQ(a1,a2)        (OS_MEMCMP(a1, a2, IEEE80211_ADDR_LEN) == 0)
+#else
+#define IEEE80211_ADDR_EQ(a1,a2)        (OS_MACCMP(a1, a2) == 0)
+#endif
+#define IEEE80211_APPIE_MAX                  1024 /* max appie buffer size */
+#define IEEE80211_KEY_GROUP     0x04    /* key used for WPA group operation */
+#define IEEE80211_SCAN_MAX_SSID     10
+#define IEEE80211_CHANINFO_MAX           1000 /* max Chaninfo buffer size */
+#endif /* EXTERNAL_USE_ONLY */
+
+ /*
+  * Macros used for Tr069 objects
+  */
+#define TR069MAXPOWERRANGE 30
+#define TR69MINTXPOWER 1
+#define TR69MAX_RATE_POWER 63
+#define TR69SCANSTATEVARIABLESIZE 20
+
+#if 0
+/*
+ * Per/node (station) statistics available when operating as an AP.
+ */
+struct ieee80211_nodestats {
+	u_int32_t	ns_rx_data;		/* rx data frames */
+	u_int32_t	ns_rx_mgmt;		/* rx management frames */
+	u_int32_t	ns_rx_ctrl;		/* rx control frames */
+	u_int32_t	ns_rx_ucast;		/* rx unicast frames */
+	u_int32_t	ns_rx_mcast;		/* rx multi/broadcast frames */
+	u_int64_t	ns_rx_bytes;		/* rx data count (bytes) */
+	u_int64_t	ns_rx_beacons;		/* rx beacon frames */
+	u_int32_t	ns_rx_proberesp;	/* rx probe response frames */
+
+	u_int32_t	ns_rx_dup;		/* rx discard 'cuz dup */
+	u_int32_t	ns_rx_noprivacy;	/* rx w/ wep but privacy off */
+	u_int32_t	ns_rx_wepfail;		/* rx wep processing failed */
+	u_int32_t	ns_rx_demicfail;	/* rx demic failed */
+	u_int32_t	ns_rx_decap;		/* rx decapsulation failed */
+	u_int32_t	ns_rx_defrag;		/* rx defragmentation failed */
+	u_int32_t	ns_rx_disassoc;		/* rx disassociation */
+	u_int32_t	ns_rx_deauth;		/* rx deauthentication */
+    u_int32_t   ns_rx_action;       /* rx action */
+	u_int32_t	ns_rx_decryptcrc;	/* rx decrypt failed on crc */
+	u_int32_t	ns_rx_unauth;		/* rx on unauthorized port */
+	u_int32_t	ns_rx_unencrypted;	/* rx unecrypted w/ privacy */
+
+	u_int32_t	ns_tx_data;		/* tx data frames */
+	u_int32_t	ns_tx_mgmt;		/* tx management frames */
+	u_int32_t	ns_tx_ucast;		/* tx unicast frames */
+	u_int32_t	ns_tx_mcast;		/* tx multi/broadcast frames */
+	u_int64_t	ns_tx_bytes;		/* tx data count (bytes) */
+	u_int32_t	ns_tx_probereq;		/* tx probe request frames */
+	u_int32_t	ns_tx_uapsd;		/* tx on uapsd queue */
+
+	u_int32_t	ns_tx_novlantag;	/* tx discard 'cuz no tag */
+	u_int32_t	ns_tx_vlanmismatch;	/* tx discard 'cuz bad tag */
+#ifdef ATH_SUPPORT_IQUE
+	u_int32_t	ns_tx_dropblock;	/* tx discard 'cuz headline block */
+#endif
+
+	u_int32_t	ns_tx_eosplost;		/* uapsd EOSP retried out */
+
+	u_int32_t	ns_ps_discard;		/* ps discard 'cuz of age */
+
+	u_int32_t	ns_uapsd_triggers;	     /* uapsd triggers */
+	u_int32_t	ns_uapsd_duptriggers;	 /* uapsd duplicate triggers */
+	u_int32_t	ns_uapsd_ignoretriggers; /* uapsd duplicate triggers */
+	u_int32_t	ns_uapsd_active;         /* uapsd duplicate triggers */
+	u_int32_t	ns_uapsd_triggerenabled; /* uapsd duplicate triggers */
+
+	/* MIB-related state */
+	u_int32_t	ns_tx_assoc;		/* [re]associations */
+	u_int32_t	ns_tx_assoc_fail;	/* [re]association failures */
+	u_int32_t	ns_tx_auth;		/* [re]authentications */
+	u_int32_t	ns_tx_auth_fail;	/* [re]authentication failures*/
+	u_int32_t	ns_tx_deauth;		/* deauthentications */
+	u_int32_t	ns_tx_deauth_code;	/* last deauth reason */
+	u_int32_t	ns_tx_disassoc;		/* disassociations */
+	u_int32_t	ns_tx_disassoc_code;	/* last disassociation reason */
+	u_int32_t	ns_psq_drops;		/* power save queue drops */
+};
+
+/*
+ * Summary statistics.
+ */
+struct ieee80211_stats {
+	u_int32_t	is_rx_badversion;	/* rx frame with bad version */
+	u_int32_t	is_rx_tooshort;		/* rx frame too short */
+	u_int32_t	is_rx_wrongbss;		/* rx from wrong bssid */
+	u_int32_t	is_rx_dup;		/* rx discard 'cuz dup */
+	u_int32_t	is_rx_wrongdir;		/* rx w/ wrong direction */
+	u_int32_t	is_rx_mcastecho;	/* rx discard 'cuz mcast echo */
+	u_int32_t	is_rx_notassoc;		/* rx discard 'cuz sta !assoc */
+	u_int32_t	is_rx_noprivacy;	/* rx w/ wep but privacy off */
+	u_int32_t	is_rx_unencrypted;	/* rx w/o wep and privacy on */
+	u_int32_t	is_rx_wepfail;		/* rx wep processing failed */
+	u_int32_t	is_rx_decap;		/* rx decapsulation failed */
+	u_int32_t	is_rx_mgtdiscard;	/* rx discard mgt frames */
+	u_int32_t	is_rx_ctl;		/* rx discard ctrl frames */
+	u_int32_t	is_rx_beacon;		/* rx beacon frames */
+	u_int32_t	is_rx_rstoobig;		/* rx rate set truncated */
+	u_int32_t	is_rx_elem_missing;	/* rx required element missing*/
+	u_int32_t	is_rx_elem_toobig;	/* rx element too big */
+	u_int32_t	is_rx_elem_toosmall;	/* rx element too small */
+	u_int32_t	is_rx_elem_unknown;	/* rx element unknown */
+	u_int32_t	is_rx_badchan;		/* rx frame w/ invalid chan */
+	u_int32_t	is_rx_chanmismatch;	/* rx frame chan mismatch */
+	u_int32_t	is_rx_nodealloc;	/* rx frame dropped */
+	u_int32_t	is_rx_ssidmismatch;	/* rx frame ssid mismatch  */
+	u_int32_t	is_rx_auth_unsupported;	/* rx w/ unsupported auth alg */
+	u_int32_t	is_rx_auth_fail;	/* rx sta auth failure */
+	u_int32_t	is_rx_auth_countermeasures;/* rx auth discard 'cuz CM */
+	u_int32_t	is_rx_assoc_bss;	/* rx assoc from wrong bssid */
+	u_int32_t	is_rx_assoc_notauth;	/* rx assoc w/o auth */
+	u_int32_t	is_rx_assoc_capmismatch;/* rx assoc w/ cap mismatch */
+	u_int32_t	is_rx_assoc_norate;	/* rx assoc w/ no rate match */
+	u_int32_t	is_rx_assoc_badwpaie;	/* rx assoc w/ bad WPA IE */
+	u_int32_t	is_rx_deauth;		/* rx deauthentication */
+	u_int32_t	is_rx_disassoc;		/* rx disassociation */
+    u_int32_t   is_rx_action;       /* rx action mgt */
+	u_int32_t	is_rx_badsubtype;	/* rx frame w/ unknown subtype*/
+	u_int32_t	is_rx_nobuf;		/* rx failed for lack of buf */
+	u_int32_t	is_rx_decryptcrc;	/* rx decrypt failed on crc */
+	u_int32_t	is_rx_ahdemo_mgt;	/* rx discard ahdemo mgt frame*/
+	u_int32_t	is_rx_bad_auth;		/* rx bad auth request */
+	u_int32_t	is_rx_unauth;		/* rx on unauthorized port */
+	u_int32_t	is_rx_badkeyid;		/* rx w/ incorrect keyid */
+	u_int32_t	is_rx_ccmpreplay;	/* rx seq# violation (CCMP) */
+	u_int32_t	is_rx_ccmpformat;	/* rx format bad (CCMP) */
+	u_int32_t	is_rx_ccmpmic;		/* rx MIC check failed (CCMP) */
+	u_int32_t	is_rx_tkipreplay;	/* rx seq# violation (TKIP) */
+	u_int32_t	is_rx_tkipformat;	/* rx format bad (TKIP) */
+	u_int32_t	is_rx_tkipmic;		/* rx MIC check failed (TKIP) */
+	u_int32_t	is_rx_tkipicv;		/* rx ICV check failed (TKIP) */
+	u_int32_t	is_rx_badcipher;	/* rx failed 'cuz key type */
+	u_int32_t	is_rx_nocipherctx;	/* rx failed 'cuz key !setup */
+	u_int32_t	is_rx_acl;		/* rx discard 'cuz acl policy */
+	u_int32_t	is_rx_ffcnt;		/* rx fast frames */
+	u_int32_t	is_rx_badathtnl;   	/* driver key alloc failed */
+	u_int32_t	is_tx_nobuf;		/* tx failed for lack of buf */
+	u_int32_t	is_tx_nonode;		/* tx failed for no node */
+	u_int32_t	is_tx_unknownmgt;	/* tx of unknown mgt frame */
+	u_int32_t	is_tx_badcipher;	/* tx failed 'cuz key type */
+	u_int32_t	is_tx_nodefkey;		/* tx failed 'cuz no defkey */
+	u_int32_t	is_tx_noheadroom;	/* tx failed 'cuz no space */
+	u_int32_t	is_tx_ffokcnt;		/* tx fast frames sent success */
+	u_int32_t	is_tx_fferrcnt;		/* tx fast frames sent success */
+	u_int32_t	is_scan_active;		/* active scans started */
+	u_int32_t	is_scan_passive;	/* passive scans started */
+	u_int32_t	is_node_timeout;	/* nodes timed out inactivity */
+	u_int32_t	is_crypto_nomem;	/* no memory for crypto ctx */
+	u_int32_t	is_crypto_tkip;		/* tkip crypto done in s/w */
+	u_int32_t	is_crypto_tkipenmic;	/* tkip en-MIC done in s/w */
+	u_int32_t	is_crypto_tkipdemic;	/* tkip de-MIC done in s/w */
+	u_int32_t	is_crypto_tkipcm;	/* tkip counter measures */
+	u_int32_t	is_crypto_ccmp;		/* ccmp crypto done in s/w */
+	u_int32_t	is_crypto_wep;		/* wep crypto done in s/w */
+	u_int32_t	is_crypto_setkey_cipher;/* cipher rejected key */
+	u_int32_t	is_crypto_setkey_nokey;	/* no key index for setkey */
+	u_int32_t	is_crypto_delkey;	/* driver key delete failed */
+	u_int32_t	is_crypto_badcipher;	/* unknown cipher */
+	u_int32_t	is_crypto_nocipher;	/* cipher not available */
+	u_int32_t	is_crypto_attachfail;	/* cipher attach failed */
+	u_int32_t	is_crypto_swfallback;	/* cipher fallback to s/w */
+	u_int32_t	is_crypto_keyfail;	/* driver key alloc failed */
+	u_int32_t	is_crypto_enmicfail;	/* en-MIC failed */
+	u_int32_t	is_ibss_capmismatch;	/* merge failed-cap mismatch */
+	u_int32_t	is_ibss_norate;		/* merge failed-rate mismatch */
+	u_int32_t	is_ps_unassoc;		/* ps-poll for unassoc. sta */
+	u_int32_t	is_ps_badaid;		/* ps-poll w/ incorrect aid */
+	u_int32_t	is_ps_qempty;		/* ps-poll w/ nothing to send */
+};
+#endif
+
+/*
+ * Max size of optional information elements.  We artificially
+ * constrain this; it's limited only by the max frame size (and
+ * the max parameter size of the wireless extensions).
+ */
+#define	IEEE80211_MAX_OPT_IE	512
+#define	IEEE80211_MAX_WSC_IE	256
+
+/*
+ * WPA/RSN get/set key request.  Specify the key/cipher
+ * type and whether the key is to be used for sending and/or
+ * receiving.  The key index should be set only when working
+ * with global keys (use IEEE80211_KEYIX_NONE for ``no index'').
+ * Otherwise a unicast/pairwise key is specified by the bssid
+ * (on a station) or mac address (on an ap).  They key length
+ * must include any MIC key data; otherwise it should be no
+ more than IEEE80211_KEYBUF_SIZE.
+ */
+struct ieee80211req_key {
+	u_int8_t	ik_type;	/* key/cipher type */
+	u_int8_t	ik_pad;
+	u_int16_t	ik_keyix;	/* key index */
+	u_int8_t	ik_keylen;	/* key length in bytes */
+	u_int8_t	ik_flags;
+/* NB: IEEE80211_KEY_XMIT and IEEE80211_KEY_RECV defined elsewhere */
+#define	IEEE80211_KEY_DEFAULT	0x80	/* default xmit key */
+	u_int8_t	ik_macaddr[IEEE80211_ADDR_LEN];
+	u_int64_t	ik_keyrsc;	/* key receive sequence counter */
+	u_int64_t	ik_keytsc;	/* key transmit sequence counter */
+	u_int8_t	ik_keydata[IEEE80211_KEYBUF_SIZE+IEEE80211_MICBUF_SIZE];
+};
+
+/*
+ * Delete a key either by index or address.  Set the index
+ * to IEEE80211_KEYIX_NONE when deleting a unicast key.
+ */
+struct ieee80211req_del_key {
+	u_int8_t	idk_keyix;	/* key index */
+	u_int8_t	idk_macaddr[IEEE80211_ADDR_LEN];
+};
+
+/*
+ * MLME state manipulation request.  IEEE80211_MLME_ASSOC
+ * only makes sense when operating as a station.  The other
+ * requests can be used when operating as a station or an
+ * ap (to effect a station).
+ */
+struct ieee80211req_mlme {
+	u_int8_t	im_op;		/* operation to perform */
+#define	IEEE80211_MLME_ASSOC		1	/* associate station */
+#define	IEEE80211_MLME_DISASSOC		2	/* disassociate station */
+#define	IEEE80211_MLME_DEAUTH		3	/* deauthenticate station */
+#define	IEEE80211_MLME_AUTHORIZE	4	/* authorize station */
+#define	IEEE80211_MLME_UNAUTHORIZE	5	/* unauthorize station */
+#define	IEEE80211_MLME_STOP_BSS		6	/* stop bss */
+#define IEEE80211_MLME_CLEAR_STATS	7	/* clear station statistic */
+#define IEEE80211_MLME_AUTH	        8	/* auth resp to station */
+#define IEEE80211_MLME_REASSOC	        9	/* reassoc to station */
+	u_int8_t	im_ssid_len;	/* length of optional ssid */
+	u_int16_t	im_reason;	/* 802.11 reason code */
+	u_int16_t	im_seq;	        /* seq for auth */
+	u_int8_t	im_macaddr[IEEE80211_ADDR_LEN];
+	u_int8_t	im_ssid[IEEE80211_NWID_LEN];
+	u_int8_t        im_optie[IEEE80211_MAX_OPT_IE];
+	u_int16_t       im_optie_len;
+};
+
+/*
+ * request to add traffic stream for an associated station.
+ */
+struct ieee80211req_ts {
+	u_int8_t    macaddr[IEEE80211_ADDR_LEN];
+	u_int8_t    tspec_ie[IEEE80211_MAX_OPT_IE];
+	u_int8_t    tspec_ielen;
+	u_int8_t    res;
+};
+
+/*
+ * Net802.11 scan request
+ *
+ */
+enum {
+    IEEE80211_SCANREQ_BG        = 1,    /*start the bg scan if vap is connected else fg scan */
+    IEEE80211_SCANREQ_FORCE    = 2,    /*start the fg scan */
+    IEEE80211_SCANREQ_STOP        = 3,    /*cancel any ongoing scanning*/
+    IEEE80211_SCANREQ_PAUSE      = 4,    /*pause any ongoing scanning*/
+    IEEE80211_SCANREQ_RESUME     = 5,    /*resume any ongoing scanning*/
+};
+
+/*
+ * Set the active channel list.  Note this list is
+ * intersected with the available channel list in
+ * calculating the set of channels actually used in
+ * scanning.
+ */
+struct ieee80211req_chanlist {
+	u_int8_t	ic_channels[IEEE80211_CHAN_BYTES];
+};
+
+/*
+ * Get the active channel list info.
+ */
+struct ieee80211req_chaninfo {
+	u_int	ic_nchans;
+	struct ieee80211_channel ic_chans[IEEE80211_CHAN_MAX];
+};
+
+/*
+* Ressource request type from app
+*/
+enum {
+    IEEE80211_RESREQ_ADDTS = 0,
+    IEEE80211_RESREQ_ADDNODE,
+};
+/*
+ * Resource request for adding Traffic stream
+ */
+struct ieee80211req_res_addts {
+	u_int8_t	tspecie[IEEE80211_MAX_OPT_IE];
+	u_int8_t	status;
+};
+/*
+ * Resource request for adding station node
+ */
+struct ieee80211req_res_addnode {
+	u_int8_t	auth_alg;
+};
+/*
+ * Resource request from app
+ */
+struct ieee80211req_res {
+	u_int8_t	macaddr[IEEE80211_ADDR_LEN];
+	u_int8_t	type;
+        union {
+            struct ieee80211req_res_addts addts;
+            struct ieee80211req_res_addnode addnode;
+        } u;
+};
+
+/*
+ * Retrieve the WPA/RSN information element for an associated station.
+ */
+struct ieee80211req_wpaie {
+	u_int8_t	wpa_macaddr[IEEE80211_ADDR_LEN];
+	u_int8_t	wpa_ie[IEEE80211_MAX_OPT_IE];
+	u_int8_t    rsn_ie[IEEE80211_MAX_OPT_IE];
+#ifdef ATH_WPS_IE
+	u_int8_t    wps_ie[IEEE80211_MAX_OPT_IE];
+#endif /* ATH_WPS_IE */
+};
+
+/*
+ * Retrieve the WSC information element for an associated station.
+ */
+struct ieee80211req_wscie {
+	u_int8_t	wsc_macaddr[IEEE80211_ADDR_LEN];
+	u_int8_t	wsc_ie[IEEE80211_MAX_WSC_IE];
+};
+
+
+/*
+ * Retrieve per-node statistics.
+ */
+struct ieee80211req_sta_stats {
+	union {
+		/* NB: explicitly force 64-bit alignment */
+		u_int8_t	macaddr[IEEE80211_ADDR_LEN];
+		u_int64_t	pad;
+	} is_u;
+	struct ieee80211_nodestats is_stats;
+};
+
+/*
+ * Station information block; the mac address is used
+ * to retrieve other data like stats, unicast key, etc.
+ */
+struct ieee80211req_sta_info {
+	u_int16_t	isi_len;		/* length (mult of 4) */
+	u_int16_t	isi_freq;		/* MHz */
+    u_int32_t   isi_flags;      /* channel flags */
+	u_int16_t	isi_state;		/* state flags */
+	u_int8_t	isi_authmode;		/* authentication algorithm */
+	int8_t	    	isi_rssi;
+	u_int16_t	isi_capinfo;		/* capabilities */
+	u_int8_t	isi_athflags;		/* Atheros capabilities */
+	u_int8_t	isi_erp;		/* ERP element */
+	u_int8_t	isi_ps;	    	/* psmode */
+	u_int8_t	isi_macaddr[IEEE80211_ADDR_LEN];
+	u_int8_t	isi_nrates;
+						/* negotiated rates */
+	u_int8_t	isi_rates[IEEE80211_RATE_MAXSIZE];
+	u_int8_t	isi_txrate;		/* index to isi_rates[] */
+    u_int32_t   isi_txratekbps; /* tx rate in Kbps, for 11n */
+	u_int16_t	isi_ie_len;		/* IE length */
+	u_int16_t	isi_associd;		/* assoc response */
+	u_int16_t	isi_txpower;		/* current tx power */
+	u_int16_t	isi_vlan;		/* vlan tag */
+	u_int16_t	isi_txseqs[17];		/* seq to be transmitted */
+	u_int16_t	isi_rxseqs[17];		/* seq previous for qos frames*/
+	u_int16_t	isi_inact;		/* inactivity timer */
+	u_int8_t	isi_uapsd;		/* UAPSD queues */
+	u_int8_t	isi_opmode;		/* sta operating mode */
+	u_int8_t	isi_cipher;
+        u_int32_t 	isi_assoc_time;         /* sta association time */
+	struct timespec	isi_tr069_assoc_time;	/* sta association time in timespec format */
+
+
+    u_int16_t   isi_htcap;      /* HT capabilities */
+    u_int32_t   isi_rxratekbps; /* rx rate in Kbps */
+                                /* We use this as a common variable for legacy rates
+                                   and lln. We do not attempt to make it symmetrical
+                                   to isi_txratekbps and isi_txrate, which seem to be
+                                   separate due to legacy code. */
+	/* XXX frag state? */
+	/* variable length IE data */
+    u_int8_t isi_maxrate_per_client; /* Max rate per client */
+	u_int16_t   isi_stamode;        /* Wireless mode for connected sta */
+};
+
+enum {
+	IEEE80211_STA_OPMODE_NORMAL,
+	IEEE80211_STA_OPMODE_XR
+};
+
+/*
+ * Retrieve per-station information; to retrieve all
+ * specify a mac address of ff:ff:ff:ff:ff:ff.
+ */
+struct ieee80211req_sta_req {
+	union {
+		/* NB: explicitly force 64-bit alignment */
+		u_int8_t	macaddr[IEEE80211_ADDR_LEN];
+		u_int64_t	pad;
+	} is_u;
+	struct ieee80211req_sta_info info[1];	/* variable length */
+};
+
+/*
+ * Get/set per-station tx power cap.
+ */
+struct ieee80211req_sta_txpow {
+	u_int8_t	it_macaddr[IEEE80211_ADDR_LEN];
+	u_int8_t	it_txpow;
+};
+
+/*
+ * WME parameters are set and return using i_val and i_len.
+ * i_val holds the value itself.  i_len specifies the AC
+ * and, as appropriate, then high bit specifies whether the
+ * operation is to be applied to the BSS or ourself.
+ */
+#define	IEEE80211_WMEPARAM_SELF	0x0000		/* parameter applies to self */
+#define	IEEE80211_WMEPARAM_BSS	0x8000		/* parameter applies to BSS */
+#define	IEEE80211_WMEPARAM_VAL	0x7fff		/* parameter value */
+
+/*
+ * Scan result data returned for IEEE80211_IOC_SCAN_RESULTS.
+ */
+struct ieee80211req_scan_result {
+	u_int16_t	isr_len;		/* length (mult of 4) */
+	u_int16_t	isr_freq;		/* MHz */
+	u_int32_t	isr_flags;		/* channel flags */
+	u_int8_t	isr_noise;
+	u_int8_t	isr_rssi;
+	u_int8_t	isr_intval;		/* beacon interval */
+	u_int16_t	isr_capinfo;		/* capabilities */
+	u_int8_t	isr_erp;		/* ERP element */
+	u_int8_t	isr_bssid[IEEE80211_ADDR_LEN];
+	u_int8_t	isr_nrates;
+	u_int8_t	isr_rates[IEEE80211_RATE_MAXSIZE];
+	u_int8_t	isr_ssid_len;		/* SSID length */
+	u_int16_t	isr_ie_len;		/* IE length */
+	u_int8_t	isr_pad[4];
+	/* variable length SSID followed by IE data */
+};
+
+/* Options for Mcast Enhancement */
+enum {
+		IEEE80211_ME_DISABLE =	0,
+		IEEE80211_ME_TUNNELING =	1,
+		IEEE80211_ME_TRANSLATE =	2
+};
+
+/*
+ * athdbg request
+ */
+enum {
+    IEEE80211_DBGREQ_SENDADDBA     =	0,
+    IEEE80211_DBGREQ_SENDDELBA     =	1,
+    IEEE80211_DBGREQ_SETADDBARESP  =	2,
+    IEEE80211_DBGREQ_GETADDBASTATS =	3,
+    IEEE80211_DBGREQ_SENDBCNRPT    =	4, /* beacon report request */
+    IEEE80211_DBGREQ_SENDTSMRPT    =	5, /* traffic stream measurement report */
+    IEEE80211_DBGREQ_SENDNEIGRPT   =	6, /* neigbor report */
+    IEEE80211_DBGREQ_SENDLMREQ     =	7, /* link measurement request */
+    IEEE80211_DBGREQ_SENDBSTMREQ   =	8, /* bss transition management request */
+    IEEE80211_DBGREQ_SENDCHLOADREQ =    9, /* bss channel load  request */
+    IEEE80211_DBGREQ_SENDSTASTATSREQ =  10, /* sta stats request */
+    IEEE80211_DBGREQ_SENDNHIST     =    11, /* Noise histogram request */
+    IEEE80211_DBGREQ_SENDDELTS     =	12, /* delete TSPEC */
+    IEEE80211_DBGREQ_SENDADDTSREQ  =	13, /* add TSPEC */
+    IEEE80211_DBGREQ_SENDLCIREQ    =    14, /* Location config info request */
+    IEEE80211_DBGREQ_GETRRMSTATS   =    15, /* RRM stats */
+    IEEE80211_DBGREQ_SENDFRMREQ    =    16, /* RRM Frame request */
+    IEEE80211_DBGREQ_GETBCNRPT     =    17, /* GET BCN RPT */
+    IEEE80211_DBGREQ_SENDSINGLEAMSDU=   18, /* Sends single VHT MPDU AMSDUs */
+    IEEE80211_DBGREQ_GETRRSSI	   =	19, /* GET the Inst RSSI */
+    IEEE80211_DBGREQ_GETACSREPORT  =	20, /* GET the ACS report */
+    IEEE80211_DBGREQ_SETACSUSERCHANLIST  =    21, /* SET ch list for acs reporting  */
+    IEEE80211_DBGREQ_GETACSUSERCHANLIST  =    22, /* GET ch list used in acs reporting */
+    IEEE80211_DBGREQ_BLOCK_ACS_CHANNEL	 =    23, /* Block acs for these channels */
+    IEEE80211_DBGREQ_TR069  	         =    24, /* to be used for tr069 */
+    IEEE80211_DBGREQ_GET_RRM_STA_LIST    =    25, /* to get list of connected rrm capable staion */
+
+    IEEE80211_DBGREQ_BSTEERING_SET_PARAMS =   26, /* Set the static band steering parameters */
+    IEEE80211_DBGREQ_BSTEERING_GET_PARAMS =   27, /* Get the static band steering parameters */
+    IEEE80211_DBGREQ_BSTEERING_SET_DBG_PARAMS =   28, /* Set the band steering debugging parameters */
+    IEEE80211_DBGREQ_BSTEERING_GET_DBG_PARAMS =   29, /* Get the band steering debugging parameters */
+    IEEE80211_DBGREQ_BSTEERING_ENABLE         =   30, /* Enable/Disable band steering */
+    IEEE80211_DBGREQ_BSTEERING_SET_OVERLOAD   =   31, /* SET overload status */
+    IEEE80211_DBGREQ_BSTEERING_GET_OVERLOAD   =   32, /* GET overload status */
+    IEEE80211_DBGREQ_BSTEERING_GET_RSSI       =   33, /* Request RSSI measurement */
+
+    IEEE80211_DBGREQ_BSTEERING_SET_PROBE_RESP_WH  = 34,/* Control whether probe responses are withheld for a MAC */
+    IEEE80211_DBGREQ_BSTEERING_GET_PROBE_RESP_WH  = 35,/* Query whether probe responses are withheld for a MAC */
+
+    IEEE80211_DBGREQ_MU_SCAN             =    36, /* do a MU scan */
+    IEEE80211_DBGREQ_LTEU_CFG            =    37, /* LTEu specific configuration */
+    IEEE80211_DBGREQ_AP_SCAN             =    38, /* do a AP scan */
+};
+
+typedef struct ieee80211req_acs_r{
+    u_int32_t index;
+    u_int32_t data_size;
+    void *data_addr;
+}ieee80211req_acs_t;
+
+typedef struct ieee80211_user_chanlist_r {
+    u_int8_t  n_chan;
+    u_int8_t *chan;
+} ieee80211_user_chanlist_t;
+
+typedef struct ieee80211_rrm_sta_info {
+    u_int16_t count; /* In application layer this variable is used to store the STA count and in the driver it is used as an index */
+    u_int8_t *dest_addr;
+}ieee80211_rrm_sta_info_t;
+
+/*
+ * command id's for use in tr069 request
+ */
+typedef enum _ieee80211_tr069_cmd_ {
+    TR069_CHANHIST           = 1,
+    TR069_TXPOWER            = 2,
+    TR069_GETTXPOWER         = 3,
+    TR069_GUARDINTV          = 4,
+    TR069_GET_GUARDINTV      = 5,
+    TR069_GETASSOCSTA_CNT    = 6,
+    TR069_GETTIMESTAMP       = 7,
+    TR069_GETDIAGNOSTICSTATE = 8,
+    TR069_GETNUMBEROFENTRIES = 9,
+    TR069_GET11HSUPPORTED    = 10,
+    TR069_GETPOWERRANGE      = 11,
+    TR069_SET_OPER_RATE      = 12,
+    TR069_GET_OPER_RATE      = 13,
+    TR069_GET_POSIBLRATE     = 14,
+    TR069_SET_BSRATE         = 15,
+    TR069_GET_BSRATE         = 16,
+    TR069_GETSUPPORTEDFREQUENCY  = 17,
+}ieee80211_tr069_cmd;
+
+typedef struct {
+	u_int32_t value;
+	int value_array[TR069MAXPOWERRANGE];
+}ieee80211_tr069_txpower_range;
+
+typedef struct{
+    u_int8_t         chanid;
+    struct timespec chan_time;
+}ieee80211_chanlhist_t;
+
+typedef struct{
+    u_int8_t act_index;
+    ieee80211_chanlhist_t chanlhist[IEEE80211_CHAN_MAXHIST+1];
+}ieee80211_channelhist_t;
+
+/*
+ * common structure to handle tr069 commands;
+ * the cmdid and data pointer has to be appropriately
+ * filled in
+ */
+typedef struct{
+    u_int32_t data_size;
+    ieee80211_tr069_cmd cmdid;
+    void *data_addr;
+}ieee80211req_tr069_t;
+
+typedef enum {
+    MU_ALGO_1 = 0x1,
+    MU_ALGO_2 = 0x2,
+    MU_ALGO_3 = 0x4,
+} mu_algo_t;
+
+typedef struct {
+    u_int8_t     mu_req_id;            /* MU request id */
+    u_int8_t     mu_channel;           /* IEEE channel number on which to do MU scan */
+    mu_algo_t    mu_type;              /* which MU algo to use */
+    u_int32_t    mu_duration;          /* duration of the scan in ms */
+    u_int32_t    lteu_tx_power;        /* LTEu Tx power */
+} ieee80211req_mu_scan_t;
+
+#define LTEU_MAX_BINS        10
+
+typedef struct {
+    u_int8_t     lteu_gpio_start;      /* start MU/AP scan after GPIO toggle */
+    u_int8_t     lteu_num_bins;        /* no. of elements in the following arrays */
+    u_int8_t     use_actual_nf;        /* whether to use the actual NF obtained or a hardcoded one */
+    u_int32_t    lteu_weight[LTEU_MAX_BINS];  /* weights for MU algo */
+    u_int32_t    lteu_thresh[LTEU_MAX_BINS];  /* thresholds for MU algo */
+    u_int32_t    lteu_gamma[LTEU_MAX_BINS];   /* gamma's for MU algo */
+    u_int32_t    lteu_scan_timeout;    /* timeout in ms to gpio toggle */
+    u_int32_t    alpha_num_bssid;      /* alpha for num active bssid calculation */
+} ieee80211req_lteu_cfg_t;
+
+#define MAX_SCAN_CHANS       32
+
+typedef enum {
+    SCAN_PASSIVE,
+    SCAN_ACTIVE,
+} scan_type_t;
+
+typedef struct {
+    u_int8_t     scan_req_id;          /* AP scan request id */
+    u_int8_t     scan_num_chan;        /* Number of channels to scan, 0 for all channels */
+    u_int8_t     scan_channel_list[MAX_SCAN_CHANS]; /* IEEE channel number of channels to scan */
+    scan_type_t  scan_type;            /* Scan type - active or passive */
+    u_int32_t    scan_duration;        /* Duration in ms for which a channel is scanned, 0 for default */
+    u_int32_t    scan_repeat_probe_time;   /* Time before sending second probe request, (u32)(-1) for default */
+    u_int32_t    scan_rest_time;       /* Time in ms on the BSS channel, (u32)(-1) for default */
+    u_int32_t    scan_idle_time;       /* Time in msec on BSS channel before switching channel, (u32)(-1) for default */
+    u_int32_t    scan_probe_delay;     /* Delay in msec before sending probe request, (u32)(-1) for default */
+} ieee80211req_ap_scan_t;
+
+struct ieee80211req_athdbg {
+    u_int8_t cmd;
+    u_int8_t dstmac[IEEE80211_ADDR_LEN];
+    union {
+        int param[4];
+        ieee80211_rrm_beaconreq_info_t bcnrpt;
+        ieee80211_rrm_tsmreq_info_t    tsmrpt;
+        ieee80211_rrm_nrreq_info_t     neigrpt;
+        struct ieee80211_bstm_reqinfo   bstmreq;
+        ieee80211_tspec_info     tsinfo;
+        ieee80211_rrm_chloadreq_info_t chloadrpt;
+        ieee80211_rrm_stastats_info_t  stastats;
+        ieee80211_rrm_nhist_info_t     nhist;
+        ieee80211_rrm_frame_req_info_t frm_req;
+        ieee80211_rrm_lcireq_info_t    lci_req;
+        ieee80211req_rrmstats_t        rrmstats_req;
+        ieee80211req_acs_t             acs_rep;
+        ieee80211req_tr069_t           tr069_req;
+        ieee80211_bsteering_param_t    bsteering_param;
+        ieee80211_bsteering_dbg_param_t bsteering_dbg_param;
+        ieee80211_bsteering_rssi_req_t bsteering_rssi_req;
+        u_int8_t                       bsteering_probe_resp_wh;
+        u_int8_t bsteering_enable;
+        u_int8_t bsteering_overload;
+        u_int8_t bsteering_rssi_num_samples;
+        ieee80211req_mu_scan_t         mu_scan_req;
+        ieee80211req_lteu_cfg_t        lteu_cfg;
+        ieee80211req_ap_scan_t         ap_scan_req;
+    } data;
+};
+
+/*
+ * Error codes for TR069 related implementation
+ */
+typedef enum {
+    TR069_EOK           =   0,
+    TR069_EINVALINP     =   1,
+    TR069_ENSERIALINP   =   2,
+}tr069_err;
+
+#ifdef __linux__
+/*
+ * Wireless Extensions API, private ioctl interfaces.
+ *
+ * NB: Even-numbered ioctl numbers have set semantics and are privileged!
+ *	(regardless of the incorrect comment in wireless.h!)
+ *
+ *	Note we can only use 32 private ioctls, and yes they are all claimed.
+ */
+#ifndef _NET_IF_H
+#include <linux/if.h>
+#endif
+#define	IEEE80211_IOCTL_SETPARAM	(SIOCIWFIRSTPRIV+0)
+#define	IEEE80211_IOCTL_GETPARAM	(SIOCIWFIRSTPRIV+1)
+#define	IEEE80211_IOCTL_SETKEY		(SIOCIWFIRSTPRIV+2)
+#define	IEEE80211_IOCTL_SETWMMPARAMS	(SIOCIWFIRSTPRIV+3)
+#define	IEEE80211_IOCTL_DELKEY		(SIOCIWFIRSTPRIV+4)
+#define	IEEE80211_IOCTL_GETWMMPARAMS	(SIOCIWFIRSTPRIV+5)
+#define	IEEE80211_IOCTL_SETMLME		(SIOCIWFIRSTPRIV+6)
+#define	IEEE80211_IOCTL_GETCHANINFO	(SIOCIWFIRSTPRIV+7)
+#define	IEEE80211_IOCTL_SETOPTIE	(SIOCIWFIRSTPRIV+8)
+#define	IEEE80211_IOCTL_GETOPTIE	(SIOCIWFIRSTPRIV+9)
+#define	IEEE80211_IOCTL_ADDMAC		(SIOCIWFIRSTPRIV+10)        /* Add ACL MAC Address */
+#define	IEEE80211_IOCTL_DELMAC		(SIOCIWFIRSTPRIV+12)        /* Del ACL MAC Address */
+#define	IEEE80211_IOCTL_GETCHANLIST	(SIOCIWFIRSTPRIV+13)
+#define	IEEE80211_IOCTL_SETCHANLIST	(SIOCIWFIRSTPRIV+14)
+#define IEEE80211_IOCTL_KICKMAC		(SIOCIWFIRSTPRIV+15)
+#define	IEEE80211_IOCTL_CHANSWITCH	(SIOCIWFIRSTPRIV+16)
+#define	IEEE80211_IOCTL_GETMODE		(SIOCIWFIRSTPRIV+17)
+#define	IEEE80211_IOCTL_SETMODE		(SIOCIWFIRSTPRIV+18)
+#define IEEE80211_IOCTL_GET_APPIEBUF	(SIOCIWFIRSTPRIV+19)
+#define IEEE80211_IOCTL_SET_APPIEBUF	(SIOCIWFIRSTPRIV+20)
+#define IEEE80211_IOCTL_SET_ACPARAMS	(SIOCIWFIRSTPRIV+21)
+#define IEEE80211_IOCTL_FILTERFRAME	(SIOCIWFIRSTPRIV+22)
+#define IEEE80211_IOCTL_SET_RTPARAMS	(SIOCIWFIRSTPRIV+23)
+#define IEEE80211_IOCTL_DBGREQ	        (SIOCIWFIRSTPRIV+24)
+#define IEEE80211_IOCTL_SEND_MGMT	(SIOCIWFIRSTPRIV+26)
+#define IEEE80211_IOCTL_SET_MEDENYENTRY (SIOCIWFIRSTPRIV+27)
+#define IEEE80211_IOCTL_CHN_WIDTHSWITCH (SIOCIWFIRSTPRIV+28)
+#define IEEE80211_IOCTL_GET_MACADDR	(SIOCIWFIRSTPRIV+29)        /* Get ACL List */
+#define IEEE80211_IOCTL_SET_HBRPARAMS	(SIOCIWFIRSTPRIV+30)
+#define IEEE80211_IOCTL_SET_RXTIMEOUT	(SIOCIWFIRSTPRIV+31)
+/*
+ * MCAST_GROUP is used for testing, not for regular operation.
+ * It is defined unconditionally (overlapping with SET_RXTIMEOUT),
+ * but only used for debugging (after disabling SET_RXTIMEOUT).
+ */
+#define IEEE80211_IOCTL_MCAST_GROUP     (SIOCIWFIRSTPRIV+31)
+
+enum {
+	IEEE80211_WMMPARAMS_CWMIN	= 1,
+	IEEE80211_WMMPARAMS_CWMAX	= 2,
+	IEEE80211_WMMPARAMS_AIFS	= 3,
+	IEEE80211_WMMPARAMS_TXOPLIMIT	= 4,
+	IEEE80211_WMMPARAMS_ACM		= 5,
+	IEEE80211_WMMPARAMS_NOACKPOLICY	= 6,
+#if UMAC_VOW_DEBUG
+    IEEE80211_PARAM_VOW_DBG_CFG     = 7,  /*Configure VoW debug MACs*/
+#endif
+};
+enum {
+	IEEE80211_IOCTL_RCPARAMS_RTPARAM	= 1,
+	IEEE80211_IOCTL_RCPARAMS_RTMASK		= 2,
+};
+enum {
+	IEEE80211_PARAM_TURBO		= 1,	/* turbo mode */
+	IEEE80211_PARAM_MODE		= 2,	/* phy mode (11a, 11b, etc.) */
+	IEEE80211_PARAM_AUTHMODE	= 3,	/* authentication mode */
+	IEEE80211_PARAM_PROTMODE	= 4,	/* 802.11g protection */
+	IEEE80211_PARAM_MCASTCIPHER	= 5,	/* multicast/default cipher */
+	IEEE80211_PARAM_MCASTKEYLEN	= 6,	/* multicast key length */
+	IEEE80211_PARAM_UCASTCIPHERS	= 7,	/* unicast cipher suites */
+	IEEE80211_PARAM_UCASTCIPHER	= 8,	/* unicast cipher */
+	IEEE80211_PARAM_UCASTKEYLEN	= 9,	/* unicast key length */
+	IEEE80211_PARAM_WPA		= 10,	/* WPA mode (0,1,2) */
+	IEEE80211_PARAM_ROAMING		= 12,	/* roaming mode */
+	IEEE80211_PARAM_PRIVACY		= 13,	/* privacy invoked */
+	IEEE80211_PARAM_COUNTERMEASURES	= 14,	/* WPA/TKIP countermeasures */
+	IEEE80211_PARAM_DROPUNENCRYPTED	= 15,	/* discard unencrypted frames */
+	IEEE80211_PARAM_DRIVER_CAPS	= 16,	/* driver capabilities */
+	IEEE80211_PARAM_MACCMD		= 17,	/* MAC ACL operation */
+	IEEE80211_PARAM_WMM		= 18,	/* WMM mode (on, off) */
+	IEEE80211_PARAM_HIDESSID	= 19,	/* hide SSID mode (on, off) */
+	IEEE80211_PARAM_APBRIDGE	= 20,	/* AP inter-sta bridging */
+	IEEE80211_PARAM_KEYMGTALGS	= 21,	/* key management algorithms */
+	IEEE80211_PARAM_RSNCAPS		= 22,	/* RSN capabilities */
+	IEEE80211_PARAM_INACT		= 23,	/* station inactivity timeout */
+	IEEE80211_PARAM_INACT_AUTH	= 24,	/* station auth inact timeout */
+	IEEE80211_PARAM_INACT_INIT	= 25,	/* station init inact timeout */
+	IEEE80211_PARAM_DTIM_PERIOD	= 28,	/* DTIM period (beacons) */
+	IEEE80211_PARAM_BEACON_INTERVAL	= 29,	/* beacon interval (ms) */
+	IEEE80211_PARAM_DOTH		= 30,	/* 11.h is on/off */
+	IEEE80211_PARAM_PWRTARGET	= 31,	/* Current Channel Pwr Constraint */
+	IEEE80211_PARAM_GENREASSOC	= 32,	/* Generate a reassociation request */
+	IEEE80211_PARAM_COMPRESSION	= 33,	/* compression */
+	IEEE80211_PARAM_FF		= 34,	/* fast frames support */
+	IEEE80211_PARAM_XR		= 35,	/* XR support */
+	IEEE80211_PARAM_BURST		= 36,	/* burst mode */
+	IEEE80211_PARAM_PUREG		= 37,	/* pure 11g (no 11b stations) */
+	IEEE80211_PARAM_AR		= 38,	/* AR support */
+	IEEE80211_PARAM_WDS		= 39,	/* Enable 4 address processing */
+	IEEE80211_PARAM_BGSCAN		= 40,	/* bg scanning (on, off) */
+	IEEE80211_PARAM_BGSCAN_IDLE	= 41,	/* bg scan idle threshold */
+	IEEE80211_PARAM_BGSCAN_INTERVAL	= 42,	/* bg scan interval */
+	IEEE80211_PARAM_MCAST_RATE	= 43,	/* Multicast Tx Rate */
+	IEEE80211_PARAM_COVERAGE_CLASS	= 44,	/* coverage class */
+	IEEE80211_PARAM_COUNTRY_IE	= 45,	/* enable country IE */
+	IEEE80211_PARAM_SCANVALID	= 46,	/* scan cache valid threshold */
+	IEEE80211_PARAM_ROAM_RSSI_11A	= 47,	/* rssi threshold in 11a */
+	IEEE80211_PARAM_ROAM_RSSI_11B	= 48,	/* rssi threshold in 11b */
+	IEEE80211_PARAM_ROAM_RSSI_11G	= 49,	/* rssi threshold in 11g */
+	IEEE80211_PARAM_ROAM_RATE_11A	= 50,	/* tx rate threshold in 11a */
+	IEEE80211_PARAM_ROAM_RATE_11B	= 51,	/* tx rate threshold in 11b */
+	IEEE80211_PARAM_ROAM_RATE_11G	= 52,	/* tx rate threshold in 11g */
+	IEEE80211_PARAM_UAPSDINFO	= 53,	/* value for qos info field */
+	IEEE80211_PARAM_SLEEP		= 54,	/* force sleep/wake */
+	IEEE80211_PARAM_QOSNULL		= 55,	/* force sleep/wake */
+	IEEE80211_PARAM_PSPOLL		= 56,	/* force ps-poll generation (sta only) */
+	IEEE80211_PARAM_EOSPDROP	= 57,	/* force uapsd EOSP drop (ap only) */
+	IEEE80211_PARAM_MARKDFS		= 58,	/* mark a dfs interference channel when found */
+	IEEE80211_PARAM_REGCLASS	= 59,	/* enable regclass ids in country IE */
+	IEEE80211_PARAM_CHANBW		= 60,	/* set chan bandwidth preference */
+	IEEE80211_PARAM_WMM_AGGRMODE	= 61,	/* set WMM Aggressive Mode */
+	IEEE80211_PARAM_SHORTPREAMBLE	= 62, 	/* enable/disable short Preamble */
+	IEEE80211_PARAM_BLOCKDFSCHAN	= 63, 	/* enable/disable use of DFS channels */
+	IEEE80211_PARAM_CWM_MODE	= 64,	/* CWM mode */
+	IEEE80211_PARAM_CWM_EXTOFFSET	= 65,	/* CWM extension channel offset */
+	IEEE80211_PARAM_CWM_EXTPROTMODE	= 66,	/* CWM extension channel protection mode */
+	IEEE80211_PARAM_CWM_EXTPROTSPACING = 67,/* CWM extension channel protection spacing */
+	IEEE80211_PARAM_CWM_ENABLE	= 68,/* CWM state machine enabled */
+	IEEE80211_PARAM_CWM_EXTBUSYTHRESHOLD = 69,/* CWM extension channel busy threshold */
+	IEEE80211_PARAM_CWM_CHWIDTH	= 70,	/* CWM STATE: current channel width */
+	IEEE80211_PARAM_SHORT_GI	= 71,	/* half GI */
+	IEEE80211_PARAM_FAST_CC		= 72,	/* fast channel change */
+
+	/*
+	 * 11n A-MPDU, A-MSDU support
+	 */
+	IEEE80211_PARAM_AMPDU		= 73,	/* 11n a-mpdu support */
+	IEEE80211_PARAM_AMPDU_LIMIT	= 74,	/* a-mpdu length limit */
+	IEEE80211_PARAM_AMPDU_DENSITY	= 75,	/* a-mpdu density */
+	IEEE80211_PARAM_AMPDU_SUBFRAMES	= 76,	/* a-mpdu subframe limit */
+	IEEE80211_PARAM_AMSDU		= 77,	/* a-msdu support */
+	IEEE80211_PARAM_AMSDU_LIMIT	= 78,	/* a-msdu length limit */
+
+	IEEE80211_PARAM_COUNTRYCODE	= 79,	/* Get country code */
+	IEEE80211_PARAM_TX_CHAINMASK	= 80,	/* Tx chain mask */
+	IEEE80211_PARAM_RX_CHAINMASK	= 81,	/* Rx chain mask */
+	IEEE80211_PARAM_RTSCTS_RATECODE	= 82,	/* RTS Rate code */
+	IEEE80211_PARAM_HT_PROTECTION	= 83,	/* Protect traffic in HT mode */
+	IEEE80211_PARAM_RESET_ONCE	= 84,	/* Force a reset */
+	IEEE80211_PARAM_SETADDBAOPER	= 85,	/* Set ADDBA mode */
+	IEEE80211_PARAM_TX_CHAINMASK_LEGACY = 86, /* Tx chain mask for legacy clients */
+	IEEE80211_PARAM_11N_RATE	= 87,	/* Set ADDBA mode */
+	IEEE80211_PARAM_11N_RETRIES	= 88,	/* Tx chain mask for legacy clients */
+	IEEE80211_PARAM_DBG_LVL		= 89,	/* Debug Level for specific VAP */
+	IEEE80211_PARAM_WDS_AUTODETECT	= 90,	/* Configurable Auto Detect/Delba for WDS mode */
+	IEEE80211_PARAM_ATH_RADIO	= 91,	/* returns the name of the radio being used */
+	IEEE80211_PARAM_IGNORE_11DBEACON = 92,	/* Don't process 11d beacon (on, off) */
+	IEEE80211_PARAM_STA_FORWARD	= 93,	/* Enable client 3 addr forwarding */
+
+	/*
+	 * Mcast Enhancement support
+	 */
+	IEEE80211_PARAM_ME          = 94,   /* Set Mcast enhancement option: 0 disable, 1 tunneling, 2 translate  4 to disable snoop feature*/
+	IEEE80211_PARAM_MEDUMP		= 95,	/* Dump the snoop table for mcast enhancement */
+	IEEE80211_PARAM_MEDEBUG		= 96,	/* mcast enhancement debug level */
+	IEEE80211_PARAM_ME_SNOOPLENGTH	= 97,	/* mcast snoop list length */
+	IEEE80211_PARAM_ME_TIMER	= 98,	/* Set Mcast enhancement timer to update the snoop list, in msec */
+	IEEE80211_PARAM_ME_TIMEOUT	= 99,	/* Set Mcast enhancement timeout for STA's without traffic, in msec */
+	IEEE80211_PARAM_PUREN		= 100,	/* pure 11n (no 11bg/11a stations) */
+	IEEE80211_PARAM_BASICRATES	= 101,	/* Change Basic Rates */
+	IEEE80211_PARAM_NO_EDGE_CH	= 102,	/* Avoid band edge channels */
+	IEEE80211_PARAM_WEP_TKIP_HT	= 103,	/* Enable HT rates with WEP/TKIP encryption */
+	IEEE80211_PARAM_RADIO		= 104,	/* radio on/off */
+	IEEE80211_PARAM_NETWORK_SLEEP	= 105,	/* set network sleep enable/disable */
+	IEEE80211_PARAM_DROPUNENC_EAPOL	= 106,
+
+	/*
+	 * Headline block removal
+	 */
+	IEEE80211_PARAM_HBR_TIMER	= 107,
+	IEEE80211_PARAM_HBR_STATE	= 108,
+
+	/*
+	 * Unassociated power consumpion improve
+	 */
+	IEEE80211_PARAM_SLEEP_PRE_SCAN	= 109,
+	IEEE80211_PARAM_SCAN_PRE_SLEEP	= 110,
+	IEEE80211_PARAM_VAP_IND		= 111,  /* Independent VAP mode for Repeater and AP-STA config */
+
+	/* support for wapi: set auth mode and key */
+	IEEE80211_PARAM_SETWAPI		= 112,
+	IEEE80211_IOCTL_GREEN_AP_PS_ENABLE = 113,
+	IEEE80211_IOCTL_GREEN_AP_PS_TIMEOUT = 114,
+	IEEE80211_IOCTL_GREEN_AP_PS_ON_TIME = 115,
+	IEEE80211_PARAM_WPS		= 116,
+	IEEE80211_PARAM_RX_RATE		= 117,
+	IEEE80211_PARAM_CHEXTOFFSET	= 118,
+	IEEE80211_PARAM_CHSCANINIT	= 119,
+	IEEE80211_PARAM_MPDU_SPACING	= 120,
+	IEEE80211_PARAM_HT40_INTOLERANT	= 121,
+	IEEE80211_PARAM_CHWIDTH		= 122,
+	IEEE80211_PARAM_EXTAP		= 123,   /* Enable client 3 addr forwarding */
+        IEEE80211_PARAM_COEXT_DISABLE    = 124,
+	IEEE80211_PARAM_ME_DROPMCAST	= 125,	/* drop mcast if empty entry */
+	IEEE80211_PARAM_ME_SHOWDENY	= 126,	/* show deny table for mcast enhancement */
+	IEEE80211_PARAM_ME_CLEARDENY	= 127,	/* clear deny table for mcast enhancement */
+	IEEE80211_PARAM_ME_ADDDENY	= 128,	/* add deny entry for mcast enhancement */
+    IEEE80211_PARAM_GETIQUECONFIG = 129, /*print out the iQUE config*/
+    IEEE80211_PARAM_CCMPSW_ENCDEC = 130,  /* support for ccmp s/w encrypt decrypt */
+
+      /* Support for repeater placement */
+    IEEE80211_PARAM_CUSTPROTO_ENABLE = 131,
+    IEEE80211_PARAM_GPUTCALC_ENABLE  = 132,
+    IEEE80211_PARAM_DEVUP            = 133,
+    IEEE80211_PARAM_MACDEV           = 134,
+    IEEE80211_PARAM_MACADDR1         = 135,
+    IEEE80211_PARAM_MACADDR2         = 136,
+    IEEE80211_PARAM_GPUTMODE         = 137,
+    IEEE80211_PARAM_TXPROTOMSG       = 138,
+    IEEE80211_PARAM_RXPROTOMSG       = 139,
+    IEEE80211_PARAM_STATUS           = 140,
+    IEEE80211_PARAM_ASSOC            = 141,
+    IEEE80211_PARAM_NUMSTAS          = 142,
+    IEEE80211_PARAM_STA1ROUTE        = 143,
+    IEEE80211_PARAM_STA2ROUTE        = 144,
+    IEEE80211_PARAM_STA3ROUTE        = 145,
+    IEEE80211_PARAM_STA4ROUTE        = 146,
+    IEEE80211_PARAM_TDLS_ENABLE      = 147,  /* TDLS support */
+    IEEE80211_PARAM_SET_TDLS_RMAC    = 148,  /* Set TDLS link */
+    IEEE80211_PARAM_CLR_TDLS_RMAC    = 149,  /* Clear TDLS link */
+    IEEE80211_PARAM_TDLS_MACADDR1    = 150,
+    IEEE80211_PARAM_TDLS_MACADDR2    = 151,
+    IEEE80211_PARAM_TDLS_ACTION      = 152,
+#if  ATH_SUPPORT_AOW
+    IEEE80211_PARAM_SWRETRIES                   = 153,
+    IEEE80211_PARAM_RTSRETRIES                  = 154,
+    IEEE80211_PARAM_AOW_LATENCY                 = 155,
+    IEEE80211_PARAM_AOW_STATS                   = 156,
+    IEEE80211_PARAM_AOW_LIST_AUDIO_CHANNELS     = 157,
+    IEEE80211_PARAM_AOW_PLAY_LOCAL              = 158,
+    IEEE80211_PARAM_AOW_CLEAR_AUDIO_CHANNELS    = 159,
+    IEEE80211_PARAM_AOW_INTERLEAVE              = 160,
+    IEEE80211_PARAM_AOW_ER                      = 161,
+    IEEE80211_PARAM_AOW_PRINT_CAPTURE           = 162,
+    IEEE80211_PARAM_AOW_ENABLE_CAPTURE          = 163,
+    IEEE80211_PARAM_AOW_FORCE_INPUT             = 164,
+    IEEE80211_PARAM_AOW_EC                      = 165,
+    IEEE80211_PARAM_AOW_EC_FMAP                 = 166,
+    IEEE80211_PARAM_AOW_ES                      = 167,
+    IEEE80211_PARAM_AOW_ESS                     = 168,
+    IEEE80211_PARAM_AOW_ESS_COUNT               = 169,
+    IEEE80211_PARAM_AOW_ESTATS                  = 170,
+    IEEE80211_PARAM_AOW_AS                      = 171,
+    IEEE80211_PARAM_AOW_PLAY_RX_CHANNEL         = 172,
+    IEEE80211_PARAM_AOW_SIM_CTRL_CMD            = 173,
+    IEEE80211_PARAM_AOW_FRAME_SIZE              = 174,
+    IEEE80211_PARAM_AOW_ALT_SETTING             = 175,
+    IEEE80211_PARAM_AOW_ASSOC_ONLY              = 176,
+    IEEE80211_PARAM_AOW_EC_RAMP                 = 177,
+    IEEE80211_PARAM_AOW_DISCONNECT_DEVICE       = 178,
+#endif  /* ATH_SUPPORT_AOW */
+    IEEE80211_PARAM_PERIODIC_SCAN = 179,
+#if ATH_SUPPORT_AP_WDS_COMBO
+    IEEE80211_PARAM_NO_BEACON     = 180,  /* No beacon xmit on VAP */
+#endif
+    IEEE80211_PARAM_VAP_COUNTRY_IE   = 181, /* 802.11d country ie per vap */
+    IEEE80211_PARAM_VAP_DOTH         = 182, /* 802.11h per vap */
+    IEEE80211_PARAM_STA_QUICKKICKOUT = 183, /* station quick kick out */
+    IEEE80211_PARAM_AUTO_ASSOC       = 184,
+    IEEE80211_PARAM_RXBUF_LIFETIME   = 185, /* lifetime of reycled rx buffers */
+    IEEE80211_PARAM_2G_CSA           = 186, /* 2.4 GHz CSA is on/off */
+    IEEE80211_PARAM_WAPIREKEY_USK = 187,
+    IEEE80211_PARAM_WAPIREKEY_MSK = 188,
+    IEEE80211_PARAM_WAPIREKEY_UPDATE = 189,
+#if ATH_SUPPORT_IQUE
+    IEEE80211_PARAM_RC_VIVO          = 190, /* Use separate rate control algorithm for VI/VO queues */
+#endif
+    IEEE80211_PARAM_CLR_APPOPT_IE    = 191,  /* Clear Cached App/OptIE */
+    IEEE80211_PARAM_SW_WOW           = 192,   /* wow by sw */
+    IEEE80211_PARAM_QUIET_PERIOD    = 193,
+    IEEE80211_PARAM_QBSS_LOAD       = 194,
+    IEEE80211_PARAM_RRM_CAP         = 195,
+    IEEE80211_PARAM_WNM_CAP         = 196,
+#if UMAC_SUPPORT_WDS
+    IEEE80211_PARAM_ADD_WDS_ADDR    = 197,  /* add wds addr */
+#endif
+#ifdef QCA_PARTNER_PLATFORM
+    IEEE80211_PARAM_PLTFRM_PRIVATE = 198, /* platfrom's private ioctl*/
+#endif
+
+#if UMAC_SUPPORT_VI_DBG
+    /* Support for Video Debug */
+    IEEE80211_PARAM_DBG_CFG            = 199,
+    IEEE80211_PARAM_DBG_NUM_STREAMS    = 200,
+    IEEE80211_PARAM_STREAM_NUM         = 201,
+    IEEE80211_PARAM_DBG_NUM_MARKERS    = 202,
+    IEEE80211_PARAM_MARKER_NUM         = 203,
+    IEEE80211_PARAM_MARKER_OFFSET_SIZE = 204,
+    IEEE80211_PARAM_MARKER_MATCH       = 205,
+    IEEE80211_PARAM_RXSEQ_OFFSET_SIZE  = 206,
+    IEEE80211_PARAM_RX_SEQ_RSHIFT      = 207,
+    IEEE80211_PARAM_RX_SEQ_MAX         = 208,
+    IEEE80211_PARAM_RX_SEQ_DROP        = 209,
+    IEEE80211_PARAM_TIME_OFFSET_SIZE   = 210,
+    IEEE80211_PARAM_RESTART            = 211,
+    IEEE80211_PARAM_RXDROP_STATUS      = 212,
+#endif
+    IEEE80211_PARAM_TDLS_DIALOG_TOKEN  = 213,  /* Dialog Token of TDLS Discovery Request */
+    IEEE80211_PARAM_TDLS_DISCOVERY_REQ = 214,  /* Do TDLS Discovery Request */
+    IEEE80211_PARAM_TDLS_AUTO_ENABLE   = 215,  /* Enable TDLS auto setup */
+    IEEE80211_PARAM_TDLS_OFF_TIMEOUT   = 216,  /* Seconds of Timeout for off table : TDLS_OFF_TABLE_TIMEOUT */
+    IEEE80211_PARAM_TDLS_TDB_TIMEOUT   = 217,  /* Seconds of Timeout for teardown block : TD_BLOCK_TIMEOUT */
+    IEEE80211_PARAM_TDLS_WEAK_TIMEOUT  = 218,  /* Seconds of Timeout for weak peer : WEAK_PEER_TIMEOUT */
+    IEEE80211_PARAM_TDLS_RSSI_MARGIN   = 219,  /* RSSI margin between AP path and Direct link one */
+    IEEE80211_PARAM_TDLS_RSSI_UPPER_BOUNDARY= 220,  /* RSSI upper boundary of Direct link path */
+    IEEE80211_PARAM_TDLS_RSSI_LOWER_BOUNDARY= 221,  /* RSSI lower boundary of Direct link path */
+    IEEE80211_PARAM_TDLS_PATH_SELECT        = 222,  /* Enable TDLS Path Select bewteen AP path and Direct link one */
+    IEEE80211_PARAM_TDLS_RSSI_OFFSET        = 223,  /* RSSI offset of TDLS Path Select */
+    IEEE80211_PARAM_TDLS_PATH_SEL_PERIOD    = 224,  /* Period time of Path Select */
+#if ATH_SUPPORT_IBSS_DFS
+    IEEE80211_PARAM_IBSS_DFS_PARAM     = 225,
+#endif
+    IEEE80211_PARAM_TDLS_TABLE_QUERY        = 236,  /* Print Table info. of AUTO-TDLS */
+#if ATH_SUPPORT_IBSS_NETLINK_NOTIFICATION
+    IEEE80211_PARAM_IBSS_SET_RSSI_CLASS     = 237,
+    IEEE80211_PARAM_IBSS_START_RSSI_MONITOR = 238,
+    IEEE80211_PARAM_IBSS_RSSI_HYSTERESIS    = 239,
+#endif
+#ifdef ATH_SUPPORT_TxBF
+    IEEE80211_PARAM_TXBF_AUTO_CVUPDATE = 240,       /* Auto CV update enable*/
+    IEEE80211_PARAM_TXBF_CVUPDATE_PER = 241,        /* per theshold to initial CV update*/
+#endif
+    IEEE80211_PARAM_MAXSTA              = 242,
+    IEEE80211_PARAM_RRM_STATS               =243,
+    IEEE80211_PARAM_RRM_SLWINDOW            =244,
+    IEEE80211_PARAM_MFP_TEST    = 245,
+    IEEE80211_PARAM_SCAN_BAND   = 246,                /* only scan channels of requested band */
+#if ATH_SUPPORT_FLOWMAC_MODULE
+    IEEE80211_PARAM_FLOWMAC            = 247, /* flowmac enable/disable ath0*/
+#endif
+#if CONFIG_RCPI
+    IEEE80211_PARAM_TDLS_RCPI_HI     = 248,    /* RCPI params: hi,lo threshold and margin */
+    IEEE80211_PARAM_TDLS_RCPI_LOW    = 249,    /* RCPI params: hi,lo threshold and margin */
+    IEEE80211_PARAM_TDLS_RCPI_MARGIN = 250,    /* RCPI params: hi,lo threshold and margin */
+    IEEE80211_PARAM_TDLS_SET_RCPI    = 251,    /* RCPI params: set hi,lo threshold and margin */
+    IEEE80211_PARAM_TDLS_GET_RCPI    = 252,    /* RCPI params: get hi,lo threshold and margin */
+#endif
+    IEEE80211_PARAM_TDLS_PEER_UAPSD_ENABLE  = 253, /* Enable TDLS Peer U-APSD Power Save feature */
+    IEEE80211_PARAM_TDLS_QOSNULL            = 254, /* Send QOSNULL frame to remote peer */
+    IEEE80211_PARAM_STA_PWR_SET_PSPOLL      = 255,  /* Set ips_use_pspoll flag for STA */
+    IEEE80211_PARAM_NO_STOP_DISASSOC        = 256,  /* Do not send disassociation frame on stopping vap */
+#if UMAC_SUPPORT_IBSS
+    IEEE80211_PARAM_IBSS_CREATE_DISABLE = 257,      /* if set, it prevents IBSS creation */
+#endif
+#if ATH_SUPPORT_WIFIPOS
+    IEEE80211_PARAM_WIFIPOS_TXCORRECTION = 258,      /* Set/Get TxCorrection */
+    IEEE80211_PARAM_WIFIPOS_RXCORRECTION = 259,      /* Set/Get RxCorrection */
+#endif
+#if UMAC_SUPPORT_CHANUTIL_MEASUREMENT
+    IEEE80211_PARAM_CHAN_UTIL_ENAB      = 260,
+    IEEE80211_PARAM_CHAN_UTIL           = 261,      /* Get Channel Utilization value (scale: 0 - 255) */
+#endif /* UMAC_SUPPORT_CHANUTIL_MEASUREMENT */
+    IEEE80211_PARAM_DBG_LVL_HIGH        = 262, /* Debug Level for specific VAP (upper 32 bits) */
+    IEEE80211_PARAM_PROXYARP_CAP        = 263, /* Enable WNM Proxy ARP feature */
+    IEEE80211_PARAM_DGAF_DISABLE        = 264, /* Hotspot 2.0 DGAF Disable feature */
+    IEEE80211_PARAM_L2TIF_CAP           = 265, /* Hotspot 2.0 L2 Traffic Inspection and Filtering */
+    IEEE80211_PARAM_WEATHER_RADAR_CHANNEL = 266, /* weather radar channel selection is bypassed */
+    IEEE80211_PARAM_SEND_DEAUTH           = 267,/* for sending deauth while doing interface down*/
+    IEEE80211_PARAM_WEP_KEYCACHE          = 268,/* wepkeys mustbe in first fourslots in Keycache*/
+#if ATH_SUPPORT_WPA_SUPPLICANT_CHECK_TIME
+    IEEE80211_PARAM_REJOINT_ATTEMP_TIME   = 269, /* Set the Rejoint time */
+#endif
+    IEEE80211_PARAM_WNM_SLEEP           = 270,      /* WNM-Sleep Mode */
+    IEEE80211_PARAM_WNM_BSS_CAP         = 271,
+    IEEE80211_PARAM_WNM_TFS_CAP         = 272,
+    IEEE80211_PARAM_WNM_TIM_CAP         = 273,
+    IEEE80211_PARAM_WNM_SLEEP_CAP       = 274,
+    IEEE80211_PARAM_WNM_FMS_CAP         = 275,
+    IEEE80211_PARAM_RRM_DEBUG           = 276, /* RRM debugging parameter */
+    IEEE80211_PARAM_SET_TXPWRADJUST     = 277,
+    IEEE80211_PARAM_TXRX_DBG              = 278,    /* show txrx debug info */
+    IEEE80211_PARAM_VHT_MCS               = 279,    /* VHT MCS set */
+    IEEE80211_PARAM_TXRX_FW_STATS         = 280,    /* single FW stat */
+    IEEE80211_PARAM_TXRX_FW_MSTATS        = 281,    /* multiple FW stats */
+    IEEE80211_PARAM_NSS                   = 282,    /* Number of Spatial Streams */
+    IEEE80211_PARAM_LDPC                  = 283,    /* Support LDPC */
+    IEEE80211_PARAM_TX_STBC               = 284,    /* Support TX STBC */
+    IEEE80211_PARAM_RX_STBC               = 285,    /* Support RX STBC */
+#if UMAC_SUPPORT_SMARTANTENNA
+    IEEE80211_PARAM_SMARTANT_RETRAIN_THRESHOLD = 286,    /* number of iterations needed for training */
+    IEEE80211_PARAM_SMARTANT_RETRAIN_INTERVAL = 287,    /* number of iterations needed for training */
+    IEEE80211_PARAM_SMARTANT_RETRAIN_DROP = 288,    /* number of iterations needed for training */
+#endif
+#if UMAC_SUPPORT_TDLS
+    IEEE80211_PARAM_TDLS_SET_OFF_CHANNEL    = 288,  /* Configuration of off channel operations */
+    IEEE80211_PARAM_TDLS_SWITCH_TIME        = 289,  /* Time to perform channel switch to an off channel */
+    IEEE80211_PARAM_TDLS_SWITCH_TIMEOUT     = 290,  /* User configured timeout value for switching to an off channel */
+    IEEE80211_PARAM_TDLS_SEC_CHANNEL_OFFSET = 291,
+    IEEE80211_PARAM_TDLS_OFF_CHANNEL_MODE   = 292,
+#endif
+    IEEE80211_PARAM_APONLY                  = 293,
+    IEEE80211_PARAM_TXRX_FW_STATS_RESET     = 294,
+    IEEE80211_PARAM_TX_PPDU_LOG_CFG         = 295,  /* tx PPDU log cfg params */
+    IEEE80211_PARAM_OPMODE_NOTIFY           = 296,  /* Op Mode Notification */
+    IEEE80211_PARAM_NOPBN                   = 297, /* don't send push button notification */
+    IEEE80211_PARAM_DFS_CACTIMEOUT          = 298, /* override CAC timeout */
+    IEEE80211_PARAM_ENABLE_RTSCTS           = 299, /* Enable/disable RTS-CTS */
+
+    IEEE80211_PARAM_MAX_AMPDU               = 300,   /* Set/Get rx AMPDU exponent/shift */
+    IEEE80211_PARAM_VHT_MAX_AMPDU           = 301,   /* Set/Get rx VHT AMPDU exponent/shift */
+    IEEE80211_PARAM_BCAST_RATE              = 302,   /* Setting Bcast DATA rate */
+    IEEE80211_PARAM_PARENT_IFINDEX          = 304,   /* parent net_device ifindex for this VAP */
+#if WDS_VENDOR_EXTENSION
+    IEEE80211_PARAM_WDS_RX_POLICY           = 305,  /* Set/Get WDS rx filter policy for vendor specific WDS */
+#endif
+    IEEE80211_PARAM_ENABLE_OL_STATS         = 306,   /*Enables/Disables the
+                                                        stats in the Host and in the FW */
+    IEEE80211_IOCTL_GREEN_AP_ENABLE_PRINT   = 307,  /* Enable/Disable Green-AP debug prints */
+    IEEE80211_PARAM_RC_NUM_RETRIES          = 308,
+    IEEE80211_PARAM_GET_ACS                 = 309,/* to get status of acs */
+    IEEE80211_PARAM_GET_CAC                 = 310,/* to get status of CAC period */
+    IEEE80211_PARAM_EXT_IFACEUP_ACS         = 311,  /* Enable external auto channel selection entity
+                                                       at VAP init time */
+    IEEE80211_PARAM_ONETXCHAIN              = 312,  /* force to tx with one chain for legacy client */
+    IEEE80211_PARAM_DFSDOMAIN               = 313,  /* Get DFS Domain */
+    IEEE80211_PARAM_SCAN_CHAN_EVENT         = 314,  /* Enable delivery of Scan Channel Events during
+                                                       802.11 scans (11ac offload, and IEEE80211_M_HOSTAP
+                                                       mode only). */
+    IEEE80211_PARAM_DESIRED_CHANNEL         = 315,  /* Get desired channel corresponding to desired
+                                                       PHY mode */
+    IEEE80211_PARAM_DESIRED_PHYMODE         = 316,  /* Get desired PHY mode */
+    IEEE80211_PARAM_SEND_ADDITIONAL_IES     = 317,  /* Control sending of additional IEs to host */
+    IEEE80211_PARAM_START_ACS_REPORT        = 318,  /* to start acs scan report */
+    IEEE80211_PARAM_MIN_DWELL_ACS_REPORT    = 319,  /* min dwell time for  acs scan report */
+    IEEE80211_PARAM_MAX_DWELL_ACS_REPORT    = 320,  /* max dwell time for  acs scan report */
+    IEEE80211_PARAM_ACS_CH_HOP_LONG_DUR     = 321,  /* channel long duration timer used in acs */
+    IEEE80211_PARAM_ACS_CH_HOP_NO_HOP_DUR   = 322,  /* No hopping timer used in acs */
+    IEEE80211_PARAM_ACS_CH_HOP_CNT_WIN_DUR  = 323,  /* counter window timer used in acs */
+    IEEE80211_PARAM_ACS_CH_HOP_NOISE_TH     = 324,  /* Noise threshold used in acs channel hopping */
+    IEEE80211_PARAM_ACS_CH_HOP_CNT_TH       = 325,  /* counter threshold used in acs channel hopping */
+    IEEE80211_PARAM_ACS_ENABLE_CH_HOP       = 326,  /* Enable/Disable acs channel hopping */
+    IEEE80211_PARAM_SET_CABQ_MAXDUR         = 327,  /* set the max tx percentage for cabq */
+    IEEE80211_PARAM_256QAM_2G               = 328,  /* 2.4 GHz 256 QAM support */
+#if ATH_DEBUG
+    IEEE80211_PARAM_OFFCHAN_TX              = 329,  /* testing offchan transmission */
+#endif
+    IEEE80211_PARAM_MAX_SCANENTRY           = 330,  /* MAX scan entry */
+    IEEE80211_PARAM_SCANENTRY_TIMEOUT       = 331,  /* Scan entry timeout value */
+    IEEE80211_PARAM_PURE11AC                = 332,  /* pure 11ac(no 11bg/11a/11n stations) */
+#if UMAC_VOW_DEBUG
+    IEEE80211_PARAM_VOW_DBG_ENABLE  = 333,  /*Enable VoW debug*/
+#endif
+    IEEE80211_PARAM_SCAN_MIN_DWELL          = 334,  /* MIN dwell time to be used during scan */
+    IEEE80211_PARAM_SCAN_MAX_DWELL          = 335,  /* MAX dwell time to be used during scan */
+    IEEE80211_PARAM_BANDWIDTH               = 336,
+    IEEE80211_PARAM_FREQ_BAND               = 337,
+    IEEE80211_PARAM_EXTCHAN                 = 338,
+    IEEE80211_PARAM_MCS                     = 339,
+    IEEE80211_PARAM_CHAN_NOISE              = 340,
+    IEEE80211_PARAM_VHT_SGIMASK             = 341,   /* Set VHT SGI MASK */
+    IEEE80211_PARAM_VHT80_RATEMASK          = 342,   /* Set VHT80 Auto Rate MASK */
+#if ATH_SUPPORT_DSCP_OVERRIDE
+    IEEE80211_PARAM_DSCP_OVERRIDE           = 343,
+    IEEE80211_PARAM_DSCP_TID_MAP            = 344,
+#endif
+    IEEE80211_PARAM_VAP_ENHIND              = 345, /* Independent VAP mode for Repeater and AP-STA config */
+    IEEE80211_PARAM_VAP_PAUSE_SCAN          = 346, /* Pause VAP mode for scanning */
+    IEEE80211_PARAM_VHT_TX_MCSMAP           = 347,   /* Set VHT TX MCS MAP */
+    IEEE80211_PARAM_VHT_RX_MCSMAP           = 348,   /* Set VHT RX MCS MAP */
+#if ATH_PERF_PWR_OFFLOAD
+    IEEE80211_PARAM_VAP_TX_ENCAP_TYPE       = 349,   /* Set Tx encapsulation type */
+#if QCA_SUPPORT_RAWMODE_PKT_SIMULATION
+    IEEE80211_PARAM_RAWMODE_PKT_SIM_STATS   = 350,   /* Get Raw mode packet simulation stats. */
+    IEEE80211_PARAM_CLR_RAWMODE_PKT_SIM_STATS = 351, /* Clear Raw mode packet simulation stats. */
+    IEEE80211_PARAM_RAWMODE_SIM_DEBUG       = 352,   /* Enable/disable raw mode simulation debug */
+#endif /* QCA_SUPPORT_RAWMODE_PKT_SIMULATION */
+#endif /* ATH_PERF_PWR_OFFLOAD */
+    IEEE80211_PARAM_11NG_VHT_INTEROP         = 353,  /* 2.4ng Vht Interop */
+    IEEE80211_PARAM_RX_SIGNAL_DBM            = 354,  /*get rx signal strength in dBm*/
+#if QCA_AIRTIME_FAIRNESS
+    IEEE80211_PARAM_ATF_OPT                 = 355,   /* set airtime feature */
+    IEEE80211_PARAM_ATF_PER_UNIT            = 356,
+#endif
+    IEEE80211_PARAM_SCAN_REPEAT_PROBE_TIME   = 357,
+    IEEE80211_PARAM_SCAN_REST_TIME           = 358,
+    IEEE80211_PARAM_SCAN_IDLE_TIME           = 359,
+    IEEE80211_PARAM_SCAN_PROBE_DELAY         = 360,
+    IEEE80211_PARAM_MU_DELAY                 = 361,
+    IEEE80211_PARAM_WIFI_TX_POWER            = 362,
+};
+/*
+ * New get/set params for p2p.
+ * The first 16 set/get priv ioctls know the direction of the xfer
+ * These sub-ioctls, don't care, any number in 16 bits is ok
+ * The param numbers need not be contiguous, but must be unique
+ */
+#define IEEE80211_IOC_P2P_GO_OPPPS        621    /* IOCTL to turn on/off oppPS for P2P GO */
+#define IEEE80211_IOC_P2P_GO_CTWINDOW     622    /* IOCTL to set CT WINDOW size for P2P GO*/
+#define IEEE80211_IOC_P2P_GO_NOA          623    /* IOCTL to set NOA for P2P GO*/
+
+//#define IEEE80211_IOC_P2P_FLUSH           616    /* IOCTL to flush P2P state */
+#define IEEE80211_IOC_SCAN_REQ            624    /* IOCTL to request a scan */
+//needed, below
+#define IEEE80211_IOC_SCAN_RESULTS        IEEE80211_IOCTL_SCAN_RESULTS
+
+#define IEEE80211_IOC_SSID                626    /* set ssid */
+#define IEEE80211_IOC_MLME                IEEE80211_IOCTL_SETMLME
+#define IEEE80211_IOC_CHANNEL             628    /* set channel */
+
+#define IEEE80211_IOC_WPA                 IEEE80211_PARAM_WPA    /* WPA mode (0,1,2) */
+#define IEEE80211_IOC_AUTHMODE            IEEE80211_PARAM_AUTHMODE
+#define IEEE80211_IOC_KEYMGTALGS          IEEE80211_PARAM_KEYMGTALGS    /* key management algorithms */
+#define IEEE80211_IOC_WPS_MODE            632    /* Wireless Protected Setup mode  */
+
+#define IEEE80211_IOC_UCASTCIPHERS        IEEE80211_PARAM_UCASTCIPHERS    /* unicast cipher suites */
+#define IEEE80211_IOC_UCASTCIPHER         IEEE80211_PARAM_UCASTCIPHER    /* unicast cipher */
+#define IEEE80211_IOC_MCASTCIPHER         IEEE80211_PARAM_MCASTCIPHER    /* multicast/default cipher */
+//unused below
+#define IEEE80211_IOC_START_HOSTAP        636    /* Start hostap mode BSS */
+
+#define IEEE80211_IOC_DROPUNENCRYPTED     637    /* discard unencrypted frames */
+#define IEEE80211_IOC_PRIVACY             638    /* privacy invoked */
+#define IEEE80211_IOC_OPTIE               IEEE80211_IOCTL_SETOPTIE    /* optional info. element */
+#define IEEE80211_IOC_BSSID               640    /* GET bssid */
+//unused below 3
+#define IEEE80211_IOC_P2P_SET_CHANNEL     641    /* Request a switch to a specific channel */
+#define IEEE80211_IOC_P2P_CANCEL_CHANNEL  642    /* Cancel current set-channel operation */
+#define IEEE80211_IOC_P2P_SEND_ACTION     643    /* Send Action frame */
+
+#define IEEE80211_IOC_P2P_OPMODE          644    /* set/get the opmode(STA,AP,P2P GO,P2P CLI) */
+#define IEEE80211_IOC_P2P_FETCH_FRAME     645    /* get rx_frame mgmt data, too large for an event */
+
+#define IEEE80211_IOC_SCAN_FLUSH          646
+#define IEEE80211_IOC_CONNECTION_STATE    647 	/* connection state of the iface */
+#define IEEE80211_IOC_P2P_NOA_INFO        648   /*  To get NOA sub element info from p2p client */
+#define IEEE80211_IOC_P2P_FIND_BEST_CHANNEL 649   /*  find best channel */
+#define IEEE80211_IOC_CANCEL_SCAN           650   /* To cancel scan request */
+#define IEEE80211_IOC_P2P_RADIO_IDX         651   /* Get radio index */
+#ifdef HOST_OFFLOAD
+#define IEEE80211_IOC_P2P_FRAME_LIST_EMPTY  652   /* Get whether any rx frame is pending or not */
+#endif
+
+struct ieee80211_p2p_go_neg {
+    u_int8_t peer_addr[IEEE80211_ADDR_LEN];
+    u_int8_t own_interface_addr[IEEE80211_ADDR_LEN];
+    u_int16_t force_freq;
+    u_int8_t go_intent;
+    char pin[9];
+} __attribute__ ((packed));
+
+struct ieee80211_p2p_prov_disc {
+    u_int8_t peer_addr[IEEE80211_ADDR_LEN];
+    u_int16_t config_methods;
+} __attribute__ ((packed));
+
+struct ieee80211_p2p_serv_disc_resp {
+    u_int16_t freq;
+    u_int8_t dst[IEEE80211_ADDR_LEN];
+    u_int8_t dialog_token;
+    /* followed by response TLVs */
+} __attribute__ ((packed));
+
+struct ieee80211_p2p_go_noa {
+    u_int8_t  num_iterations;   /* Number of iterations (equal 1 if one shot)
+                                   and 1-254 if periodic) and 255 for continuous */
+    u_int16_t offset_next_tbtt; /* offset in msec from next tbtt */
+    u_int16_t duration;         /* duration in msec */
+} __attribute__ ((packed));
+
+struct ieee80211_p2p_set_channel {
+    u_int32_t freq;
+    u_int32_t req_id;
+    u_int32_t channel_time;
+} __attribute__ ((packed));
+
+struct ieee80211_p2p_send_action {
+    u_int32_t freq;
+    u_int8_t dst_addr[IEEE80211_ADDR_LEN];
+    u_int8_t src_addr[IEEE80211_ADDR_LEN];
+    u_int8_t bssid[IEEE80211_ADDR_LEN];
+    /* Followed by Action frame payload */
+} __attribute__ ((packed));
+
+struct ieee80211_send_action_cb {
+    u_int8_t dst_addr[IEEE80211_ADDR_LEN];
+    u_int8_t src_addr[IEEE80211_ADDR_LEN];
+    u_int8_t bssid[IEEE80211_ADDR_LEN];
+    u_int8_t ack;
+    /* followed by frame body */
+} __attribute__ ((packed));
+
+/* Optional parameters for IEEE80211_IOC_SCAN_REQ */
+struct ieee80211_scan_req {
+#define MAX_SCANREQ_FREQ 16
+    u_int32_t freq[MAX_SCANREQ_FREQ];
+    u_int8_t num_freq;
+    u_int8_t num_ssid;
+    u_int16_t ie_len;
+#define MAX_SCANREQ_SSID 4
+    u_int8_t ssid[MAX_SCANREQ_SSID][32];
+    u_int8_t ssid_len[MAX_SCANREQ_SSID];
+    /* followed by ie_len octets of IEs to add to Probe Request frames */
+} __attribute__ ((packed));
+
+struct ieee80211_ioc_channel {
+    u_int32_t phymode; /* enum ieee80211_phymode */
+    u_int32_t channel; /* IEEE channel number */
+} __attribute__ ((packed));
+
+#define LINUX_PVT_SET_VENDORPARAM       (SIOCDEVPRIVATE+0)
+#define LINUX_PVT_GET_VENDORPARAM       (SIOCDEVPRIVATE+1)
+#define	SIOCG80211STATS		(SIOCDEVPRIVATE+2)
+/* NB: require in+out parameters so cannot use wireless extensions, yech */
+#define	IEEE80211_IOCTL_GETKEY		(SIOCDEVPRIVATE+3)
+#define	IEEE80211_IOCTL_GETWPAIE	(SIOCDEVPRIVATE+4)
+#define	IEEE80211_IOCTL_STA_STATS	(SIOCDEVPRIVATE+5)
+#define	IEEE80211_IOCTL_STA_INFO	(SIOCDEVPRIVATE+6)
+#define	SIOC80211IFCREATE		(SIOCDEVPRIVATE+7)
+#define	SIOC80211IFDESTROY	 	(SIOCDEVPRIVATE+8)
+#define	IEEE80211_IOCTL_SCAN_RESULTS	(SIOCDEVPRIVATE+9)
+#define IEEE80211_IOCTL_RES_REQ         (SIOCDEVPRIVATE+10)
+#define IEEE80211_IOCTL_GETMAC          (SIOCDEVPRIVATE+11)
+#define IEEE80211_IOCTL_CONFIG_GENERIC  (SIOCDEVPRIVATE+12)
+#define SIOCIOCTLTX99                   (SIOCDEVPRIVATE+13)
+#define IEEE80211_IOCTL_P2P_BIG_PARAM   (SIOCDEVPRIVATE+14)
+#define SIOCDEVVENDOR                   (SIOCDEVPRIVATE+15)    /* Used for ATH_SUPPORT_LINUX_VENDOR */
+#define	IEEE80211_IOCTL_GET_SCAN_SPACE  (SIOCDEVPRIVATE+16)
+
+#if QCA_AIRTIME_FAIRNESS 
+#define IEEE80211_IOCTL_ATF_ADDSSID     0xFF01
+#define IEEE80211_IOCTL_ATF_DELSSID     0xFF02
+#define IEEE80211_IOCTL_ATF_ADDSTA      0xFF03
+#define IEEE80211_IOCTL_ATF_DELSTA      0xFF04
+#define IEEE80211_IOCTL_ATF_SHOWATFTBL  0xFF05
+#define IEEE80211_IOCTL_ATF_SHOWAIRTIME 0xFF06
+#endif
+
+
+struct ieee80211_clone_params {
+	char		icp_name[IFNAMSIZ];	/* device name */
+	u_int16_t	icp_opmode;		/* operating mode */
+	u_int16_t	icp_flags;		/* see below */
+    u_int8_t icp_bssid[IEEE80211_ADDR_LEN];    /* optional mac/bssid address */
+        int32_t         icp_vapid;             /* vap id for MAC addr req */
+    u_int8_t icp_mataddr[IEEE80211_ADDR_LEN];    /* optional MAT address */
+};
+#define	    IEEE80211_CLONE_BSSID       0x0001		/* allocate unique mac/bssid */
+#define	    IEEE80211_NO_STABEACONS	    0x0002		/* Do not setup the station beacon timers */
+#define    IEEE80211_CLONE_WDS          0x0004      /* enable WDS processing */
+#define    IEEE80211_CLONE_WDSLEGACY    0x0008      /* legacy WDS operation */
+#define    IEEE80211_NOTSUPP_MODE       0x0010      /* AP and monitor VAP combination not supported */
+/* added APPIEBUF related definations */
+enum{
+    IEEE80211_APPIE_FRAME_BEACON     = 0,
+    IEEE80211_APPIE_FRAME_PROBE_REQ  = 1,
+    IEEE80211_APPIE_FRAME_PROBE_RESP = 2,
+    IEEE80211_APPIE_FRAME_ASSOC_REQ  = 3,
+    IEEE80211_APPIE_FRAME_ASSOC_RESP = 4,
+    IEEE80211_APPIE_FRAME_TDLS_FTIE  = 5,   /* TDLS SMK_FTIEs */
+    IEEE80211_APPIE_FRAME_AUTH       = 6,
+    IEEE80211_APPIE_NUM_OF_FRAME     = 7,
+    IEEE80211_APPIE_FRAME_WNM        = 8
+};
+struct ieee80211req_getset_appiebuf {
+    u_int32_t app_frmtype; /*management frame type for which buffer is added*/
+    u_int32_t app_buflen;  /*application supplied buffer length */
+    u_int8_t  app_buf[];
+};
+
+struct ieee80211req_mgmtbuf {
+    u_int8_t  macaddr[IEEE80211_ADDR_LEN]; /* mac address to be sent */
+    u_int32_t buflen;  /*application supplied buffer length */
+    u_int8_t  buf[];
+};
+
+/* the following definations are used by application to set filter
+ * for receiving management frames */
+enum {
+     IEEE80211_FILTER_TYPE_BEACON      =   0x1,
+     IEEE80211_FILTER_TYPE_PROBE_REQ   =   0x2,
+     IEEE80211_FILTER_TYPE_PROBE_RESP  =   0x4,
+     IEEE80211_FILTER_TYPE_ASSOC_REQ   =   0x8,
+     IEEE80211_FILTER_TYPE_ASSOC_RESP  =   0x10,
+     IEEE80211_FILTER_TYPE_AUTH        =   0x20,
+     IEEE80211_FILTER_TYPE_DEAUTH      =   0x40,
+     IEEE80211_FILTER_TYPE_DISASSOC    =   0x80,
+     IEEE80211_FILTER_TYPE_ACTION      =   0x100,
+     IEEE80211_FILTER_TYPE_ALL         =   0xFFF  /* used to check the valid filter bits */
+};
+
+struct ieee80211req_set_filter {
+      u_int32_t app_filterype; /* management frame filter type */
+};
+
+
+struct ieee80211_wlanconfig_nawds {
+    u_int8_t num;
+    u_int8_t mode;
+    u_int8_t defcaps;
+    u_int8_t override;
+    u_int8_t mac[IEEE80211_ADDR_LEN];
+    u_int8_t caps;
+};
+
+struct ieee80211_wlanconfig_hmwds {
+    u_int8_t  wds_ni_macaddr[IEEE80211_ADDR_LEN];
+    u_int16_t wds_macaddr_cnt;
+    u_int8_t  wds_macaddr[0];
+};
+
+struct ieee80211_wlanconfig_ald_sta {
+    u_int8_t  macaddr[IEEE80211_ADDR_LEN];
+    u_int32_t enable;
+};
+
+struct ieee80211_wlanconfig_ald {
+    union {
+        struct ieee80211_wlanconfig_ald_sta ald_sta;
+    } data;
+};
+
+struct ieee80211_wlanconfig_wnm_bssmax {
+    u_int16_t idleperiod;
+};
+
+struct ieee80211_wlanconfig_wds {
+    u_int8_t destmac[IEEE80211_ADDR_LEN];
+    u_int8_t peermac[IEEE80211_ADDR_LEN];
+    u_int32_t flags;
+};
+
+struct ieee80211_wlanconfig_hmmc {
+    u_int32_t ip;
+    u_int32_t mask;
+};
+
+struct ieee80211_wlanconfig_setmaxrate {
+    u_int8_t mac[IEEE80211_ADDR_LEN];
+    u_int8_t maxrate;
+};
+
+#define TFS_MAX_FILTER_LEN 50
+#define TFS_MAX_TCLAS_ELEMENTS 2
+#define TFS_MAX_SUBELEMENTS 2
+#define TFS_MAX_REQUEST 2
+#define TFS_MAX_RESPONSE 600
+
+#define FMS_MAX_SUBELEMENTS    2
+#define FMS_MAX_TCLAS_ELEMENTS 2
+#define FMS_MAX_REQUEST        2
+#define FMS_MAX_RESPONSE       2
+
+typedef enum {
+    IEEE80211_WNM_TFS_AC_DELETE_AFTER_MATCH = 0,
+    IEEE80211_WNM_TFS_AC_NOTIFY = 1,
+} IEEE80211_WNM_TFS_ACTIONCODE;
+
+typedef enum {
+    IEEE80211_WNM_TCLAS_CLASSIFIER_TYPE0 = 0,
+    IEEE80211_WNM_TCLAS_CLASSIFIER_TYPE1 = 1,
+    IEEE80211_WNM_TCLAS_CLASSIFIER_TYPE2 = 2,
+    IEEE80211_WNM_TCLAS_CLASSIFIER_TYPE3 = 3,
+    IEEE80211_WNM_TCLAS_CLASSIFIER_TYPE4 = 4,
+} IEEE80211_WNM_TCLAS_CLASSIFIER;
+
+typedef enum {
+    IEEE80211_WNM_TCLAS_CLAS4_VERSION_4 = 4,
+    IEEE80211_WNM_TCLAS_CLAS4_VERSION_6 = 6,
+} IEEE80211_WNM_TCLAS_VERSION;
+
+struct clas3 {
+    u_int16_t filter_offset;
+    u_int32_t filter_len;
+    u_int8_t  filter_value[TFS_MAX_FILTER_LEN];
+    u_int8_t  filter_mask[TFS_MAX_FILTER_LEN];
+} __packed;
+
+#ifndef IEEE80211_IPV4_LEN
+#define IEEE80211_IPV4_LEN 4
+#endif
+
+#ifndef IEEE80211_IPV6_LEN
+#define IEEE80211_IPV6_LEN 16
+#endif
+struct clas4_v4 {
+    u_int8_t     version;
+    u_int8_t     source_ip[IEEE80211_IPV4_LEN];
+    u_int8_t     reserved1[IEEE80211_IPV6_LEN - IEEE80211_IPV4_LEN];
+    u_int8_t     dest_ip[IEEE80211_IPV4_LEN];
+    u_int8_t     reserved2[IEEE80211_IPV6_LEN - IEEE80211_IPV4_LEN];
+    u_int16_t    source_port;
+    u_int16_t    dest_port;
+    u_int8_t     dscp;
+    u_int8_t     protocol;
+    u_int8_t     reserved;
+    u_int8_t     reserved3[2];
+}__packed;
+
+struct clas4_v6 {
+    u_int8_t     version;
+    u_int8_t     source_ip[IEEE80211_IPV6_LEN];
+    u_int8_t     dest_ip[IEEE80211_IPV6_LEN];
+    u_int16_t    source_port;
+    u_int16_t    dest_port;
+    u_int8_t     dscp;
+    u_int8_t     next_header;
+    u_int8_t     flow_label[3];
+}__packed;
+
+struct tfsreq_tclas_element {
+    u_int8_t classifier_type;
+    u_int8_t classifier_mask;
+    u_int8_t priority;
+    union {
+        struct clas3 clas3;
+        union {
+            struct clas4_v4 clas4_v4;
+            struct clas4_v6 clas4_v6;
+        } clas4;
+    } clas;
+} __packed;
+
+struct tfsreq_subelement {
+    u_int32_t num_tclas_elements;
+    u_int8_t tclas_processing;
+    struct tfsreq_tclas_element tclas[TFS_MAX_TCLAS_ELEMENTS];
+} __packed;
+
+struct ieee80211_wlanconfig_wnm_tfs_req {
+    u_int8_t tfsid;
+    u_int8_t actioncode;
+    u_int8_t num_subelements;
+    struct tfsreq_subelement subelement[TFS_MAX_SUBELEMENTS];
+} __packed;
+
+
+
+struct ieee80211_wlanconfig_wnm_tfs {
+    u_int8_t num_tfsreq;
+    struct ieee80211_wlanconfig_wnm_tfs_req  tfs_req[TFS_MAX_REQUEST];
+} __packed;
+
+struct tfsresp_element {
+	u_int8_t tfsid;
+    u_int8_t status;
+} __packed;
+
+struct ieee80211_wnm_tfsresp {
+    u_int8_t num_tfsresp;
+    struct tfsresp_element  tfs_resq[TFS_MAX_RESPONSE];
+} __packed;
+
+typedef struct  ieee80211_wnm_rate_identifier_s {
+    u_int8_t mask;
+    u_int8_t mcs_idx;
+    u_int16_t rate;
+}__packed ieee80211_wnm_rate_identifier_t;
+
+struct fmsresp_fms_subele_status {
+    u_int8_t status;
+    u_int8_t del_itvl;
+    u_int8_t max_del_itvl;
+    u_int8_t fmsid;
+    u_int8_t fms_counter;
+    ieee80211_wnm_rate_identifier_t rate_id;
+    u_int8_t mcast_addr[6];
+};
+
+struct fmsresp_tclas_subele_status {
+    u_int8_t fmsid;
+    u_int8_t ismcast;
+    u_int32_t mcast_ipaddr;
+    ieee80211_tclas_processing tclasprocess;
+    u_int32_t num_tclas_elements;
+    struct tfsreq_tclas_element tclas[TFS_MAX_TCLAS_ELEMENTS];
+};
+
+struct fmsresp_element {
+    u_int8_t fms_token;
+    u_int8_t num_subelements;
+    u_int8_t subelement_type;
+    union {
+        struct fmsresp_fms_subele_status fms_subele_status[FMS_MAX_TCLAS_ELEMENTS];
+        struct fmsresp_tclas_subele_status tclas_subele_status[FMS_MAX_SUBELEMENTS];
+    }status;
+};
+
+struct ieee80211_wnm_fmsresp {
+    u_int8_t num_fmsresp;
+    struct fmsresp_element  fms_resp[FMS_MAX_RESPONSE];
+};
+
+struct fmsreq_subelement {
+    u_int8_t del_itvl;
+    u_int8_t max_del_itvl;
+    u_int8_t tclas_processing;
+    u_int32_t num_tclas_elements;
+    ieee80211_wnm_rate_identifier_t rate_id;
+    struct tfsreq_tclas_element tclas[FMS_MAX_TCLAS_ELEMENTS];
+} __packed;
+
+struct ieee80211_wlanconfig_wnm_fms_req {
+    u_int8_t fms_token;
+    u_int8_t num_subelements;
+    struct fmsreq_subelement subelement[FMS_MAX_SUBELEMENTS];
+} __packed;
+
+struct ieee80211_wlanconfig_wnm_fms {
+    u_int8_t num_fmsreq;
+    struct ieee80211_wlanconfig_wnm_fms_req  fms_req[FMS_MAX_REQUEST];
+} __packed;
+
+enum {
+    IEEE80211_WNM_TIM_HIGHRATE_ENABLE = 0x1,
+    IEEE80211_WNM_TIM_LOWRATE_ENABLE = 0x2,
+};
+
+struct ieee80211_wlanconfig_wnm_tim {
+    u_int8_t interval;
+    u_int8_t enable_highrate;
+    u_int8_t enable_lowrate;
+} __packed;
+
+struct ieee80211_wlanconfig_wnm {
+    union {
+        struct ieee80211_wlanconfig_wnm_bssmax bssmax;
+        struct ieee80211_wlanconfig_wnm_tfs tfs;
+        struct ieee80211_wlanconfig_wnm_fms fms;
+        struct ieee80211_wlanconfig_wnm_tim tim;
+    } data;
+} __packed;
+
+
+/* generic structure to support sub-ioctl due to limited ioctl */
+typedef enum {
+    IEEE80211_WLANCONFIG_NOP,
+    IEEE80211_WLANCONFIG_NAWDS_SET_MODE,
+    IEEE80211_WLANCONFIG_NAWDS_SET_DEFCAPS,
+    IEEE80211_WLANCONFIG_NAWDS_SET_OVERRIDE,
+    IEEE80211_WLANCONFIG_NAWDS_SET_ADDR,
+    IEEE80211_WLANCONFIG_NAWDS_CLR_ADDR,
+    IEEE80211_WLANCONFIG_NAWDS_GET,
+    IEEE80211_WLANCONFIG_WNM_SET_BSSMAX,
+    IEEE80211_WLANCONFIG_WNM_GET_BSSMAX,
+    IEEE80211_WLANCONFIG_WNM_TFS_ADD,
+    IEEE80211_WLANCONFIG_WNM_TFS_DELETE,
+    IEEE80211_WLANCONFIG_WNM_FMS_ADD_MODIFY,
+    IEEE80211_WLANCONFIG_WNM_SET_TIMBCAST,
+    IEEE80211_WLANCONFIG_WNM_GET_TIMBCAST,
+    IEEE80211_WLANCONFIG_WDS_ADD_ADDR,
+    IEEE80211_WLANCONFIG_HMMC_ADD,
+    IEEE80211_WLANCONFIG_HMMC_DEL,
+    IEEE80211_WLANCONFIG_HMMC_DUMP,
+    IEEE80211_WLANCONFIG_HMWDS_ADD_ADDR,
+    IEEE80211_WLANCONFIG_HMWDS_RESET_ADDR,
+    IEEE80211_WLANCONFIG_HMWDS_RESET_TABLE,
+    IEEE80211_WLANCONFIG_HMWDS_READ_ADDR,
+    IEEE80211_WLANCONFIG_HMWDS_READ_TABLE,
+    IEEE80211_WLANCONFIG_SET_MAX_RATE,
+    IEEE80211_WLANCONFIG_WDS_SET_ENTRY,
+    IEEE80211_WLANCONFIG_WDS_DEL_ENTRY,
+    IEEE80211_WLANCONFIG_ALD_STA_ENABLE,
+} IEEE80211_WLANCONFIG_CMDTYPE;
+/* Note: Do not place any of the above ioctls within compile flags,
+   The above ioctls are also being used by external apps.
+   External apps do not define the compile flags as driver does.
+   Having ioctls within compile flags leave the apps and drivers to use
+   a different values.
+*/
+
+typedef enum {
+    IEEE80211_WLANCONFIG_OK          = 0,
+    IEEE80211_WLANCONFIG_FAIL        = 1,
+} IEEE80211_WLANCONFIG_STATUS;
+
+struct ieee80211_wlanconfig {
+    IEEE80211_WLANCONFIG_CMDTYPE cmdtype;  /* sub-command */
+    IEEE80211_WLANCONFIG_STATUS status;     /* status code */
+    union {
+        struct ieee80211_wlanconfig_nawds nawds;
+        struct ieee80211_wlanconfig_hmwds hmwds;
+        struct ieee80211_wlanconfig_wnm wnm;
+        struct ieee80211_wlanconfig_hmmc hmmc;
+        struct ieee80211_wlanconfig_ald ald;
+    } data;
+
+    struct ieee80211_wlanconfig_setmaxrate smr;
+};
+
+/* kev event_code value for Atheros IEEE80211 events */
+enum {
+    IEEE80211_EV_SCAN_DONE,
+    IEEE80211_EV_CHAN_START,
+    IEEE80211_EV_CHAN_END,
+    IEEE80211_EV_RX_MGMT,
+    IEEE80211_EV_P2P_SEND_ACTION_CB,
+    IEEE80211_EV_IF_RUNNING,
+    IEEE80211_EV_IF_NOT_RUNNING,
+    IEEE80211_EV_AUTH_COMPLETE_AP,
+    IEEE80211_EV_ASSOC_COMPLETE_AP,
+    IEEE80211_EV_DEAUTH_COMPLETE_AP,
+    IEEE80211_EV_AUTH_IND_AP,
+    IEEE80211_EV_AUTH_COMPLETE_STA,
+    IEEE80211_EV_ASSOC_COMPLETE_STA,
+    IEEE80211_EV_DEAUTH_COMPLETE_STA,
+    IEEE80211_EV_DISASSOC_COMPLETE_STA,
+    IEEE80211_EV_AUTH_IND_STA,
+    IEEE80211_EV_DEAUTH_IND_STA,
+    IEEE80211_EV_ASSOC_IND_STA,
+    IEEE80211_EV_DISASSOC_IND_STA,
+    IEEE80211_EV_DEAUTH_IND_AP,
+    IEEE80211_EV_DISASSOC_IND_AP,
+    IEEE80211_EV_WAPI,
+    IEEE80211_EV_CHAN_CHANGE,
+    IEEE80211_EV_MU_RPT,
+    IEEE80211_EV_SCAN,
+};
+
+#endif /* __linux__ */
+
+#define IEEE80211_VAP_PROFILE_NUM_ACL 64
+#define IEEE80211_VAP_PROFILE_MAX_VAPS 16
+
+struct rssi_info {
+    u_int8_t avg_rssi;
+    u_int8_t valid_mask;
+    int8_t   rssi_ctrl[MAX_CHAINS];
+    int8_t   rssi_ext[MAX_CHAINS];
+};
+
+struct ieee80211vap_profile  {
+    char name[IFNAMSIZ];
+    u_int32_t opmode;
+    u_int32_t phymode;
+    char  ssid[IEEE80211_NWID_LEN];
+    u_int32_t bitrate;
+    u_int32_t beacon_interval;
+    u_int32_t txpower;
+    u_int32_t txpower_flags;
+    struct rssi_info bcn_rssi;
+    struct rssi_info rx_rssi;
+    u_int8_t  vap_mac[IEEE80211_ADDR_LEN];
+    u_int32_t  rts_thresh;
+    u_int8_t  rts_disabled;
+    u_int8_t  rts_fixed;
+    u_int32_t frag_thresh;
+    u_int8_t frag_disabled;
+    u_int8_t frag_fixed;
+    u_int32_t   sec_method;
+    u_int32_t   cipher;
+    u_int8_t wep_key[4][256];
+    u_int8_t wep_key_len[4];
+    u_int8_t  maclist[IEEE80211_VAP_PROFILE_NUM_ACL][IEEE80211_ADDR_LEN];
+   	u_int8_t  node_acl;
+    int  num_node;
+    u_int8_t wds_enabled;
+    u_int8_t wds_addr[IEEE80211_ADDR_LEN];
+    u_int32_t wds_flags;
+};
+
+struct ieee80211_profile {
+    u_int8_t radio_name[IFNAMSIZ];
+    u_int8_t channel;
+    u_int32_t freq;
+    u_int16_t cc;
+    u_int8_t  radio_mac[IEEE80211_ADDR_LEN];
+    struct ieee80211vap_profile vap_profile[IEEE80211_VAP_PROFILE_MAX_VAPS];
+    int num_vaps;
+};
+
+#define MU_MAX_ALGO          3
+
+typedef enum {
+    MU_STATUS_SUCCESS,
+    MU_STATUS_BUSY,
+    MU_STATUS_FAIL,
+} mu_status_t;
+
+struct event_data_mu_rpt {
+    u_int8_t        mu_req_id;                 /* MU request id, copied from the request */
+    u_int8_t        mu_channel;                /* IEEE channel number on which MU was done */
+    mu_status_t     mu_status;                 /* whether the MU scan was successful or not */
+    u_int32_t       mu_total_val[MU_MAX_ALGO]; /* the total MU computed by the algos */
+    u_int32_t       mu_num_bssid;              /* number of active BSSIDs */
+    u_int32_t       mu_actual_duration;        /* time in ms for which the MU scan was done */
+};
+
+typedef enum {
+    SCAN_SUCCESS,
+    SCAN_FAIL,
+} scan_status_t;
+
+struct event_data_scan {
+    u_int8_t        scan_req_id;               /* AP scan request id, copied from the request */
+    scan_status_t   scan_status;               /* whether the AP scan was successful or not */
+};
+
+#endif /* _NET80211_IEEE80211_IOCTL_H_ */
diff -Naur hostapd-2.9/src/drivers/ieee80211_phytype.h hostapd-2.9-new/src/drivers/ieee80211_phytype.h
--- hostapd-2.9/src/drivers/ieee80211_phytype.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ieee80211_phytype.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2012 Qualcomm Atheros, Inc.
+ * All Rights Reserved.
+ * Qualcomm Atheros Confidential and Proprietary.
+ */
+
+#ifndef _IEEE80211_PHYTYPE__H_
+#define _IEEE80211_PHYTYPE__H_
+
+
+/*
+ * phy type definitions.
+ * do not change the order of these
+ * defines .
+ */
+enum ieee80211_phytype {
+    IEEE80211_T_DS,                 /* direct sequence spread spectrum */
+    IEEE80211_T_FH,                 /* frequency hopping */
+    IEEE80211_T_OFDM,               /* frequency division multiplexing */
+    IEEE80211_T_TURBO,              /* high rate OFDM, aka turbo mode */
+    IEEE80211_T_HT,                 /* HT - full GI */
+    IEEE80211_T_ERP,
+    IEEE80211_T_ANY,
+    IEEE80211_T_MAX
+};
+#define IEEE80211_T_CCK IEEE80211_T_DS  /* more common nomenclature */
+
+
+#endif /* _IEEE80211_PHYTYPE__H_ */
diff -Naur hostapd-2.9/src/drivers/ieee80211_rrm.h hostapd-2.9-new/src/drivers/ieee80211_rrm.h
--- hostapd-2.9/src/drivers/ieee80211_rrm.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ieee80211_rrm.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,284 @@
+/*
+ *  Copyright (c) 2014 Qualcomm Atheros, Inc.  All rights reserved. 
+ *
+ *  Qualcomm is a trademark of Qualcomm Incorporated, registered in the United
+ *  States and other countries.  All Qualcomm Incorporated trademarks are used with
+ *  permission.  Atheros is a trademark of Qualcomm Atheros, Inc., registered in
+ *  the United States and other countries.  Other products and brand names may be
+ *  trademarks or registered trademarks of their respective owners. 
+ */
+
+#ifndef _IEEE80211_RRM_H_
+#define _IEEE80211_RRM_H_ 
+
+#define IEEE80211_RRM_CHAN_MAX            255
+
+#define IEEE80211_RRM_NUM_CHANREQ_MAX 5
+#define IEEE80211_RRM_NUM_CHANREP_MAX 2
+
+struct ieee80211_beaconreq_chaninfo {
+    u_int8_t regclass;
+    u_int8_t numchans;
+    u_int8_t channum[IEEE80211_RRM_NUM_CHANREQ_MAX];
+};
+
+typedef struct ieee80211_rrm_beaconreq_info_s {
+    u_int16_t   num_rpt;
+    u_int8_t    regclass;
+    u_int8_t    channum;
+    u_int16_t   random_ivl;
+    u_int16_t   duration;
+    u_int8_t    reqmode;
+    u_int8_t    reqtype;
+    u_int8_t    bssid[6];
+    u_int8_t    mode;
+    u_int8_t    req_ssid;
+    u_int8_t    rep_cond;
+    u_int8_t    rep_thresh;
+    u_int8_t    rep_detail;
+    u_int8_t    req_ie;
+    u_int8_t    num_chanrep;
+    struct ieee80211_beaconreq_chaninfo
+              apchanrep[IEEE80211_RRM_NUM_CHANREP_MAX];
+}ieee80211_rrm_beaconreq_info_t;
+
+typedef struct ieee80211_rrm_chloadreq_info_s{
+    u_int8_t dstmac[6];
+    u_int16_t num_rpts;
+    u_int8_t regclass;
+    u_int8_t chnum;
+    u_int16_t r_invl;
+    u_int16_t m_dur;
+    u_int8_t cond;
+    u_int8_t c_val;
+}ieee80211_rrm_chloadreq_info_t;
+
+typedef struct ieee80211_rrm_nhist_info_s{
+    u_int16_t num_rpts;
+    u_int8_t dstmac[6];
+    u_int8_t regclass;
+    u_int8_t chnum;
+    u_int16_t r_invl;
+    u_int16_t m_dur;
+    u_int8_t cond;
+    u_int8_t c_val;
+}ieee80211_rrm_nhist_info_t;
+
+typedef struct ieee80211_rrm_frame_req_info_s{
+    u_int8_t dstmac[6];
+    u_int8_t peermac[6];
+    u_int16_t num_rpts;
+    u_int8_t regclass;
+    u_int8_t chnum;
+    u_int16_t r_invl;
+    u_int16_t m_dur;
+    u_int8_t ftype;
+}ieee80211_rrm_frame_req_info_t;
+
+typedef struct ieee80211_rrm_lcireq_info_s
+{
+    u_int8_t dstmac[6];
+    u_int16_t num_rpts;
+    u_int8_t location;
+    u_int8_t lat_res;
+    u_int8_t long_res;
+    u_int8_t alt_res;
+    u_int8_t azi_res;
+    u_int8_t azi_type;
+}ieee80211_rrm_lcireq_info_t;
+
+typedef struct ieee80211_rrm_stastats_info_s{
+    u_int8_t dstmac[6];
+    u_int16_t num_rpts;
+    u_int16_t m_dur;
+    u_int16_t r_invl;
+    u_int8_t  gid;
+}ieee80211_rrm_stastats_info_t;
+
+typedef struct ieee80211_rrm_tsmreq_info_s {
+    u_int16_t   num_rpt;
+    u_int16_t   rand_ivl;
+    u_int16_t   meas_dur;
+    u_int8_t    reqmode;
+    u_int8_t    reqtype;
+    u_int8_t    tid;
+    u_int8_t    macaddr[6];
+    u_int8_t    bin0_range;
+    u_int8_t    trig_cond;
+    u_int8_t    avg_err_thresh;
+    u_int8_t    cons_err_thresh;
+    u_int8_t    delay_thresh;
+    u_int8_t    meas_count;
+    u_int8_t    trig_timeout;
+}ieee80211_rrm_tsmreq_info_t;
+
+typedef struct ieee80211_rrm_nrreq_info_s {
+    u_int8_t dialogtoken;
+    u_int8_t ssid[32];
+    u_int8_t ssid_len;
+}ieee80211_rrm_nrreq_info_t;
+
+struct ieee80211_rrmreq_info {
+    u_int8_t rm_dialogtoken;
+    u_int8_t rep_dialogtoken;
+    u_int8_t bssid[6];
+    u_int16_t duration;
+    u_int8_t chnum;
+    u_int8_t regclass;
+    u_int8_t gid;
+    u_int8_t location; /* Location of requesting/reporting station */
+    u_int8_t lat_res;  /* Latitute resolution */
+    u_int8_t long_res; /* Longitude resolution */
+    u_int8_t alt_res;  /* Altitude resolution */
+    u_int8_t reject_type;
+    u_int8_t reject_mode;
+};
+
+typedef struct ieee80211_rrm_lci_data_s
+{
+  u_int8_t id;
+  u_int8_t len;
+  u_int8_t lat_res;
+  u_int8_t alt_type;
+  u_int8_t long_res;
+  u_int8_t alt_res;
+  u_int8_t azi_res;
+  u_int8_t alt_frac;
+  u_int8_t datum;
+  u_int8_t azi_type;
+  u_int16_t lat_integ;
+  u_int16_t long_integ;
+  u_int16_t azimuth;
+  u_int32_t lat_frac;
+  u_int32_t long_frac;
+  u_int32_t alt_integ;
+}ieee80211_rrm_lci_data_t;
+
+typedef struct ieee80211_rrm_statsgid10_s{
+    u_int8_t ap_avg_delay;
+    u_int8_t be_avg_delay;
+    u_int8_t bk_avg_delay;
+    u_int8_t vi_avg_delay;
+    u_int8_t vo_avg_delay;
+    u_int16_t st_cnt;
+    u_int8_t ch_util;
+}ieee80211_rrm_statsgid10_t;
+
+typedef struct ieee80211_rrm_statsgid0_s{
+    u_int32_t txfragcnt;
+    u_int32_t mcastfrmcnt;
+    u_int32_t failcnt;
+    u_int32_t rxfragcnt;
+    u_int32_t mcastrxfrmcnt;
+    u_int32_t fcserrcnt;
+    u_int32_t txfrmcnt;
+}ieee80211_rrm_statsgid0_t;
+
+typedef struct ieee80211_rrm_statsgid1_s{
+    u_int32_t rty;
+    u_int32_t multirty;
+    u_int32_t frmdup;
+    u_int32_t rtsuccess;
+    u_int32_t rtsfail;
+    u_int32_t ackfail;
+}ieee80211_rrm_statsgid1_t;
+
+typedef struct ieee80211_rrm_statsgidupx_s {
+    u_int32_t qostxfragcnt;
+    u_int32_t qosfailedcnt;
+    u_int32_t qosrtycnt;
+    u_int32_t multirtycnt;
+    u_int32_t qosfrmdupcnt;
+    u_int32_t qosrtssuccnt;
+    u_int32_t qosrtsfailcnt;
+    u_int32_t qosackfailcnt;
+    u_int32_t qosrxfragcnt;
+    u_int32_t qostxfrmcnt;
+    u_int32_t qosdiscadrfrmcnt;
+    u_int32_t qosmpdurxcnt;
+    u_int32_t qosrtyrxcnt;
+}ieee80211_rrm_statsgidupx_t;
+
+typedef struct ieee80211_rrm_tsm_data_s
+{
+    u_int8_t tid;
+    u_int8_t brange;
+    u_int8_t mac[6];
+    u_int32_t tx_cnt;
+    u_int32_t discnt;
+    u_int32_t multirtycnt;
+    u_int32_t cfpoll;
+    u_int32_t qdelay;
+    u_int32_t txdelay;
+    u_int32_t bin[6];
+}ieee80211_rrm_tsm_data_t;
+
+typedef struct ieee80211_frmcnt_data_s
+{
+    u_int8_t phytype;
+    u_int8_t arcpi;
+    u_int8_t lrsni;
+    u_int8_t lrcpi;
+    u_int8_t antid;
+    u_int8_t ta[6];
+    u_int8_t bssid[6];
+    u_int16_t frmcnt;
+}ieee80211_rrm_frmcnt_data_t;
+
+typedef struct ieee80211_rrm_lm_data_s
+{
+    u_int8_t tx_pow;
+    u_int8_t lmargin;
+    u_int8_t rxant;
+    u_int8_t txant;
+    u_int8_t rcpi;
+    u_int8_t rsni;
+}ieee80211_rrm_lm_data_t;
+
+typedef struct ieee80211_rrm_noise_data_s
+{
+    u_int8_t antid;
+    int8_t anpi;
+    u_int8_t ipi[11];
+}ieee80211_rrm_noise_data_t;
+
+typedef struct ieee80211_rrm_node_stats_s 
+{
+    ieee80211_rrm_statsgid0_t   gid0;
+    ieee80211_rrm_statsgid1_t   gid1;
+    ieee80211_rrm_statsgidupx_t gidupx[8]; /* from 0 to seven */
+    ieee80211_rrm_statsgid10_t  gid10;
+    ieee80211_rrm_tsm_data_t    tsm_data;
+  
+    /* as per specification length can maximum be 228 */
+    ieee80211_rrm_frmcnt_data_t frmcnt_data[12];
+    ieee80211_rrm_lm_data_t     lm_data;
+    ieee80211_rrm_lci_data_t    ni_rrm_lciinfo; /* RRM LCI information of this node */
+    ieee80211_rrm_lci_data_t    ni_vap_lciinfo; /* RRM LCI information of VAP wrt this node */
+}ieee80211_rrm_node_stats_t;
+
+
+/* RRM statistics */
+typedef struct ieee80211_rrmstats_s 
+{
+    u_int8_t                    chann_load[IEEE80211_RRM_CHAN_MAX];
+    ieee80211_rrm_noise_data_t  noise_data[IEEE80211_RRM_CHAN_MAX];
+    ieee80211_rrm_node_stats_t  ni_rrm_stats;
+}ieee80211_rrmstats_t;
+
+/* to user level */
+typedef struct ieee80211_bcnrpt_s {
+    u_int8_t bssid[6];
+    u_int8_t rsni;
+    u_int8_t rcpi;
+    u_int8_t chnum;
+    u_int8_t more;
+}ieee80211_bcnrpt_t; 
+
+typedef struct ieee80211req_rrmstats_s {
+    u_int32_t index;
+    u_int32_t data_size;
+    void *data_addr;
+}ieee80211req_rrmstats_t;
+
+#endif /* _IEEE80211_RRM_PROTO_H_ */
diff -Naur hostapd-2.9/src/drivers/ieee80211_wnm_proto.h hostapd-2.9-new/src/drivers/ieee80211_wnm_proto.h
--- hostapd-2.9/src/drivers/ieee80211_wnm_proto.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/ieee80211_wnm_proto.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,347 @@
+/*
+ *  Copyright (c) 2014 Qualcomm Atheros, Inc.  All rights reserved. 
+ *
+ *  Qualcomm is a trademark of Qualcomm Incorporated, registered in the United
+ *  States and other countries.  All Qualcomm Incorporated trademarks are used with
+ *  permission.  Atheros is a trademark of Qualcomm Atheros, Inc., registered in
+ *  the United States and other countries.  Other products and brand names may be
+ *  trademarks or registered trademarks of their respective owners. 
+ */
+
+#ifndef _IEEE80211_WNM_PROTO_H_
+#define _IEEE80211_WNM_PROTO_H_ 
+
+#include <sys/queue.h>
+
+/*
+ * Wireless Network management Protocol definitions
+ */
+
+/* categories */
+#define IEEE80211_ACTION_CAT_WNM    10   /* Wireless Network Management */
+#define IEEE80211_ACTION_CAT_UNPROTECTED_WNM    11   /* UnProtected WNM */
+
+
+/* WNM action fields */
+#define IEEE80211_ACTION_TIM_FRAME     0
+#define IEEE80211_ACTION_BSTM_QUERY    6
+#define IEEE80211_ACTION_BSTM_REQ      7
+#define IEEE80211_ACTION_BSTM_RESP     8
+#define IEEE80211_ACTION_FMS_REQ       9 
+#define IEEE80211_ACTION_FMS_RESP      10
+#define IEEE80211_ACTION_TFS_REQ       13
+#define IEEE80211_ACTION_TFS_RESP      14
+#define IEEE80211_ACTION_TFS_NOTIFY    15
+#define IEEE80211_ACTION_WNMSLEEP_REQ  16
+#define IEEE80211_ACTION_WNMSLEEP_RESP 17
+#define IEEE80211_ACTION_TIM_REQ       18
+#define IEEE80211_ACTION_TIM_RESP      19
+
+/* Information Element IDs */
+#define IEEE80211_ELEMID_WNMSLEEP_MODE  93
+enum {
+    IEEE80211_SUBELEMID_KEYDATA_GTK = 0,
+    IEEE80211_SUBELEMID_KEYDATA_IGTK = 1,
+};
+
+#define IEEE80211_WNMSLEEP_ACTION_ENTER 0
+#define IEEE80211_WNMSLEEP_ACTION_EXIT  1
+
+/* WNM action frame dialogtokens */
+#define IEEE80211_ACTION_RM_TOKEN    1
+
+#define IEEE80211_TFS_DELETE   0x01
+#define IEEE80211_TFS_NOTIFY   0x02
+#define IEEE80211_IPV4_LEN 4
+#define IEEE80211_IPV6_LEN 16
+
+#define IEEE80211_FMS_MAX_COUNTERS     8
+#define IEEE80211_FMS_STATUS_SUBELE    1
+#define IEEE80211_TCLASS_STATUS_SUBELE 2
+
+#define IEEE80211_FMS_SUBELEMENT_ID 1
+
+#define IEEE80211_WNM_NETLINKBUF 4096
+#define MAC_ADDR_LEN 6
+
+typedef struct wnm_netlink_event {
+    u_int32_t type;
+    u_int8_t mac[MAC_ADDR_LEN];
+    u_int32_t datalen;
+    u_int8_t event_data[IEEE80211_WNM_NETLINKBUF];
+}__packed wnm_netlink_event_t;
+
+
+enum {
+    IEEE80211_WNM_TIMREQUEST_ACCEPT,
+    IEEE80211_WNM_TIMREQUEST_ACCEPT_VALID_TSF,
+    IEEE80211_WNM_TIMREQUEST_DENIED,
+    IEEE80211_WNM_TIMREQUEST_OVERRIDDEN,
+};
+enum {
+    IEEE80211_WNM_FMSSUBELE_ACCEPT,
+    IEEE80211_WNM_FMSSUBELE_DENY_FORMAT,
+    IEEE80211_WNM_FMSSUBELE_DENY_RESOURCES,
+    IEEE80211_WNM_FMSSUBELE_DENY_CLASSIFIER,
+    IEEE80211_WNM_FMSSUBELE_DENY_POLICY,
+    IEEE80211_WNM_FMSSUBELE_DENY_UNSPECIFIED,
+    IEEE80211_WNM_FMSSUBELE_ALTE_DEL_ITVL,
+    IEEE80211_WNM_FMSSUBELE_ALTE_POLICY,
+    IEEE80211_WNM_FMSSUBELE_ALTE_DEL_ITVL_CHANGE,
+    IEEE80211_WNM_FMSSUBELE_ALTE_MCAST_RATE_CHANGE,
+    IEEE80211_WNM_FMSSUBELE_TERM_POLICY_CHANGE,
+    IEEE80211_WNM_FMSSUBELE_TERM_LACK_RESOURCES,
+    IEEE80211_WNM_FMSSUBELE_TERM_HIGHER_PRI,
+    IEEE80211_WNM_FMSSUBELE_ALTE_MAX_DEL_ITVL_CHG,
+    IEEE80211_WNM_FMSSUBELE_ALTE_TCLASS,
+    IEEE80211_WNM_FMSSUBELE_RESERVED,
+};
+
+
+struct tclas_type3 {
+    u_int16_t filter_offset;
+    u_int8_t  *filter_value;
+    u_int8_t  *filter_mask;
+    u_int8_t  filter_len;
+} __packed;
+
+
+struct tclas_type4_v4 {
+    u_int8_t  version;
+    u_int8_t  src_ip[IEEE80211_IPV4_LEN];
+    u_int8_t  dst_ip[IEEE80211_IPV4_LEN];
+    u_int16_t src_port;
+    u_int16_t dst_port;
+    u_int8_t  dscp;
+    u_int8_t  protocol;
+    u_int8_t  reserved;
+} __packed;
+
+struct tclas_type4_v6 {
+    u_int8_t version;
+    u_int8_t  src_ip[IEEE80211_IPV6_LEN];
+    u_int8_t  dst_ip[IEEE80211_IPV6_LEN];
+    u_int16_t src_port;
+    u_int16_t dst_port;
+    u_int8_t  dscp;
+    u_int8_t  next_header;
+    u_int8_t  flow_label[3];
+} __packed;
+
+typedef struct tclas_element {
+    u_int8_t  elemid;
+    u_int8_t  len;
+    u_int8_t  up;
+    u_int8_t  type;
+    u_int8_t  mask;
+    union {
+        struct tclas_type3  type3;
+        union {
+            struct tclas_type4_v4  type4_v4;
+            struct tclas_type4_v6  type4_v6;
+        } type4;
+    } tclas;
+    TAILQ_ENTRY(tclas_element) tclas_next;
+} __packed ieee80211_tclas_element;
+
+typedef struct ieee80211_tclas_processing {
+    u_int8_t elem_id;
+    u_int8_t length;
+    u_int8_t tclas_process;
+} __packed ieee80211_tclas_processing;
+    
+
+typedef struct ieee80211_tfs_subelement_rsp {
+    u_int8_t elem_id;
+    u_int8_t length;
+    u_int8_t status;
+    u_int8_t tfsid;
+    TAILQ_ENTRY(ieee80211_tfs_subelement_rsp) tsub_next;
+} __packed ieee80211_tfs_subelement_rsp;
+
+typedef struct ieee80211_tfs_subelement_req {
+    TAILQ_HEAD(, tclas_element) tclas_head;
+    u_int8_t elem_id;
+    u_int8_t length;
+    struct ieee80211_tclas_processing tclasprocess;
+    TAILQ_ENTRY(ieee80211_tfs_subelement_req) tsub_next;
+} __packed ieee80211_tfs_subelement_req;
+
+typedef struct ieee80211_tfs_response {
+    TAILQ_ENTRY(ieee80211_tfs_response) tfs_rsp_next;
+    u_int8_t tfs_elemid;
+    u_int8_t length;
+    TAILQ_HEAD(, ieee80211_tfs_subelement_rsp) tfs_rsp_sub;
+} __packed ieee80211_tfs_response;
+
+typedef struct ieee80211_tfs_request {
+    TAILQ_ENTRY(ieee80211_tfs_request) tfs_req_next;
+    u_int8_t tfs_elemid;
+    u_int8_t length;
+    u_int8_t tfs_id;
+    u_int8_t tfs_action_code;
+    TAILQ_HEAD(, ieee80211_tfs_subelement_req) tfs_req_sub;
+} __packed ieee80211_tfs_request;
+
+struct ieee80211_tfsreq{
+    u_int8_t dialogtoken;
+    TAILQ_HEAD(, ieee80211_tfs_request)  tfs_req_head;
+}__packed;
+
+struct ieee80211_tfsrsp {
+    u_int8_t dialogtoken;
+    TAILQ_HEAD(, ieee80211_tfs_response)  tfs_rsp_head;
+}__packed;
+
+struct ieee80211_bstm_reqinfo {
+    u_int8_t dialogtoken;
+    u_int8_t candidate_list;
+    u_int8_t disassoc;
+    u_int16_t disassoc_timer;
+    u_int8_t validity_itvl;
+} __packed;
+
+enum IEEE80211_TFS_ERRORS {
+    IEEE80211_TFS_ACCEPT = 0,
+    IEEE80211_TFS_INVALID_CLASSIFIER,
+    IEEE80211_TFS_RESOURCE_UNAVAILABLE,
+    IEEE80211_TFS_REASON_UNKNOWN = 5,
+};
+
+/* Flexible Multicast Service(FMS) Types */
+
+typedef struct ieee80211_rate_identifier_s {
+    u_int8_t mask;
+    u_int8_t mcs_idx;
+    u_int16_t rate;
+}__packed ieee80211_fms_rate_identifier_t;
+
+typedef struct ieee80211_fmsreq_subele_s
+{
+    TAILQ_ENTRY(ieee80211_fmsreq_subele_s) fmssubele_next;
+    u_int8_t accepted;
+    u_int8_t num_tclas;
+    u_int8_t elem_id;
+    u_int8_t len;
+    u_int8_t del_itvl;
+    u_int8_t max_del_itvl;
+    ieee80211_fms_rate_identifier_t rate_id;
+    u_int8_t mcast_addr[6];
+    TAILQ_HEAD(, tclas_element) tclas_head;
+    struct ieee80211_tclas_processing tclasprocess;
+}__packed ieee80211_fmsreq_subele_t;
+
+
+typedef struct ieee80211_fms_subelement_status_s 
+{
+    TAILQ_ENTRY (ieee80211_fms_subelement_status_s) subele_status_next;
+    u_int8_t len;
+    u_int8_t element_status;
+    u_int8_t del_itvl;
+    u_int8_t max_del_itvl;
+    u_int8_t fmsid;
+    u_int8_t fms_counter;
+    ieee80211_fms_rate_identifier_t rate_id;
+    u_int8_t mcast_addr[6];
+}ieee80211_fms_subelement_status_t;
+
+typedef struct ieee80211_tclass_subelement_status_s
+{
+    u_int8_t subelementid;
+    u_int8_t len;
+    u_int8_t fmsid;
+    TAILQ_HEAD(, tclas_element) tclas_head;
+    ieee80211_tclas_processing tclasprocess;
+}ieee80211_tclass_subelement_status_t;
+
+typedef struct ieee80211_fms_status_subelement_s 
+{
+    TAILQ_ENTRY(ieee80211_fms_status_subelement_s) status_subele_next;
+    u_int8_t subelementid;
+    void     *subele_status;
+}ieee80211_fms_status_subelement_t;
+
+typedef struct ieee80211_fms_response_s
+{ 
+    TAILQ_ENTRY(ieee80211_fms_response_s) fmsrsp_next;
+    u_int8_t elemid;
+    u_int8_t len;
+    u_int8_t fms_token;
+    TAILQ_HEAD(, ieee80211_fms_status_subelement_s) status_subele_head;
+}ieee80211_fms_response_t;
+
+
+typedef struct ieee80211_fms_request_s {
+    TAILQ_ENTRY(ieee80211_fms_request_s) fmsreq_next;
+    u_int8_t elem_id;
+    u_int8_t len;
+    u_int8_t fms_token;
+    TAILQ_HEAD(, ieee80211_fmsreq_subele_s) fmssubele_head;
+}ieee80211_fms_request_t;
+
+typedef struct ieee80211_fmsreq_active_element {
+    TAILQ_ENTRY(ieee80211_fmsreq_active_element) fmsreq_act_next;
+    u_int8_t fms_token;
+    TAILQ_HEAD(, ieee80211_fms_act_stream_ptr) fmsact_strmptr_head;
+}ieee80211_fmsreq_active_element_t;
+
+struct ieee80211_fmsreq {
+    u_int8_t dialog_token;
+    TAILQ_HEAD(, ieee80211_fms_request_s) fmsreq_head;
+};
+
+struct ieee80211_fmsrsp {
+    u_int8_t dialog_token;
+    TAILQ_HEAD(, ieee80211_fms_response_s) fmsrsp_head;
+};
+
+typedef struct ieee80211_fms_action_hdr_s {
+    u_int8_t  ia_category;
+    u_int8_t  ia_action;
+    u_int8_t  dialogtoken;
+    u_int8_t  fms_ies[1];
+} __packed ieee80211_fms_action_hdr_t;
+
+typedef struct ieee80211_fms_status_tclass_subelement_s {
+    u_int8_t subelement_id;
+    u_int8_t len;
+    u_int8_t fmsid;
+    u_int8_t tclass_elements[1];
+}__packed ieee80211_fms_status_tclass_subelement_t;
+
+typedef struct ieee80211_fms_status_subelements_s {
+    u_int8_t subelement_id;
+    u_int8_t len;
+    u_int8_t element_status;
+    u_int8_t del_itvl;
+    u_int8_t max_del_itvl;
+    u_int8_t fmsid;
+    u_int8_t fms_counter;
+    ieee80211_fms_rate_identifier_t rate_id;
+    u_int8_t mcast_addr[6];
+}__packed ieee80211_fms_status_subelements_t;
+
+typedef struct ieee80211_fms_hdr_s {
+    u_int8_t elementid;
+    u_int8_t len;
+    u_int8_t fms_token;
+}__packed ieee80211_fms_hdr_t;
+
+typedef struct ieee80211_fms_descr_s {
+    u_int8_t elementid;
+    u_int8_t len;
+    u_int8_t num_ctrs;
+    u_int8_t fms_ctrs[1];
+}__packed ieee80211_fms_descr_t;
+
+typedef struct ieee80211_fms_req_s {
+    ieee80211_fms_hdr_t hdr;
+    u_int8_t subelements[1];
+}__packed ieee80211_fms_req_t;
+
+typedef struct ieee80211_fms_resp_s {
+    ieee80211_fms_hdr_t hdr;
+    u_int8_t subelements[1];
+}__packed ieee80211_fms_resp_t;
+
+#endif /* _IEEE80211_WNM_PROTO_H_ */
diff -Naur hostapd-2.9/src/drivers/if_athioctl.h hostapd-2.9-new/src/drivers/if_athioctl.h
--- hostapd-2.9/src/drivers/if_athioctl.h	1969-12-31 20:00:00.000000000 -0400
+++ hostapd-2.9-new/src/drivers/if_athioctl.h	2017-04-29 09:25:03.000000000 -0300
@@ -0,0 +1,870 @@
+/*
+ * Copyright (c) 2010, Atheros Communications Inc. 
+ * All Rights Reserved.
+ * 
+ * Copyright (c) 2011 Qualcomm Atheros, Inc.
+ * All Rights Reserved.
+ * Qualcomm Atheros Confidential and Proprietary.
+ * 
+ */
+
+/*
+ * Ioctl-related defintions for the Atheros Wireless LAN controller driver.
+ */
+#ifndef _DEV_ATH_ATHIOCTL_H
+#define _DEV_ATH_ATHIOCTL_H
+
+#ifdef VOW_LOGLATENCY
+#define ATH_STATS_LATENCY_BINS 45  /* Number of 1024us bins to log latency */
+#define ATH_STATS_LATENCY_CATS 5     /* Number of categories to log latency: 4 access categories + 1 combined */
+#endif
+/* add by David.Dai, for support ath_tool - athtweak */
+#ifndef SIOC80211SCOMMONCMD
+#define SIOC80211SCOMMONCMD    _IOWR('i', 247, struct ieee80211req)
+#endif 
+#ifndef SIOC80211GCOMMONCMD
+ #define SIOC80211GCOMMONCMD    _IOWR('i', 248, struct ieee80211req)
+#endif 
+
+#define ATH_STATS_VI_LOG_LEN 10
+
+#define MAX_BB_PANICS 3
+
+#ifdef ATH_SUPPORT_HTC
+#include "htc_host_struct.h"
+#endif
+
+/* end add, David.Dai */
+/*
+ * 11n tx/rx stats
+ */
+struct ath_11n_stats {
+    u_int32_t   tx_pkts;            /* total tx data packets */
+    u_int32_t   tx_checks;          /* tx drops in wrong state */
+    u_int32_t   tx_drops;           /* tx drops due to qdepth limit */
+    u_int32_t   tx_minqdepth;       /* tx when h/w queue depth is low */
+    u_int32_t   tx_queue;           /* tx pkts when h/w queue is busy */
+    u_int32_t   tx_resetq;          /* tx reset queue instances */
+    u_int32_t   tx_comps;           /* tx completions */
+    u_int32_t   tx_comperror;       /* tx error completions on global failures */
+    u_int32_t   tx_unaggr_comperror; /* tx error completions of unaggregted frames */
+    u_int32_t   tx_stopfiltered;    /* tx pkts filtered for requeueing */
+    u_int32_t   tx_qnull;           /* txq empty occurences */
+    u_int32_t   tx_noskbs;          /* tx no skbs for encapsulations */
+    u_int32_t   tx_nobufs;          /* tx no descriptors */
+    u_int32_t   tx_badsetups;       /* tx key setup failures */
+    u_int32_t   tx_normnobufs;      /* tx no desc for legacy packets */
+    u_int32_t   tx_schednone;       /* tx schedule pkt queue empty */
+    u_int32_t   tx_bars;            /* tx bars sent */
+    u_int32_t   tx_legacy;          /* tx legacy frames sent */
+    u_int32_t   txunaggr_single;    /* tx unaggregate singles sent */
+    u_int32_t   txbar_xretry;       /* tx bars excessively retried */
+    u_int32_t   txbar_compretries;  /* tx bars retried */
+    u_int32_t   txbar_errlast;      /* tx bars last frame failed */
+    u_int32_t   tx_compunaggr;      /* tx unaggregated frame completions */
+    u_int32_t   txunaggr_xretry;    /* tx unaggregated excessive retries */
+    u_int32_t   tx_compaggr;        /* tx aggregated completions */
+    u_int32_t   tx_bawadv;          /* tx block ack window advanced */
+    u_int32_t   tx_bawretries;      /* tx block ack window retries */
+    u_int32_t   tx_bawnorm;         /* tx block ack window additions */
+    u_int32_t   tx_bawupdates;      /* tx block ack window updates */
+    u_int32_t   tx_bawupdtadv;      /* tx block ack window advances */
+    u_int32_t   tx_retries;         /* tx retries of sub frames */
+    u_int32_t   tx_xretries;        /* tx excessive retries of aggregates */
+    u_int32_t   tx_aggregates;      /* tx aggregated pkts sent */
+    u_int32_t   tx_sf_hw_xretries;  /* sub-frames excessively retried in h/w */
+    u_int32_t   tx_aggr_frames;     /* tx total frames aggregated */
+    u_int32_t   txaggr_noskbs;      /* tx no skbs for aggr encapsualtion */
+    u_int32_t   txaggr_nobufs;      /* tx no desc for aggr */
+    u_int32_t   txaggr_badkeys;     /* tx enc key setup failures */
+    u_int32_t   txaggr_schedwindow; /* tx no frame scheduled: baw limited */
+    u_int32_t   txaggr_single;      /* tx frames not aggregated */
+    u_int32_t   txaggr_mimo;        /* tx frames aggregated for mimo */
+    u_int32_t   txaggr_compgood;    /* tx aggr good completions */
+    u_int32_t   txaggr_comperror;   /* tx aggr error completions */
+    u_int32_t   txaggr_compxretry;  /* tx aggr excessive retries */
+    u_int32_t   txaggr_compretries; /* tx aggr unacked subframes */
+    u_int32_t   txunaggr_compretries; /* tx non-aggr unacked subframes */
+    u_int32_t   txaggr_prepends;    /* tx aggr old frames requeued */
+    u_int32_t   txaggr_filtered;    /* filtered aggr packet */
+    u_int32_t   txaggr_fifo;        /* fifo underrun of aggregate */
+    u_int32_t   txaggr_xtxop;       /* txop exceeded for an aggregate */
+    u_int32_t   txaggr_desc_cfgerr; /* aggregate descriptor config error */
+    u_int32_t   txaggr_data_urun;   /* data underrun for an aggregate */
+    u_int32_t   txaggr_delim_urun;  /* delimiter underrun for an aggregate */
+    u_int32_t   txaggr_errlast;     /* tx aggr: last sub-frame failed */
+    u_int32_t   txunaggr_errlast;   /* tx non-aggr: last frame failed */
+    u_int32_t   txaggr_longretries; /* tx aggr h/w long retries */
+    u_int32_t   txaggr_shortretries;/* tx aggr h/w short retries */
+    u_int32_t   txaggr_timer_exp;   /* tx aggr : tx timer expired */
+    u_int32_t   txaggr_babug;       /* tx aggr : BA bug */
+    u_int32_t   txrifs_single;      /* tx frames not bursted */
+    u_int32_t   txrifs_babug;       /* tx rifs : BA bug */
+    u_int32_t   txaggr_badtid;      /* tx aggr : Bad TID */
+    u_int32_t   txrifs_compretries; /* tx rifs unacked subframes */
+    u_int32_t   txrifs_bar_alloc;   /* tx rifs bars allocated */
+    u_int32_t   txrifs_bar_freed;   /* tx rifs bars freed */
+    u_int32_t   txrifs_compgood;    /* tx rifs good completions */
+    u_int32_t   txrifs_prepends;    /* tx rifs old frames requeued */
+    u_int32_t   tx_comprifs;        /* tx rifs completions */
+    u_int32_t   tx_compnorifs;      /* tx not a rifs completion */
+    u_int32_t   rx_pkts;            /* rx pkts */
+    u_int32_t   rx_aggr;            /* rx aggregated packets */
+    u_int32_t   rx_aggrbadver;      /* rx pkts with bad version */
+    u_int32_t   rx_bars;            /* rx bars */
+    u_int32_t   rx_nonqos;          /* rx non qos-data frames */
+    u_int32_t   rx_seqreset;        /* rx sequence resets */
+    u_int32_t   rx_oldseq;          /* rx old packets */
+    u_int32_t   rx_bareset;         /* rx block ack window reset */
+    u_int32_t   rx_baresetpkts;     /* rx pts indicated due to baw resets */
+    u_int32_t   rx_dup;             /* rx duplicate pkts */
+    u_int32_t   rx_baadvance;       /* rx block ack window advanced */
+    u_int32_t   rx_recvcomp;        /* rx pkt completions */
+    u_int32_t   rx_bardiscard;      /* rx bar discarded */
+    u_int32_t   rx_barcomps;        /* rx pkts unblocked on bar reception */
+    u_int32_t   rx_barrecvs;        /* rx pkt completions on bar reception */
+    u_int32_t   rx_skipped;         /* rx pkt sequences skipped on timeout */
+    u_int32_t   rx_comp_to;         /* rx indications due to timeout */
+    u_int32_t   rx_timer_starts;    /* rx countdown timers started */
+    u_int32_t   rx_timer_stops;     /* rx countdown timers stopped */ 
+    u_int32_t   rx_timer_run;       /* rx timeout occurences */
+    u_int32_t   rx_timer_more;      /* rx partial timeout of pending packets */
+    u_int32_t   wd_tx_active;       /* watchdog: tx is active */
+    u_int32_t   wd_tx_inactive;     /* watchdog: tx is not active */
+    u_int32_t   wd_tx_hung;         /* watchdog: tx is hung */
+    u_int32_t   wd_spurious;        /* watchdog: spurious tx hang */
+    u_int32_t   tx_requeue;         /* filter & requeue on 20/40 transitions */
+    u_int32_t   tx_drain_txq;       /* draining tx queue on error */
+    u_int32_t   tx_drain_tid;       /* draining tid buf queue on error */
+    u_int32_t   tx_cleanup_tid;     /* draining tid buf queue on node cleanup */
+    u_int32_t   tx_drain_bufs;      /* buffers drained from pending tid queue */
+    u_int32_t   tx_tidpaused;       /* pausing tx on tid */
+    u_int32_t   tx_tidresumed;      /* resuming tx on tid */
+    u_int32_t   tx_unaggr_filtered; /* unaggregated tx pkts filtered */
+    u_int32_t   tx_aggr_filtered;   /* aggregated tx pkts filtered */
+    u_int32_t   tx_filtered;        /* total sub-frames filtered */
+    u_int32_t   rx_rb_on;           /* total rb-s on  */
+    u_int32_t   rx_rb_off;          /* total rb-s off */
+    u_int32_t   rx_dsstat_err;      /* rx descriptor status corrupted */
+#ifdef ATH_SUPPORT_TxBF
+    u_int32_t   bf_stream_miss;     /* beamform stream mismatch */ 
+    u_int32_t   bf_bandwidth_miss;  /* beamform bandwidth mismatch */ 
+    u_int32_t   bf_destination_miss;/* beamform destination mismatch */ 
+#endif
+
+};
+
+
+
+/*
+ * DFS stats
+ */
+#define DFS_MAX_FILTER  32
+
+struct dfs_filter_stats {
+    u_int32_t       max_pri_count;
+    u_int32_t       max_used_pri;
+    u_int32_t       excess_pri;
+    u_int32_t       pri_threshold_reached;
+    u_int32_t       dur_threshold_reached;
+    u_int32_t       rssi_threshold_reached;
+    u_int32_t       filter_id;
+};
+
+struct ath_dfs_stats {
+    u_int32_t       dfs_stats_valid;
+    u_int32_t       event_count;
+    u_int32_t       chirp_count;
+    u_int32_t       num_filter;
+    struct dfs_filter_stats fstat[DFS_MAX_FILTER];    
+};
+
+struct ath_bb_panic_info {
+    int valid;
+    u_int32_t status;
+    u_int32_t tsf;
+    u_int32_t phy_panic_wd_ctl1;
+    u_int32_t phy_panic_wd_ctl2;
+    u_int32_t phy_gen_ctrl;
+    u_int32_t rxc_pcnt;
+    u_int32_t rxf_pcnt;
+    u_int32_t txf_pcnt;
+    u_int32_t cycles;
+    u_int32_t wd;
+    u_int32_t det;
+    u_int32_t rdar;
+    u_int32_t r_odfm;
+    u_int32_t r_cck;
+    u_int32_t t_odfm;
+    u_int32_t t_cck;
+    u_int32_t agc;
+    u_int32_t src;
+};
+
+struct ath_phy_stats {
+    u_int64_t   ast_tx_rts;   /* RTS success count */
+    u_int64_t   ast_tx_shortretry;/* tx on-chip retries (short). RTSFailCnt */
+    u_int64_t   ast_tx_longretry;/* tx on-chip retries (long). DataFailCnt */
+    u_int64_t   ast_rx_tooshort;/* rx discarded 'cuz frame too short */
+    u_int64_t   ast_rx_toobig;    /* rx discarded 'cuz frame too large */
+    u_int64_t   ast_rx_err; /* rx error */
+    u_int64_t   ast_rx_crcerr;    /* rx failed 'cuz of bad CRC */
+    u_int64_t   ast_rx_fifoerr;    /* rx failed 'cuz of FIFO overrun */
+    u_int64_t   ast_rx_phyerr;    /* rx PHY error summary count */
+    u_int64_t   ast_rx_decrypterr; /* rx decryption error */
+    u_int64_t   ast_rx_demicerr; /* rx demic error */
+    u_int64_t   ast_rx_demicok; /* rx demic ok */
+    u_int64_t   ast_rx_delim_pre_crcerr; /* pre-delimiter crc errors */
+    u_int64_t   ast_rx_delim_post_crcerr; /* post-delimiter crc errors */
+    u_int64_t   ast_rx_decrypt_busyerr; /* decrypt busy errors */
+    u_int64_t   ast_rx_phy[32];    /* rx PHY error per-code counts */
+};
+
+struct ast_mib_mac_stats {
+    u_int32_t   ast_ackrcv_bad;
+    u_int32_t   ast_rts_bad;
+    u_int32_t   ast_rts_good;
+    u_int32_t   ast_fcs_bad;
+    u_int32_t   ast_beacons;
+#ifdef ATH_SUPPORT_HTC
+    HTC_HOST_TGT_MIB_STATS  ast_tgt_stats;
+#endif
+};
+
+struct ath_stats {
+    u_int32_t    ast_watchdog;     /* device reset by watchdog */
+    u_int32_t    ast_resetOnError; /* resets on error */
+    u_int32_t    ast_mat_ucast_encrypted;
+    u_int32_t    ast_mat_rx_recrypt;
+    u_int32_t    ast_mat_rx_decrypt;
+    u_int32_t    ast_mat_key_switch;
+    u_int32_t    ast_hardware;     /* fatal hardware error interrupts */
+    u_int32_t    ast_halresets;    /* HAL resets */
+    u_int32_t    ast_bmiss;        /* beacon miss interrupts */
+    u_int32_t    ast_rxorn;        /* rx overrun interrupts */
+    u_int32_t    ast_rxorn_bmiss;  /* rx overrun and bmiss interrupts: indicate descriptor corruption */
+    u_int32_t    ast_rxeol;        /* rx eol interrupts */
+    u_int32_t    ast_rxeol_recover;/* rx eol interrupt hang recoveries */
+    u_int32_t    ast_txurn;        /* tx underrun interrupts */
+    u_int32_t    ast_txto;         /* tx timeout interrupts */
+    u_int32_t    ast_cst;          /* carrier sense timeout interrupts */
+    u_int32_t    ast_mib;          /* mib interrupts */
+    u_int32_t    ast_rx;           /* rx interrupts */
+    u_int32_t    ast_rxdesc;       /* rx descriptor interrupts */
+    u_int32_t    ast_rxerr;        /* rx error interrupts */
+    u_int32_t    ast_rxnofrm;      /* rx no frame interrupts */
+    u_int32_t    ast_tx;           /* tx interrupts */
+    u_int32_t    ast_txdesc;       /* tx descriptor interrupts */
+    u_int32_t    ast_tim_timer;    /* tim timer interrupts */
+    u_int32_t    ast_bbevent;      /* baseband event interrupts */
+    u_int32_t    ast_rxphy;        /* rx phy error interrupts */
+    u_int32_t    ast_rxkcm;        /* rx key cache miss interrupts */
+    u_int32_t    ast_swba;         /* sw beacon alert interrupts */
+    u_int32_t    ast_brssi;        /* beacon rssi threshold interrupts */
+    u_int32_t    ast_bnr;          /* beacon not ready interrupts */
+    u_int32_t    ast_tim;          /* tim interrupts */
+    u_int32_t    ast_dtim;         /* dtim interrupts */
+    u_int32_t    ast_dtimsync;     /* dtimsync interrupts */
+    u_int32_t    ast_gpio;         /* general purpose IO interrupts */
+    u_int32_t    ast_cabend;       /* cab end interrupts */
+    u_int32_t    ast_tsfoor;       /* tsf out-of-range interrupts */
+    u_int32_t    ast_gentimer;     /* generic timer interrupts */
+    u_int32_t    ast_gtt;          /* global transmit timeout interrupts */
+    u_int32_t    ast_fatal;        /* fatal interrupts */
+    u_int32_t    ast_tx_packets;   /* packet sent on the interface */
+    u_int32_t    ast_rx_packets;   /* packet received on the interface */
+    u_int32_t    ast_tx_mgmt;      /* management frames transmitted */
+    u_int32_t    ast_tx_discard;   /* frames discarded prior to assoc */
+    u_int32_t    ast_tx_invalid;   /* frames discarded 'cuz device gone */
+    u_int32_t    ast_tx_qstop;     /* tx queue stopped 'cuz full */
+    u_int32_t    ast_tx_encap;     /* tx encapsulation failed */
+    u_int32_t    ast_tx_nonode;    /* tx failed 'cuz no node */
+    u_int32_t    ast_tx_nobuf;     /* tx failed 'cuz no tx buffer (data) */
+    u_int32_t    ast_tx_stop;      /* number of times the netif_stop called*/
+    u_int32_t    ast_tx_resume;    /* number of times netif_wake_queue called */
+    u_int32_t    ast_tx_nobufmgt;  /* tx failed 'cuz no tx buffer (mgmt)*/
+    u_int32_t    ast_tx_xretries;  /* tx failed 'cuz too many retries */
+    u_int64_t    ast_tx_hw_retries;/* tx retries in hw, not including RTS and
+                                      successes.
+                                      (approximation only) */
+    u_int64_t    ast_tx_hw_success;/* tx successes indicated by hw */
+    u_int32_t    ast_tx_fifoerr;   /* tx failed 'cuz FIFO underrun */
+    u_int32_t    ast_tx_filtered;  /* tx failed 'cuz xmit filtered */
+    u_int32_t    ast_tx_badrate;   /* tx failed 'cuz bogus xmit rate */
+    u_int32_t    ast_tx_noack;     /* tx frames with no ack marked */
+    u_int32_t    ast_tx_cts;       /* tx frames with cts enabled */
+    u_int32_t    ast_tx_shortpre;  /* tx frames with short preamble */
+    u_int32_t    ast_tx_altrate;   /* tx frames with alternate rate */
+    u_int32_t    ast_tx_protect;   /* tx frames with protection */
+    u_int32_t    ast_rx_orn;       /* rx failed 'cuz of desc overrun */
+    u_int32_t    ast_rx_badcrypt;  /* rx failed 'cuz decryption */
+    u_int32_t    ast_rx_badmic;    /* rx failed 'cuz MIC failure */
+    u_int32_t    ast_rx_nobuf;     /* rx setup failed 'cuz no skbuff */
+    u_int32_t    ast_rx_swdecrypt; /* rx frames sw decrypted due to key miss */
+        u_int32_t       ast_rx_hal_in_progress;
+        u_int32_t       ast_rx_num_data;
+        u_int32_t       ast_rx_num_mgmt;
+        u_int32_t       ast_rx_num_ctl;
+        u_int32_t       ast_rx_num_unknown;
+        u_int32_t       ast_max_pkts_per_intr;
+#define ATH_STATS_MAX_INTR_BKT  512
+    u_int32_t   ast_pkts_per_intr[ATH_STATS_MAX_INTR_BKT+1]; /* counter bucket of packets handled in a single iteration */
+    int8_t      ast_tx_rssi;                    /* tx rssi of last ack */
+    int8_t      ast_tx_rssi_ctl0;               /* tx rssi of last ack [ctl, chain 0] */
+    int8_t      ast_tx_rssi_ctl1;               /* tx rssi of last ack [ctl, chain 1] */
+    int8_t      ast_tx_rssi_ctl2;               /* tx rssi of last ack [ctl, chain 2] */
+    int8_t      ast_tx_rssi_ext0;               /* tx rssi of last ack [ext, chain 0] */
+    int8_t      ast_tx_rssi_ext1;               /* tx rssi of last ack [ext, chain 1] */
+    int8_t      ast_tx_rssi_ext2;               /* tx rssi of last ack [ext, chain 2] */
+    int8_t      ast_rx_rssi;                    /* rx rssi from histogram [combined]*/
+    int8_t      ast_rx_rssi_ctl0;               /* rx rssi from histogram [ctl, chain 0] */
+    int8_t      ast_rx_rssi_ctl1;               /* rx rssi from histogram [ctl, chain 1] */
+    int8_t      ast_rx_rssi_ctl2;               /* rx rssi from histogram [ctl, chain 2] */
+    int8_t      ast_rx_rssi_ext0;               /* rx rssi from histogram [ext, chain 0] */
+    int8_t      ast_rx_rssi_ext1;               /* rx rssi from histogram [ext, chain 1] */
+    int8_t      ast_rx_rssi_ext2;               /* rx rssi from histogram [ext, chain 2] */
+    u_int32_t   ast_be_xmit;                    /* beacons transmitted */
+    u_int32_t   ast_be_nobuf;                    /* no skbuff available for beacon */
+    u_int32_t   ast_per_cal;                    /* periodic calibration calls */
+    u_int32_t   ast_per_calfail;                /* periodic calibration failed */
+    u_int32_t   ast_per_rfgain;                    /* periodic calibration rfgain reset */
+    u_int32_t   ast_rate_calls;                    /* rate control checks */
+    u_int32_t   ast_rate_raise;                    /* rate control raised xmit rate */
+    u_int32_t   ast_rate_drop;                    /* rate control dropped xmit rate */
+    u_int32_t   ast_ant_defswitch;              /* rx/default antenna switches */
+    u_int32_t   ast_ant_txswitch;               /* tx antenna switches */
+    u_int32_t   ast_ant_rx[8];                    /* rx frames with antenna */
+    u_int32_t   ast_ant_tx[8];                    /* tx frames with antenna */
+    u_int64_t   ast_rx_bytes;                    /* total number of bytes received */
+    u_int64_t   ast_tx_bytes;                    /* total number of bytes transmitted */
+    u_int32_t   ast_rx_num_qos_data[16];        /* per tid rx packets (includes duplicates)*/
+    u_int32_t   ast_rx_num_nonqos_data;         /* non qos rx packets    */
+    u_int32_t   ast_txq_packets[16];            /* perq packets sent on the interface for each category */
+    u_int32_t   ast_txq_xretries[16];           /* per q tx failed 'cuz too many retries */
+    u_int32_t   ast_txq_fifoerr[16];            /* per q tx failed 'cuz FIFO underrun */
+    u_int32_t   ast_txq_filtered[16];           /*per q  tx failed 'cuz xmit filtered */
+    u_int32_t   ast_txq_athbuf_limit[16];       /* tx dropped 'cuz of athbuf limit */
+    u_int32_t   ast_txq_nobuf[16];              /* tx dropped 'cuz no athbufs */
+    u_int8_t    ast_num_rxchain;                /* Number of rx chains */
+    u_int8_t    ast_num_txchain;                /* Number of tx chains */
+    struct ath_11n_stats ast_11n_stats;         /* 11n statistics */
+    struct ath_dfs_stats ast_dfs_stats;         /* DFS statistics */
+    u_int32_t   ast_bb_hang;                    /* BB hang detected */
+    u_int32_t   ast_mac_hang;                   /* MAC hang detected */
+#if ATH_WOW
+    u_int32_t   ast_wow_wakeups;                /* count of hibernate and standby wakeups */
+    u_int32_t   ast_wow_wakeupsok;              /* count of wakeups thru WoW */
+    u_int32_t   ast_wow_wakeupserror;           /* count of errored wakeups */
+#if ATH_WOW_DEBUG
+    u_int32_t   ast_normal_sleeps;              /* count of normal sleeps */
+    u_int32_t   ast_normal_wakeups;             /* count of normal wakeups*/
+    u_int32_t   ast_wow_sleeps;                 /* count of wow sleeps */
+    u_int32_t   ast_wow_sleeps_nonet;           /* w/o IP config */
+#endif
+#endif
+#ifdef ATH_SUPPORT_UAPSD
+    u_int32_t   ast_uapsdqnulbf_unavail;        /* no qos null buffers available */
+    u_int32_t   ast_uapsdqnul_pkts;             /* count of qos null frames sent */
+    u_int32_t   ast_uapsdtriggers;              /* count of UAPSD triggers received */
+    u_int32_t   ast_uapsdnodeinvalid;           /* count of triggers for non-UAPSD node */
+    u_int32_t   ast_uapsdeospdata;              /* count of QoS Data with EOSP sent */
+    u_int32_t   ast_uapsddata_pkts;             /* count of UAPSD QoS Data frames sent */
+    u_int32_t   ast_uapsddatacomp;              /* count of UAPSD QoS Data frames completed */
+    u_int32_t   ast_uapsdqnulcomp;              /* count of UAPSD QoS NULL frames completed */
+    u_int32_t   ast_uapsddataqueued;            /* count of UAPSD QoS Data Queued */
+    u_int32_t   ast_uapsdedmafifofull;          /* count of UAPSD trigger frames not processed due to EDMA HW FIFO being full */
+#endif
+#ifdef ATH_SUPPORT_VOWEXT
+    /* VOWEXT stats only. Literally some of the iqueue stats can be re-used here
+     * As part of current release, all vow stats will be added extra and 
+     * re-using will be thought for next release 
+     */
+    /*
+     * ast_vow_ul_tx_calls : Number of frames Upper Layer ( ieee ) tried to send
+     * over each access category. For each of the AC this would denote how many 
+     * frames reached ATH layer.
+     *                       
+     * ast_vow_ath_txq_calls: Subset of ( ast_vow_ul_tx_calls ) that can be
+     * either queued or can be sent immediate, either as an aggregate or as an
+     * normal frame. This counts only frames that can be sent. 
+    */
+    u_int32_t   ast_vow_ul_tx_calls[4]; 
+    u_int32_t   ast_vow_ath_txq_calls[4];
+    u_int32_t   ast_vow_ath_be_drop, ast_vow_ath_bk_drop;
+#endif
+#if ATH_SUPPORT_CFEND
+    u_int32_t ast_cfend_sched;			/* count of CF-END frames scheduled */
+    u_int32_t ast_cfend_sent;   		/* count of CF-END frames sent */
+#endif
+#ifdef VOW_LOGLATENCY
+    u_int32_t ast_retry_delay[ATH_STATS_LATENCY_CATS][ATH_STATS_LATENCY_BINS];
+    u_int32_t ast_queue_delay[ATH_STATS_LATENCY_CATS][ATH_STATS_LATENCY_BINS];
+#endif
+
+#ifdef UMAC_SUPPORT_VI_DBG
+    u_int32_t   vi_timestamp[ATH_STATS_VI_LOG_LEN];      /* h/w assigned timestamp        */
+    u_int8_t    vi_rssi_ctl0[ATH_STATS_VI_LOG_LEN];      /* rx frame RSSI [ctl, chain 0]  */
+    u_int8_t    vi_rssi_ctl1[ATH_STATS_VI_LOG_LEN];      /* rx frame RSSI [ctl, chain 1]  */
+    u_int8_t    vi_rssi_ctl2[ATH_STATS_VI_LOG_LEN];      /* rx frame RSSI [ctl, chain 2]  */
+    u_int8_t    vi_rssi_ext0[ATH_STATS_VI_LOG_LEN];      /* rx frame RSSI [ext, chain 0]  */
+    u_int8_t    vi_rssi_ext1[ATH_STATS_VI_LOG_LEN];      /* rx frame RSSI [ext, chain 1]  */
+    u_int8_t    vi_rssi_ext2[ATH_STATS_VI_LOG_LEN];      /* rx frame RSSI [ext, chain 2]  */
+    u_int8_t    vi_rssi[ATH_STATS_VI_LOG_LEN];
+    u_int8_t    vi_evm0[ATH_STATS_VI_LOG_LEN];           /* evm - chain 0                 */
+    u_int8_t    vi_evm1[ATH_STATS_VI_LOG_LEN];           /* evm - chain 1                 */
+    u_int8_t    vi_evm2[ATH_STATS_VI_LOG_LEN];           /* evm - chain 2                 */
+    u_int8_t    vi_rs_rate[ATH_STATS_VI_LOG_LEN];        /* h/w receive rate index        */
+    u_int32_t   vi_tx_frame_cnt[ATH_STATS_VI_LOG_LEN];   /* Profile count transmit frames */
+    u_int32_t   vi_rx_frame_cnt[ATH_STATS_VI_LOG_LEN];   /* Profile count receive frames  */
+    u_int32_t   vi_rx_clr_cnt[ATH_STATS_VI_LOG_LEN];     /* Profile count receive clear   */
+    u_int32_t   vi_rx_ext_clr_cnt[ATH_STATS_VI_LOG_LEN]; /* Profile count receive clear on ext channel */
+    u_int32_t   vi_cycle_cnt[ATH_STATS_VI_LOG_LEN];      /* Profile count cycle counter   */
+    u_int8_t    vi_stats_index;                          /* Used to index circular buffer used to hold video stats */
+#endif
+#ifdef ATH_SUPPORT_TxBF
+#define MCS_RATE 0x1f
+    u_int8_t    ast_txbf;
+    u_int8_t    ast_lastratecode;
+    u_int32_t   ast_sounding_count;
+    u_int32_t   ast_txbf_rpt_count;
+    u_int32_t   ast_mcs_count[MCS_RATE+1];
+#endif
+#if ATH_RX_LOOPLIMIT_TIMER
+    u_int32_t   ast_rx_looplimit_start;
+    u_int32_t   ast_rx_looplimit_end;
+#endif
+    u_int32_t   ast_chan_clr_cnt;
+    u_int32_t   ast_cycle_cnt;
+    int16_t     ast_noise_floor;
+    struct ast_mib_mac_stats ast_mib_stats;
+    struct ath_bb_panic_info ast_bb_panic[MAX_BB_PANICS];
+};
+
+struct ath_stats_container {
+    u_int32_t         size;
+    struct ath_stats  *address;
+    u_int32_t         offload_if;
+};
+
+struct ath_phy_stats_container {
+    u_int32_t              size;
+    struct ath_phy_stats  *address;
+};
+
+/*
+** Enumeration of parameter IDs
+** This is how the external users refer to specific parameters, which is
+** why it's defined in the external interface
+*/
+
+typedef enum {
+    ATH_PARAM_TXCHAINMASK           =1,
+    ATH_PARAM_RXCHAINMASK           =2,
+    ATH_PARAM_TXCHAINMASKLEGACY     =3,
+    ATH_PARAM_RXCHAINMASKLEGACY     =4,
+    ATH_PARAM_CHAINMASK_SEL         =5,
+    ATH_PARAM_AMPDU                 =6,
+    ATH_PARAM_AMPDU_LIMIT           =7,
+    ATH_PARAM_AMPDU_SUBFRAMES       =8,
+    ATH_PARAM_AGGR_PROT             =9,
+    ATH_PARAM_AGGR_PROT_DUR         =10,
+    ATH_PARAM_AGGR_PROT_MAX         =11,
+    ATH_PARAM_TXPOWER_LIMIT2G       =12,
+    ATH_PARAM_TXPOWER_LIMIT5G       =13,
+    ATH_PARAM_TXPOWER_OVERRIDE      =14,
+    ATH_PARAM_PCIE_DISABLE_ASPM_WK  =15,
+    ATH_PARAM_PCID_ASPM             =16,
+    ATH_PARAM_BEACON_NORESET        =17,
+    ATH_PARAM_CAB_CONFIG            =18,
+    ATH_PARAM_ATH_DEBUG             =19,
+    ATH_PARAM_ATH_TPSCALE           =20,
+    ATH_PARAM_ACKTIMEOUT            =21,
+#ifdef ATH_RB
+    ATH_PARAM_RX_RB                 =22,
+    ATH_PARAM_RX_RB_DETECT          =23,
+    ATH_PARAM_RX_RB_TIMEOUT         =24,
+    ATH_PARAM_RX_RB_SKIPTHRESH      =25,
+#endif
+    ATH_PARAM_AMSDU_ENABLE          =26,
+#if ATH_SUPPORT_IQUE
+    ATH_PARAM_RETRY_DURATION        =27,
+    ATH_PARAM_HBR_HIGHPER           =28,
+    ATH_PARAM_HBR_LOWPER            =29,
+#endif
+    ATH_PARAM_RX_STBC               =30,
+    ATH_PARAM_TX_STBC               =31,
+    ATH_PARAM_LDPC                  =32,
+    ATH_PARAM_LIMIT_LEGACY_FRM      =33,
+    ATH_PARAM_TOGGLE_IMMUNITY       =34,
+    ATH_PARAM_WEP_TKIP_AGGR_TX_DELIM    =35,
+    ATH_PARAM_WEP_TKIP_AGGR_RX_DELIM    =36,
+    ATH_PARAM_GPIO_LED_CUSTOM       =37,
+    ATH_PARAM_SWAP_DEFAULT_LED      =38,
+#if defined(ATH_SUPPORT_WIRESHARK)
+    ATH_PARAM_TAPMONITOR            =39,
+#endif
+#if ATH_SUPPORT_VOWEXT
+    ATH_PARAM_VOWEXT                =40,
+    /*ATH_PARAM_RCA                   =41,*/ /* rate control and 
+                                       aggregation parameters */
+	ATH_PARAM_VSP_ENABLE            =42,
+	ATH_PARAM_VSP_THRESHOLD         =43,
+	ATH_PARAM_VSP_EVALINTERVAL      =44,
+#endif
+#if ATH_VOW_EXT_STATS
+    ATH_PARAM_VOWEXT_STATS          =45,
+#endif
+#ifdef VOW_TIDSCHED
+    ATH_PARAM_TIDSCHED              =46,
+    ATH_PARAM_TIDSCHED_VOQW         =47,
+    ATH_PARAM_TIDSCHED_VIQW         =48,
+    ATH_PARAM_TIDSCHED_BKQW         =49,
+    ATH_PARAM_TIDSCHED_BEQW         =50,
+    ATH_PARAM_TIDSCHED_VOTO         =51,
+    ATH_PARAM_TIDSCHED_VITO         =52,
+    ATH_PARAM_TIDSCHED_BKTO         =53,
+    ATH_PARAM_TIDSCHED_BETO         =54,
+#endif
+#if  ATH_SUPPORT_AOW
+    ATH_PARAM_SW_RETRY_LIMIT        =55,
+    ATH_PARAM_AOW_LATENCY           =56,
+    ATH_PARAM_AOW_STATS             =57,
+    ATH_PARAM_AOW_LIST_AUDIO_CHANNELS   =58,
+    ATH_PARAM_AOW_PLAY_LOCAL            =59,
+    ATH_PARAM_AOW_CLEAR_AUDIO_CHANNELS  =60,
+    ATH_PARAM_AOW_ER                    =61,
+    ATH_PARAM_AOW_EC                    =62,
+    ATH_PARAM_AOW_EC_FMAP               =63,
+#endif  /* ATH_SUPPORT_AOW */
+    /*Thresholds for interrupt mitigation*/
+    ATH_PARAM_RIMT_FIRST                =64,
+    ATH_PARAM_RIMT_LAST                 =65,
+    ATH_PARAM_TIMT_FIRST                =66,
+    ATH_PARAM_TIMT_LAST                 =67,
+#ifdef VOW_LOGLATENCY
+    ATH_PARAM_LOGLATENCY                =68,
+#endif
+    ATH_PARAM_TXBF_SW_TIMER             =69,
+    ATH_PARAM_PHYRESTART_WAR            =70,
+    ATH_PARAM_CHANNEL_SWITCHING_TIME_USEC    =71,
+    ATH_PARAM_KEYSEARCH_ALWAYS_WAR      = 72,
+#ifdef ATH_SUPPORT_DYN_TX_CHAINMASK
+    ATH_PARAM_DYN_TX_CHAINMASK          =73,
+#endif /* ATH_SUPPORT_DYN_TX_CHAINMASK */
+#if ATH_SUPPORT_VOWEXT
+    ATH_PARAM_VSP_STATS                 =74,
+    ATH_PARAM_VSP_STATSCLR              =75,
+#endif
+
+#if UMAC_SUPPORT_SMARTANTENNA
+    ATH_PARAM_SMARTANTENNA          = 76,
+#endif    
+#if ATH_SUPPORT_AGGR_BURST
+    ATH_PARAM_AGGR_BURST                =77,
+    ATH_PARAM_AGGR_BURST_DURATION       =78,
+#endif
+
+#if ATH_SUPPORT_FLOWMAC_MODULE
+    ATH_PARAM_FLOWMAC                   =79,
+#endif
+    ATH_PARAM_BCN_BURST                 =80,
+#if ATH_ANI_NOISE_SPUR_OPT
+    ATH_PARAM_NOISE_SPUR_OPT            =81,
+#endif
+    ATH_PARAM_DCS_ENABLE                =82,
+#if UMAC_SUPPORT_PERIODIC_PERFSTATS
+    ATH_PARAM_PRDPERFSTAT_THRPUT_ENAB  = 83,
+    ATH_PARAM_PRDPERFSTAT_THRPUT_WIN   = 84,
+    ATH_PARAM_PRDPERFSTAT_THRPUT       = 85,
+    ATH_PARAM_PRDPERFSTAT_PER_ENAB     = 86,
+    ATH_PARAM_PRDPERFSTAT_PER_WIN      = 87,
+    ATH_PARAM_PRDPERFSTAT_PER          = 88,
+#endif /* UMAC_SUPPORT_PERIODIC_PERFSTATS */
+    ATH_PARAM_TOTAL_PER                = 89,
+    ATH_PARAM_AMPDU_RX_BSIZE            =90,
+#if ATH_SUPPORT_RX_PROC_QUOTA   
+    ATH_PARAM_CNTRX_NUM                =91,
+#endif   
+   ATH_PARAM_RTS_CTS_RATE              =92,
+#if ATH_SUPPORT_VOW_DCS
+    ATH_PARAM_DCS_COCH                  =93,
+    ATH_PARAM_DCS_TXERR                 =94,
+    ATH_PARAM_DCS_PHYERR                =95,
+#endif
+#if UMAC_SUPPORT_SMARTANTENNA
+    ATH_PARAM_SMARTANT_TRAIN_MODE   = 96,    /* smart antenna training mode implicit or explicit*/
+    ATH_PARAM_SMARTANT_TRAIN_TYPE   = 97,    /* smart antenna train type frame base or protocol based */
+    ATH_PARAM_SMARTANT_PKT_LEN      = 98,    /* packet length of the training packet */
+    ATH_PARAM_SMARTANT_NUM_PKTS     = 99,    /* number of packets need to send for training */
+    ATH_PARAM_SMARTANT_TRAIN_START  = 100,    /* start smart antenna training */
+    ATH_PARAM_SMARTANT_NUM_ITR      = 101,    /* number of iterations needed for training */
+    ATH_PARAM_SMARTANT_CURRENT_ANTENNA = 102, /* current smart antenna used for TX */
+    ATH_PARAM_SMARTANT_DEFAULT_ANTENNA = 103, /* default antenna for RX */
+    ATH_PARAM_SMARTANT_TRAFFIC_GEN_TIMER = 104,      /* Self packet generation timer value configuration */
+    ATH_PARAM_SMARTANT_RETRAIN = 105,         /* Smart antenna retrain enable/disable */
+    ATH_PARAM_SMARTANT_RETRAIN_THRESHOLD = 106,    /* number of packets required for retrain check */
+    ATH_PARAM_SMARTANT_RETRAIN_INTERVAL = 107,    /* periodic retrain interval */
+    ATH_PARAM_SMARTANT_RETRAIN_DROP = 108,    /* % change in goodput to tigger performance training */
+    ATH_PARAM_SMARTANT_MIN_GOODPUT_THRESHOLD = 109, /* Minimum Good put threshold to tigger performance training */
+    ATH_PARAM_SMARTANT_GOODPUT_AVG_INTERVAL =  110, /* Number of intervals Good put need to be averaged to use in performance training tigger */
+#endif
+#if ATH_RX_LOOPLIMIT_TIMER
+    ATH_PARAM_LOOPLIMIT_NUM                 =  111,
+#endif
+#if ATH_TX_DUTY_CYCLE
+    ATH_PARAM_TX_DUTY_CYCLE            = 112,
+#endif
+    ATH_PARAM_NODEBUG              = 113,
+    ATH_PARAM_GET_IF_ID			= 114,
+    ATH_PARAM_ALLOW_PROMISC = 115,
+    ATH_PARAM_ANTENNA_GAIN_2G           =116,
+    ATH_PARAM_ANTENNA_GAIN_5G           =117,
+    ATH_PARAM_ACS_ENABLE_BK_SCANTIMEREN = 118,  /*Enable Acs back Ground Channel selection Scan timer in AP mode*/	
+    ATH_PARAM_ACS_SCANTIME = 119,  /* ACS scan timer value in Seconds */
+    ATH_PARAM_ACS_RSSIVAR = 120,   /*Negligence Delta RSSI between two channel */
+    ATH_PARAM_ACS_CHLOADVAR = 121, /*Negligence Delta Channel load between two channel*/
+    ATH_PARAM_ACS_LIMITEDOBSS = 122, /* Enable Limited OBSS check */
+    ATH_PARAM_ACS_CTRLFLAG   = 123, /* Acs control flag for Scan timer */
+    ATH_PARAM_ACS_DEBUGTRACE = 124, /* Acs Run time Debug level*/
+#if ATH_SUPPORT_HYFI_ENHANCEMENTS
+    ATH_PARAM_BUFF_THRESH               =125,
+#endif
+    ATH_PARAM_BLK_REPORT_FLOOD          =126,
+    ATH_PARAM_DROP_STA_QUERY            =127,
+#if ATH_SUPPORT_DSCP_OVERRIDE
+    ATH_PARAM_DSCP_OVERRIDE             =128,
+    ATH_PARAM_DSCP_TID_MAP_RESET        =129,
+    ATH_PARAM_IGMP_DSCP_OVERRIDE        =130,
+    ATH_PARAM_IGMP_DSCP_TID_MAP         =131,
+    ATH_PARAM_HMMC_DSCP_OVERRIDE        =132,
+    ATH_PARAM_HMMC_DSCP_TID_MAP         =133,
+    ATH_PARAM_UPNP_DSCP_OVERRIDE        =134,
+    ATH_PARAM_UPNP_DSCP_TID_MAP         =135,
+#endif
+#if ATH_SUPPORT_HYFI_ENHANCEMENTS
+	ATH_PARAM_ALDSTATS                  = 136,
+#endif
+    ATH_PARAM_SET_FW_HANG_ID            = 137,
+    ATH_PARAM_RADIO_TYPE                = 138,
+    ATH_PARAM_FW_RECOVERY_ID		= 139,
+    ATH_PARAM_RATE_ENABLE_RTS           = 140,
+    ATH_PARAM_EN_SELECTIVE_RTS          = 141,
+    ATH_PARAM_ATH_RXQ_INFO              = 142,
+    ATH_PARAM_RESET_OL_STATS            = 143,
+    ATH_PARAM_DISABLE_DFS               = 144,
+    ATH_PARAM_DECLINE_ADDBA_ENABLE      = 145,
+    ATH_PARAM_ATF_STRICT_SCHED          = 146,
+} ath_param_ID_t;
+
+#define ATH_TX_POWER_SRM 0
+
+#ifndef WIN32
+struct ath_diag {
+    char    ad_name[IFNAMSIZ];    /* if name, e.g. "ath0" */
+    u_int16_t ad_id;
+#define    ATH_DIAG_DYN    0x8000        /* allocate buffer in caller */
+#define    ATH_DIAG_IN    0x4000        /* copy in parameters */
+#define    ATH_DIAG_OUT    0x0000        /* copy out results (always) */
+#define    ATH_DIAG_ID    0x0fff
+    u_int16_t ad_in_size;        /* pack to fit, yech */
+    caddr_t    ad_in_data;
+    caddr_t    ad_out_data;
+    u_int    ad_out_size;
+};
+
+#ifdef _MAVERICK_STA_
+/* need to handle case where userland uses different sized
+ * pointers than kernel, mostly x86_64 UL and 32-bit kernel
+ */
+struct ath_diag64 {
+	char	    ad_name[IFNAMSIZ];                              /* 16 bytes */
+	u_int16_t   ad_id;                                          /*  2 bytes */
+	u_int16_t   ad_in_size;                                     /*  2 bytes */
+	u_int64_t   ad_in_data __attribute__((aligned(8)));         /*  8 bytes */
+	u_int64_t   ad_out_data;                                    /*  8 bytes */
+	u_int	    ad_out_size;                                    /*  4 bytes */
+};
+#define SIOCGATHDIAG_64        _IOWR('i', 138, struct ath_diag64)
+#define SIOCGATHTX99_64        _IOWR('i', 143, struct ath_diag64)
+
+struct ath_diag32 {
+	char	    ad_name[IFNAMSIZ];                              /* 16 bytes */
+	u_int16_t   ad_id;                                          /*  2 bytes */
+	u_int16_t   ad_in_size;                                     /*  2 bytes */
+	u_int32_t   ad_in_data;                                     /*  4 bytes */
+	u_int32_t   ad_out_data;                                    /*  4 bytes */
+	u_int       ad_out_size;                                    /*  4 bytes */
+};
+#define SIOCGATHDIAG_32        _IOWR('i', 138, struct ath_diag32)
+#define SIOCGATHTX99_32        _IOWR('i', 143, struct ath_diag32)
+#endif
+
+#define    ATH_RADAR_MUTE_TIME    1    /* Set dfs mute time for dfs test mode */
+
+#ifdef __linux__
+#define SIOCGATHSTATS       (SIOCDEVPRIVATE+0)
+#define SIOCGATHDIAG        (SIOCDEVPRIVATE+1)
+#define SIOCGATHCWMINFO     (SIOCDEVPRIVATE+2)
+#define SIOCGATHCWMDBG      (SIOCDEVPRIVATE+3)
+#define SIOCGATHSTATSCLR    (SIOCDEVPRIVATE+4)
+#define SIOCGATHPHYERR      (SIOCDEVPRIVATE+5)
+#define SIOCGATHEACS        (SIOCDEVPRIVATE+6)
+#define SIOCGATHAOW         (SIOCDEVPRIVATE+8)
+#define SIOCSATHSUSPEND     (SIOCDEVPRIVATE+10)
+/* Currently exposed only for Linux, as part of some Access Point
+   statistics.
+   TODO: Implement for other platforms, if required. */
+#define SIOCGATHPHYSTATS    (SIOCDEVPRIVATE+11)
+#define SIOCG80211PROFILE     (SIOCDEVPRIVATE+12)
+/* 13 for TX99 */
+#define SIOCGATHPHYSTATSCUR (SIOCDEVPRIVATE+14)
+#define SIOCGSETCTLPOW   	(SIOCDEVPRIVATE+15)
+
+#define ATH_HAL_IOCTL_SETPARAM              (SIOCIWFIRSTPRIV+0)
+#define ATH_HAL_IOCTL_GETPARAM              (SIOCIWFIRSTPRIV+1)
+#define ATH_IOCTL_SETCOUNTRY                (SIOCIWFIRSTPRIV+2)
+#define ATH_IOCTL_GETCOUNTRY                (SIOCIWFIRSTPRIV+3)
+#define ATH_IOCTL_SETHWADDR                 (SIOCIWFIRSTPRIV+4)
+#define ATH_IOCTL_GETHWADDR                 (SIOCIWFIRSTPRIV+5)
+#define ATH_IOCTL_SET_DSCP_TID_MAP          (SIOCIWFIRSTPRIV+6)
+#define ATH_IOCTL_GET_DSCP_TID_MAP          (SIOCIWFIRSTPRIV+7)
+#if ATH_SUPPORT_DSCP_OVERRIDE
+#define OL_ATH_IOCTL_SET_DSCP_TID_MAP       (SIOCIWFIRSTPRIV+8)
+#define OL_ATH_IOCTL_GET_DSCP_TID_MAP       (SIOCIWFIRSTPRIV+9)
+#endif
+/* Both Direct attach and OL uses same IOCTL defines */
+#define ATH_IOCTL_SET_SMART_ANTENNA   	(SIOCIWFIRSTPRIV+11)
+#define ATH_IOCTL_GET_SMART_ANTENNA   	(SIOCIWFIRSTPRIV+12)
+
+
+
+
+
+#define ATH_GET_COUNTRY                     1
+#define ATH_SET_COUNTRY                     2
+
+/* NOTE that ATH_IOCTL_EXTENDED corresponds to AR6000_IOCTL_EXTENDED from
+ * the TOBA tree - this was necessary for interoperation between simulator
+ * binary built in toba and the driver built in the newma tree.
+ *
+ * With qca_main, the simulator is built in the same workspace as the host
+ * driver, but the idea of using ATH_IOCTL_EXTENDED to allow an expanded
+ * range of ioctls remains.
+ * The simulator ioctls are defined in sim_io.h, and start at 200.
+ */
+#if !defined(ATH_IOCTL_EXTENDED)
+#define ATH_IOCTL_EXTENDED               (SIOCIWFIRSTPRIV+31)
+#endif
+
+
+/*
+** We have to do a "split" of ID values, since they are all combined
+** into the same table.  This value is a "shift" value for ATH parameters
+*/
+
+#define ATH_PARAM_SHIFT     0x1000
+#define SPECIAL_PARAM_SHIFT 0x2000
+
+#else /* __linux__ */
+
+struct ath_privreq {
+    char        ap_name[IFNAMSIZ];    /* if_name, e.g. "wi0" */
+    u_int16_t    ap_type;        /* req type */
+    int16_t        ap_val;            /* Index or simple value */
+    int16_t        ap_len;            /* Index or simple value */
+    void        *ap_data;        /* Extra data */
+};
+#define SIOCATHPRIV        _IOWR('i', 140, struct ath_privreq)
+#define SIOCGATHSTATS       _IOWR('i', 137, struct ifreq)
+#define SIOCGATHDIAG        _IOWR('i', 138, struct ath_diag)
+#define SIOCGATHCWMINFO     _IOWR('i', 139, struct ath_cwminfo)
+#ifndef REMOVE_PKT_LOG
+#define SIOCGATHPKT         _IOWR('i', 141, struct ath_pktlog_ioctl)
+#endif /* REMOVE_PKT_LOG */
+#define SIOCGATHPHYERR      _IOWR('i', 142, struct ath_diag)
+#define SIOCGATHTX99        _IOWR('i', 143, struct ath_diag)
+#define SIOCGATHEACS        _IOWR('i', 145, struct ifreq)
+#define SIOCGATHCWMDBG      _IOWR('i', 146, struct ath_cwmdbg)
+#define SIOCGATHSTATSCLR    _IOWR('i', 147, struct ifreq)
+
+/* ifreq, for athstats */
+/* the system version of struct ifreq hides ifru_data64 from us in userland */
+struct	ath_ifreq {
+	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	union {
+		caddr_t	ifru_data;
+	} ifr_ifru;
+};
+#ifdef _MAVERICK_STA_
+struct	ath_ifreq32 {
+	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	union {
+		u_int32_t	ifru_data;
+	} ifr_ifru;
+};
+
+struct	ath_ifreq64 {
+	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	union {
+		u_int64_t	ifru_data;
+	} ifr_ifru __attribute__((aligned(8)));
+};
+#define	aifr_data	ifr_ifru.ifru_data	/* for use by interface */
+/* don't use struct ifreq anymore */
+#undef SIOCGATHSTATS
+#define SIOCGATHSTATS       _IOWR('i', 137, struct ath_ifreq)
+#define SIOCGATHSTATS_32     _IOWR('i', 137, struct ath_ifreq32)
+#define SIOCGATHSTATS_64     _IOWR('i', 137, struct ath_ifreq64)
+#endif /* _MAVERICK_STA_ */
+
+/*
+ * packet_log support.
+ */
+#ifndef REMOVE_PKT_LOG
+struct ieee80211com;
+int ath_ioctl_pktlog(struct ieee80211com *, u_long, caddr_t);
+
+struct ath_pktlog_ioctl {
+    char    ap_name[IFNAMSIZ];    /* ifname, e.g. "ath0" */
+    u_int16_t    ap_cmd;
+    u_int32_t    ap_val;
+    caddr_t    ap_data;
+    u_int32_t    ap_data_size;
+};
+
+#ifdef _MAVERICK_STA_
+/* pktlog */
+struct ath_pktlog_ioctl64 {
+    char	ap_name[IFNAMSIZ];	/* ifname, e.g. "ath0" */       /* 16 bytes */
+    u_int16_t	ap_cmd;                                         /*  2 bytes */
+    u_int32_t	ap_val;                                         /*  4 bytes */
+    u_int64_t	ap_data __attribute__((aligned(8)));            /*  8 bytes */
+    u_int32_t	ap_data_size;                                   /*  4 bytes */
+};
+#define SIOCGATHPKT_64         _IOWR('i', 141, struct ath_pktlog_ioctl64)
+
+struct ath_pktlog_ioctl32 {
+    char	ap_name[IFNAMSIZ];	/* ifname, e.g. "ath0" */       /* 16 bytes */
+    u_int16_t	ap_cmd;                                         /*  2 bytes */
+    u_int32_t	ap_val __attribute__((aligned(4)));             /*  4 bytes */
+    u_int32_t	ap_data;                                        /*  4 bytes */
+    u_int32_t	ap_data_size;                                   /*  4 bytes */
+};
+#define SIOCGATHPKT_32         _IOWR('i', 141, struct ath_pktlog_ioctl32)
+#endif /* _MAVERICK_STA_ */
+
+#define    ATH_PKT_ENABLE        1
+#define    ATH_PKT_SETSIZE       2
+#define    ATH_PKT_READ          3 /* Kept for compatibility with the old code */
+#define    ATH_PKT_RESET         4
+#define    ATH_PKT_GETSIZE       5
+#define    ATH_PKT_GETBUF        6
+#define    ATH_PKT_GET_LOGSTATE  7
+
+#endif /* REMOVE_PKT_LOG */
+
+#endif /* __linux__ */
+
+#endif /* #ifndef WIN32 */
+#endif /* _DEV_ATH_ATHIOCTL_H */
+
